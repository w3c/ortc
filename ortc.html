<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8">
        <title>Object RTC (ORTC) API for WebRTC</title>
        <script src="http://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
        <script src="respec-config.js" class="remove"></script>
    </head>
    <body>
        <section id="abstract">
            <p>
                This document defines a set of ECMAScript APIs in WebIDL to allow media to be sent and received
                from another browser or device implementing the appropriate set of real-time protocols. However,
                unlike the WebRTC 1.0 API, Object Real-Time Communications (ORTC) does not
                utilize Session Description Protocol (SDP) in the API,
                nor does it mandate support for the Offer/Answer state machine (though an application
                is free to choose SDP and Offer/Answer as an on-the-wire signaling mechanism).
                Instead, ORTC uses "sender", "receiver" and "transport" objects, which have
                "capabilities" describing what they are capable of doing,
                as well as "parameters" which define what they are configured to do.
                "Tracks" are encoded by senders and sent over transports, then decoded by receivers while
                "data channels" are sent over transports directly.
            </p>
        </section>
        <section id="sotd"></section>
        <section id="overview*">
            <h2><span class="secno"> </span>Overview</h2>
            <p>
                Object Real-Time Communications (ORTC) provides a powerful API for the development of WebRTC based applications.
                ORTC does not utilize Session Description Protocol (SDP) in the API, nor does it mandate support for the Offer/Answer
                state machine (though an application
                is free to choose SDP and Offer/Answer as an on-the-wire signaling mechanism).
                Instead, ORTC uses "sender", "receiver" and "transport" objects, which have
                "capabilities" describing what they are capable of doing,
                as well as "parameters" which define what they are configured to do.
                "Tracks" are encoded by senders and sent over transports, then decoded by receivers while
                "data channels" are sent over transports directly.
            </p>
            <p>
                In a Javascript application utilizing the ORTC API,
                the relationship between the application and the objects, as well
                as between the objects themselves is shown below.
                Horizontal or slanted arrows denote the flow of media or data,
                whereas vertical arrows denote interactions via methods and events.
            </p>
            <figure>
                <img alt="The non-normative ORTC Big Picture Diagram" src="images/ortc-bigy-picture.svg" style="width:100%" />
                <figcaption>
                   Non-normative ORTC Big Picture Diagram
                </figcaption>
            </figure>
            <p>
                In the figure above, the <code><a>RTCRtpSender</a></code> (<a href="#rtcrtpsender*">Section 5</a>) encodes the
                track provided as input, which is transported over a <code><a>RTCDtlsTransport</a></code>
                (<a href="#rtcdtlstransport*">Section 4</a>).
                An <code><a>RTCDataChannel</a></code> (<a href="#rtcdatachannel*">Section 11</a>) utilizes an
                <code><a>RTCSctpTransport</a></code> (<a href="#sctp-transport*">Section 12</a>) which can also be multiplexed
                over the <code><a>RTCDtlsTransport</a></code>.
                Sending of Dual Tone Multi Frequency (DTMF) tones is supported via the
                <code><a>RTCDtmfSender</a></code> (<a href="#rtcdtmfsender*">Section 10</a>).
            </p>
            <p>
                The <code><a>RTCDtlsTransport</a></code> utilizes an <code><a>RTCIceTransport</a></code>
                (<a href="#rtcicetransport*">Section 3</a>) to select a communication path to reach the
                receiving peer's <code><a>RTCIceTransport</a></code>, which is in turn associated with
                an <code><a>RTCDtlsTransport</a></code> which de-multiplexes
                media to the <code><a>RTCRtpReceiver</a></code> (<a href="#rtcrtpreceiver*">Section 6</a>) and
                data to the <code><a>RTCSctpTransport</a></code> and <code><a>RTCDataChannel</a></code>.
                The <code><a>RTCRtpReceiver</a></code> then decodes media, producing a track which is rendered
                by an audio or video tag.
            </p>
            <p>
                Several other objects also play a role.
                The <code><a>RTCIceGatherer</a></code> (<a href="#rtcicegatherer*">Section 2</a>) gathers local ICE candidates for use by one or
                more <code><a>RTCIceTransport</a></code> objects, enabling forking scenarios.
                The <code><a>RTCIceTransportController</a></code> (<a href="#rtcicetransportcontroller*">Section 7</a>)
                manages freezing/unfreezing (defined in [[!RFC5245]]) and bandwidth estimation.
                The <code><a>RTCRtpListener</a></code> (<a href="#rtcrtplistener*">Section 8</a>) detects whether an RTP stream is received that
                cannot be delivered to any existing <code><a>RTCRtpReceiver</a></code>, providing an <code>onunhandledrtp</code> event handler that the application can use
                to correct the situation.
            </p>
            <p>
                Remaining sections of the specification fill in details relating to RTP capabilities and parameters,
                operational statistics, media authentication via Certificates and Identity Providers (IdP) and compatibility with the
                WebRTC 1.0 API.
                RTP dictionaries are described in <a href="#rtcrtpdictionaries*">Section 9</a>,
                the Statistics API is described in <a href="#statistics-api">Section 13</a>,
                the Identity API is described in <a href="#identity-api">Section 14</a>,
                the Certificate API is described in <a href="#certificate-api">Section 15</a>,
                an event summary is provided in <a href="#event-summary">Section 16</a>,
                WebRTC 1.0 compatibility issues are discussed in <a href="#webrtc-compat*">Section 17</a>,
                and complete examples are provided in <a href="#examples*">Section 18</a>.
            </p>
            <section>
                <h3>Terminology</h3>
                <p>
                    The <code><a href="http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
                    interface, representing a callback used for event handlers, and the
                    <a href="http://dev.w3.org/html5/spec/webappapis.html#errorevent"><code><dfn>ErrorEvent</dfn></code></a>
                    interface are defined in [[!HTML5]].
                </p>
                <p>
                    The concepts <dfn><a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a></dfn>,
                    <dfn><a href= "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a simple event</a></dfn>
                    and <dfn><a href="http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking task source</a></dfn>
                    are defined in [[!HTML5]].
                </p>
                <p>
                    The terms <dfn>event</dfn>,
                    <dfn><a href="http://dev.w2.org/html5/spec/webappapis.html#event-handlers">event handlers</a></dfn>
                    and <dfn><a href= "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event handler event types</a></dfn>
                    are defined in [[!HTML5]].
                </p>
                <p>
                    The terms <dfn>MediaStream</dfn>, <dfn>MediaStreamTrack</dfn>, and <dfn>MediaStreamConstraints</dfn> are defined in [[!GETUSERMEDIA]].
                </p>
            </section>
            <section>
                <h3>Scope</h3>
                <p>
                    For Scalable Video Coding (SVC), the terms single-session transmission (<dfn>SST</dfn>) and multi-session transmission (<dfn>MST</dfn>)
                    are defined in [[RFC6190]]. This specification only supports <a>SST</a> but not <a>MST</a>.
                    The term Single Real-time transport protocol stream Single Transport (<dfn>SRST</dfn>),
                    defined in [[RFC7656]] Section 3.7, refers to an SVC implementation that transmits all layers within a
                    single transport, using a single Real-time Transport Protocol (RTP) stream and synchronization source (SSRC).
                    The term Multiple RTP stream Single Transport (<dfn>MRST</dfn>), also defined in [[RFC7656]] Section 3.7, refers
                    to an implementation that transmits all layers within a single transport, using multiple RTP streams with
                    a distinct SSRC for each layer. This specification supports SVC codecs utilizing <a>SRST</a> transport
                    (such as with H.264/SVC, VP8 and VP9). Also, sending of simulcast is supported.  SVC codecs supporting
                    <a>MRST</a> transport (such as H.264/SVC and HEVC) can also be supported, along with reception of simulcast.
                    However, these features should be considered experimental, since implementation experience is limited.
                </p>
                <div class="note">
                    At the time of publication, there were two ORTC implementations supporting simulcast reception.
                    Since neither implementation supported [[!RFC6051]], mechanisms needed to be provided to handle
                    intermingling of received simulcast streams due to reordering. The ORTC Lib
                    implementation deals with this by utilizing timing heuristics as well as "hidden" receivers
                    for each received simulcast stream, with each "hidden" receiver producing a "hidden" track.
                    The "hidden" tracks are then mixed internally to produce a single
                    <code><a>MediaStreamTrack</a></code> <code>RTCRtpReceiver.track</code>.
                </div>
            </section>
        </section>
        <section id="rtcicegatherer*">
            <h2>The RTCIceGatherer Object</h2>
            <p>
                The <dfn><code>RTCIceGatherer</code></dfn> gathers local host, server reflexive and relay candidates, as
                well as enabling the retrieval of local Interactive Connectivity Establishment (ICE) parameters which can be exchanged in signaling.
                By enabling an endpoint to use a set of local candidates to construct
                multiple <code><a>RTCIceTransport</a></code> objects, the <code><a>RTCIceGatherer</a></code>
                enables support for scenarios such as parallel forking.
            </p>
            <section id="rtcicegatherer-overview*">
                <h3>Overview</h3>
                <p>
                    An <code><a>RTCIceGatherer</a></code> instance can be associated to multiple <code><a>RTCIceTransport</a></code> objects.
                    The <code><a>RTCIceGatherer</a></code> does not prune local candidates until at least one <code><a>RTCIceTransport</a></code>
                    object has become associated and all associated <code><a>RTCIceTransport</a></code> objects are in the <code>completed</code> or
                    <code>failed</code> state.
                </p>
                <p>
                    As noted in [[!RFC5245]] Section 7.1.2.2, an incoming connectivity check contains an <code>ICE-CONTROLLING</code>
                    or <code>ICE-CONTROLLED</code> attribute, depending on the role of the ICE agent initiating the check.
                    Since an <code><a>RTCIceGatherer</a></code> object does not have a role, it cannot determine whether
                    to respond to an incoming connectivity check with a 487 (Role Conflict) error; however, it can validate
                    that an incoming connectivity check utilizes the correct local username fragment and password,
                    and if not, can respond with an
                    401 (Unauthorized) error, as described in [[!RFC5389]] Section 10.1.2.
                </p>
                <p>
                    For incoming connectivity checks that pass validation, the <code><a>RTCIceGatherer</a></code>
                    <em class="rfc2119" title="MUST">MUST</em>
                    buffer the incoming connectivity checks so as to be able to provide them to associated
                    <code><a>RTCIceTransport</a></code> objects so that they can respond.
                </p>
            </section>
            <section id="rtcicegatherer-operation*">
                <h3>Operation</h3>
                <p>
                  An <code><a>RTCIceGatherer</a></code> instance is constructed from an <code><a>RTCIceGatherOptions</a></code> object.
                </p>
                <p>
                    An <code><a>RTCIceGatherer</a></code> object in the <code>closed</code> state can be garbage-collected
                    when it is no longer referenced.
                </p>
            </section>
            <section id="rtcicegatherer-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCIceGatherer : RTCStatsProvider">
                    <dt>Constructor(RTCIceGatherOptions options)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCIceComponent component</dt>
                    <dd>
                        <p>The component-id of the <code><a>RTCIceGatherer</a></code> object.  In <code><a>RTCIceGatherer</a></code>
                        objects returned by <code>createAssociatedGatherer()</code> the value of <var>component</var> is <code>RTCP</code>.
                        In all other <code><a>RTCIceGatherer</a></code> objects, the value of <var>component</var> is <code>RTP</code>.
                        </p>
                    </dd>
                    <dt>readonly attribute RTCIceGathererState state</dt>
                    <dd>
                        <p>The current state of the ICE gatherer.</p>
                    </dd>
                    <dt>void close()</dt>
                    <dd>
                        <p>
                            Prunes all local candidates, and closes the port. Associated <code><a>RTCIceTransport</a></code>
                            objects transition to the <code>disconnected</code> state
                            (unless they were in the <code>failed</code> state).
                            Calling <code>close()</code> when <var>state</var> is <code>closed</code> has no effect.
                        </p>
                    </dd>
                    <dt>void gather(optional RTCIceGatherOptions options)</dt>
                    <dd>
                        <p>
                            Gather ICE candidates. If <var>options</var> is omitted, utilize the value
                            of <var>options</var> passed in the constructor.
                        </p>
                    </dd>
                    <dt>RTCIceParameters getLocalParameters()</dt>
                    <dd>
                        <p>Obtain the ICE parameters of the <code><a>RTCIceGatherer</a></code>.</p>
                    </dd>
                    <dt>sequence&lt;RTCIceCandidate&gt; getLocalCandidates()</dt>
                    <dd>
                        <p>
                            Retrieve the sequence of valid local candidates associated with the
                            <code><a>RTCIceGatherer</a></code>.
                            This retrieves all unpruned local candidates currently known (except for peer reflexive candidates),
                            even if an <code><a>onlocalcandidate</a></code>
                            event hasn't been processed yet. Prior to calling <code>gather()</code> an empty list
                            will be returned.
                        </p>
                    </dd>
                    <dt>RTCIceGatherer createAssociatedGatherer()</dt>
                    <dd>
                        <p>
                            Create an associated <code><a>RTCIceGatherer</a></code> for RTCP, with the same
                            <code><a>RTCIceParameters</a></code> and <code><a>RTCIceGatherOptions</a></code>.
                            If <var>state</var> is <code>closed</code>, throw an <code>InvalidStateError</code> exception.
                            If an <code><a>RTCIceGatherer</a></code> calls the method more than once,
                            or if <var>component</var> is <code>RTCP</code>, throw
                            an <code>InvalidStateError</code> exception.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onstatechange</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code><a>statechange</a></code>,
                            <em class="rfc2119" title="MUST">MUST</em> be fired
                            any time the <code><a>RTCIceGathererState</a></code> changes.
                        <p>
                    </dd>
                    <dt>attribute EventHandler onerror</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code><a>icecandidateerror<a></code>,
                            <em class="rfc2119" title="MUST">MUST</em> be fired if an error occurs in the gathering
                            of ICE candidates (such as if TURN credentials are invalid).
                        </p>
                    </dd>
                    <dt>attribute EventHandler onlocalcandidate</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code>icecandidate</code>, uses
                            the <code><a>RTCIceGathererEvent</a></code> interface.
                            It <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the
                            <code><a>RTCIceGatherer</a></code> interface.
                            It receives events when a new local ICE candidate is available. Since ICE candidate gathering begins once
                            an <code><a>RTCIceGatherer</a></code> object is created,
                            <code>candidate</code> events are queued until an <code>onlocalcandidate</code> event handler is assigned.
                            When the final candidate is gathered, a <code>candidate</code> event occurs with an <code>RTCIceCandidateComplete</code> emitted.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtciceparameters*">
                <h3>The RTCIceParameters Object</h3>
                <p>
                    The <dfn><code>RTCIceParameters</code></dfn> object includes the ICE username fragment
                    and password and other ICE-related parameters.
                </p>
                <dl class="idl" title="dictionary RTCIceParameters">
                    <dt>DOMString usernameFragment</dt>
                    <dd>
                        <p>ICE username fragment.</p>
                    </dd>
                    <dt>DOMString password</dt>
                    <dd>
                        <p>ICE password.</p>
                    </dd>
                    <dt>boolean iceLite</dt>
                    <dd>
                        <p>
                            If only ICE-lite is supported (<code>true</code>) or not (<code>false</code> or unset). Since
                            [[!RTCWEB-TRANSPORT]] Section 3.4 requires browser support for full ICE,
                            <var>iceLite</var> will only be <code>true</code> for a remote peer such as
                            a gateway. <code>getLocalParameters().iceLite</code> MUST NOT be set.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicecandidate*">
                <h3>The RTCIceCandidate Object</h3>
                <p>
                    The <dfn><code>RTCIceCandidate</code></dfn> object includes information relating to an ICE candidate.
                </p>
                <pre class="example highlight">
{
  foundation: "abcd1234",
  priority: 1694498815,
  ip: "192.0.2.33",
  protocol: "udp",
  port: 10000,
  type: "host"
};
                </pre>
                <dl class="idl" title="typedef (RTCIceCandidate or RTCIceCandidateComplete) RTCIceGatherCandidate">
                </dl>
                <dl class="idl" title="dictionary RTCIceCandidate">
                    <dt>DOMString foundation</dt>
                    <dd>
                        <p>A unique identifier that allows ICE to correlate candidates that appear on multiple <code><a>RTCIceTransport</a></code>s.</p>
                    </dd>
                    <dt>unsigned long priority</dt>
                    <dd>
                        <p>The assigned priority of the candidate. This is automatically populated by the browser.</p>
                    </dd>
                    <dt>DOMString ip</dt>
                    <dd>
                        <p>The IP address of the candidate.</p>
                    </dd>
                    <dt>RTCIceProtocol protocol</dt>
                    <dd>
                        <p>The protocol of the candidate (UDP/TCP).</p>
                    </dd>
                    <dt>unsigned short port</dt>
                    <dd>
                        <p>The port for the candidate.</p>
                    </dd>
                    <dt>RTCIceCandidateType type</dt>
                    <dd>
                        <p>The type of candidate.</p>
                    </dd>
                    <dt>RTCIceTcpCandidateType tcpType</dt>
                    <dd>
                        <p>The type of TCP candidate.</p>
                    </dd>
                    <dt>DOMString relatedAddress=""</dt>
                    <dd>
                        <p>
                            For candidates that are derived from others, such as relay or reflexive candidates, the <dfn><code>relatedAddress</code></dfn>
                            refers to the candidate that these are derived from. For host candidates, the <var>relatedAddress</var>
                            is set to the empty string.
                        </p>
                    </dd>
                    <dt>unsigned short relatedPort</dt>
                    <dd>
                        <p>
                            For candidates that are derived from others, such as relay or reflexive candidates, the <dfn><code>relatedPort</code></dfn>
                            refers to the host candidate that these are derived from. For host candidates, the <var>relatedPort</var>
                            is 0.
                        </p>
                    </dd>
                </dl>
                <section>
                    <h4>The RTCIceProtocol</h4>
                    <p>
                        The <dfn><code>RTCIceProtocol</code></dfn> includes the protocol of the ICE candidate.
                    </p>
                    <dl class="idl" title="enum RTCIceProtocol">
                        <dt>udp</dt>
                        <dd>
                            <p>A UDP candidate, as described in [[!RFC5245]].</p>
                        </dd>
                        <dt>tcp</dt>
                        <dd>
                            <p>A TCP candidate, as described in [[!RFC6544]].</p>
                        </dd>
                    </dl>
                </section>
                <section>
                    <h4>The RTCIceTcpCandidateType</h4>
                    <p>
                        The <dfn><code>RTCIceTcpCandidateType</code></dfn> includes the type of the ICE TCP candidate, as described in [[!RFC6544]].
                        Browsers MUST gather active TCP candidates and only active TCP candidates.
                        Servers and other endpoints MAY gather active, passive or so candidates.
                    </p>
                    <dl class="idl" title="enum RTCIceTcpCandidateType">
                        <dt>active</dt>
                        <dd>
                            <p>
                                An active TCP candidate is one for which the transport will
                                attempt to open an outbound connection but will not receive incoming
                                connection requests.
                            </p>
                        </dd>
                        <dt>passive</dt>
                        <dd>
                            <p>
                                A passive TCP candidate is one for which the transport
                                will receive incoming connection attempts but not attempt a
                                connection.
                            </p>
                        </dd>
                        <dt>so</dt>
                        <dd>
                            <p>
                                An so candidate is one for which the transport will attempt
                                to open a connection simultaneously with its peer.
                            </p>
                        </dd>
                    </dl>
                </section>
                <section>
                    <h4>The RTCIceCandidateType</h4>
                    <p>
                        The <dfn><code>RTCIceCandidateType</code></dfn> includes the type of the ICE candidate as defined in [[!RFC5245]] section 15.1.
                    </p>
                    <dl class="idl" title="enum RTCIceCandidateType">
                        <dt>host</dt>
                        <dd>
                            <p>A host candidate, as defined in Section 4.1.1.1 of [[!RFC5245]].</p>
                        </dd>
                        <dt>srflx</dt>
                        <dd>
                            <p>A server reflexive candidate, as defined in Section 4.1.1.2 of [[!RFC5245]].</p>
                        </dd>
                        <dt>prflx</dt>
                        <dd>
                            <p>A peer reflexive candidate, as defined in Section 4.1.1.2 of [[!RFC5245]].</p>
                        </dd>
                        <dt>relay</dt>
                        <dd>
                            <p>A relay candidate, as defined in Section 7.1.3.2.1 of [[!RFC5245]].</p>
                        </dd>
                    </dl>
                </section>
            </section>
            <section id="rtcicecandidatecomplete*">
                <h3>dictionary RTCIceCandidateComplete</h3>
                <p>
                    <dfn><code>RTCIceCandidateComplete</code></dfn> is a dictionary signifying that all <code>RTCIceCandidate</code>s are gathered.
                <p>
                <dl class="idl" title="dictionary RTCIceCandidateComplete">
                    <dt>boolean complete=true</dt>
                    <dd>
                        <p>This attribute is always present and set to <code>true</code>, indicating that ICE candidate gathering is complete.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicegathererstate*">
                <h3>enum RTCIceGathererState</h3>
                <p><dfn><code>RTCIceGathererState</code></dfn> represents the current state of the ICE gatherer.</p>
                <dl class="idl" title="enum RTCIceGathererState">
                    <dt>new</dt>
                    <dd>
                        <p>
                            The object has been created but <code>gather()</code> has not been called.
                        </p>
                    </dd>
                    <dt>gathering</dt>
                    <dd>
                        <p>
                            <code>gather()</code> has been called, and the <code><a>RTCIceGatherer</a></code> is
                            in the process of gathering candidates (which includes adding new candidates and
                            removing invalidated candidates).
                        </p>
                    </dd>
                    <dt>complete</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceGatherer</a></code> has completed gathering. Events such as adding, updating or removing an interface,
                            or adding, changing or removing a TURN server will cause the state to go back to <code>gathering</code> before re-entering
                            <code>complete</code> once all candidate changes are finalized.
                        </p>
                    </dd>
                    <dt>closed</dt>
                    <dd>
                        <p>The <code><a>RTCIceGatherer</a></code> has been closed intentionally (by calling <code>close()</code>).</p>
                    </dd>
                </dl>
            </section>
            <section>
                <h4>RTCIceGathererIceErrorEvent</h4>
                <p>
                    The <code><a>icecandidateerror</a></code> event of the <code><a>RTCIceGatherer</a></code> object uses
                    the <code><a>RTCIceGathererIceErrorEvent</a></code> interface.
                </p>
                <dl class="idl" data-merge="RTCIceGathererIceErrorEventInit"
                    title="interface RTCIceGathererIceErrorEvent : Event">
                    <dt>Constructor(DOMString type, RTCIceGathererIceErrorEventInit eventInitDict)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCIceCandidate? hostCandidate</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceCandidate</a></code> used to communicate with the
                            STUN or TURN server. On a multihomed system, multiple interfaces may be
                            used to contact the server, and this attribute allows the application to
                            figure out on which one the failure occurred. If the browser is in a 
                            privacy mode disallowing host candidates, this attribute will be null.
                        </p>
                        <p>
                            If use of multiple interfaces has been prohibited for privacy reasons,
                            <var>hostCandidate</var> will be null.
                        </p>
                    </dd>
                    <dt>readonly attribute DOMString url</dt>
                    <dd>
                        <p>
                            The <code>url</code> attribute is the STUN or TURN URL identifying
                            the server on which the failure ocurred.
                        </p>
                    </dd>
                    <dt>readonly attribute unsigned short errorCode</dt>
                    <dd>
                        <p>
                            The <code>errorCode</code> attribute is the numeric STUN
                            error code returned by the STUN or TURN server [[STUN-PARAMETERS]].
                        </p>
                        <p>
                            If no host candidate can reach the server, <code>errorCode</code>
                            will be set to a value of 701, as this does not conflict
                            with the STUN error code range, and <var>hostCandidate</var> will be null.
                            This error is only fired once per server URL while in the 
                            <code>RTCIceGathererState</code> of <code>gathering</code>.
                        </p>
                    </dd>
                    <dt>readonly attribute USVString errorText</dt>
                    <dd>
                        <p>
                            The <code>errorText</code> attribute is the STUN reason text
                            returned by the STUN or TURN server [[STUN-PARAMETERS]].
                       </p>
                       <p>
                            If the server could not be reached, <code>errorText</code> will be set
                            to an implementation-specific value providing details about the error.
                       </p>
                    </dd>
                </dl>
                <dl class="idl" title="dictionary RTCIceGathererIceErrorEventInit : EventInit">
                    <dt>RTCIceCandidate hostCandidate</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceCandidate</a></code> used to communicate with the
                            STUN or TURN server.
                        </p>
                    </dd>
                    <dt>DOMString url</dt>
                    <dd>
                        <p>
                            The <code>url</code> attribute is the STUN or TURN URL identifying
                            the server on which the failure ocurred.
                        </p>
                    </dd>
                    <dt>unsigned short errorCode</dt>
                    <dd>
                        <p>
                            The <code>errorCode</code> attribute is the numeric STUN
                            error code returned by the STUN or TURN server [[STUN-PARAMETERS]].
                        </p>
                    </dd>
                    <dt>USVString errorText</dt>
                    <dd>
                        <p>
                            The <code>errorText</code> attribute is the STUN reason text
                            returned by the STUN or TURN server [[STUN-PARAMETERS]].
                       </p>
                    </dd>
                </dl>
            </section>
            <section>
                <h4>RTCIceGathererEvent</h4>
                <p>
                    The <code>icecandidate</code> event of the <code><a>RTCIceGatherer</a></code> object uses
                    the <code><a>RTCIceGathererEvent</a></code> interface.
                </p>
                <p>
                    Firing an
                    <code><a>RTCIceGathererEvent</a></code> event named
                    <var>e</var> with an <code><a>RTCIceCandidate</a></code>
                    <var>candidate</var> and URL <var>url</var> means that an event with the name <var>e</var>,
                    which does not bubble (except where otherwise stated) and is not
                    cancelable (except where otherwise stated), and which uses the
                    <code><a>RTCIceGathererEvent</a></code> interface with the
                    <code>candidate</code> attribute set to the new ICE candidate,
                    <em class="rfc2119" title="MUST">MUST</em> be
                    created and dispatched at the given target.
                </p>
                <dl class="idl" data-merge="RTCIceGathererEventInit"
                    title="interface RTCIceGathererEvent : Event">
                    <dt>Constructor(DOMString type, RTCIceGathererEventInit eventInitDict)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCIceGatherCandidate candidate</dt>
                    <dd>
                        <p>
                            The <code>candidate</code> attribute is the
                            <code><a>RTCIceGatherCandidate</a></code> object with the new ICE
                            candidate that caused the event.
                            If <code>candidate</code> is of type <code>RTCIceCandidateComplete</code>,
                            there are no additional candidates.
                        </p>
                    </dd>
                    <dt>readonly attribute DOMString url</dt>
                    <dd>The URL of the server from which the candidate was obtained.</dd>
                </dl>
                <dl class="idl" title="dictionary RTCIceGathererEventInit : EventInit">
                    <dt>RTCIceGatherCandidate candidate</dt>
                    <dd>
                        <p>The ICE candidate that caused the event.</p>
                    </dd>
                    <dt>DOMString url</dt>
                    <dd>The URL of the server from which the candidate was obtained.</dd>
                </dl>
            </section>
            <section id="rtcicegatheroptions*">
                <h3>dictionary RTCIceGatherOptions</h3>
                <p><dfn><code>RTCIceGatherOptions</code></dfn> provides options relating to the gathering of ICE candidates.</p>
                <dl class="idl" title="dictionary RTCIceGatherOptions">
                    <dt>RTCIceGatherPolicy gatherPolicy</dt>
                    <dd>
                        <p>The ICE gather policy.</p>
                    </dd>
                    <dt>sequence&lt;RTCIceServer&gt; iceServers</dt>
                    <dd>
                        <p>Additional ICE servers to be configured. Since implementations MAY provide default ICE servers,
                        and applications can desire to restrict communications to the local LAN, <var>iceServers</var> need not
                        be set.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicegatherpolicy*">
                <h3>enum RTCIceGatherPolicy</h3>
                <p><dfn><code>RTCIceGatherPolicy</code></dfn> denotes the policy relating to the gathering of ICE candidates.</p>
                <dl class="idl" title="enum RTCIceGatherPolicy">
                    <dt>all</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceGatherer</a></code> gathers all types of candidates
                            when this value is specified. This will not include addresses that have been
                            filtered by the browser.
                        </p>
                    </dd>
                    <dt>nohost</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceGatherer</a></code> gathers all ICE candidate types
                            except for host candidates.
                        </p>
                    </dd>
                    <dt>relay</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceGatherer</a></code> <em class="rfc2119" title="MUST">MUST</em>
                            only gather media relay candidates such as candidates passing through a TURN server.
                            This can be used to reduce leakage of IP addresses in certain use cases.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicecredentialtype*">
                <h3>enum RTCIceCredentialType</h3>
                <p><dfn><code>RTCIceCredentialType</code></dfn> represents the type of credential used by a TURN server.</p>
                <dl class="idl" title="enum RTCIceCredentialType">
                    <dt>password</dt>
                    <dd>
                        <p>The credential is a long-term authentication password, as described in [[!RFC5389]], Section 10.2.</p>
                    </dd>
                    <dt>token</dt>
                    <dd>
                        <p>The credential is an access token, as described in [[RFC7635]], Section 6.2.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtciceserver*">
                <h3>The RTCIceServer Object</h3>
                <p>
                    The <dfn><code>RTCIceServer</code></dfn> is used to provide STUN or TURN server configuration.
                    In network topologies with multiple layers of NATs, it is desirable to have a STUN server
                    between every layer of NATs in addition to the TURN servers to minimize the peer to peer network latency.
                </p>
                <p>
                    An example of an array of <code><a>RTCIceServer</a></code> objects:
                </p>
                <pre class="example highlight">
[
  { urls: "stun:stun1.example.net" },
  { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
    credentialType: "password"}
]
                </pre>
                <dl class="idl" title="dictionary RTCIceServer">
                    <dt>required (DOMString or sequence&lt;DOMString&gt;) urls</dt>
                    <dd>
                        <p>STUN or TURN URI(s) as defined in [[!RFC7064]] and [[!RFC7065]] or other URI types.</p>
                    </dd>
                    <dt>DOMString username</dt>
                    <dd>
                        <p>
                            If this <code><a>RTCIceServer</a></code> object represents a TURN server, then this attribute specifies
                            the username to use with that TURN server.
                        </p>
                    </dd>
                    <dt>DOMString credential</dt>
                    <dd>
                        <p>If this <code><a>RTCIceServer</a></code> represents a TURN server, then this attribute specifies the credential to use with that TURN server.</p>
                    </dd>
                    <dt>RTCIceCredentialType credentialType = "password"</dt>
                    <dd>
                        <p>
                            If this <code><a>RTCIceServer</a></code> object represents a TURN Server, then this
                            attribute specifies how <var>credential</var> should be used when that TURN server requests authorization.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicegatherer-initial-example*">
                <h3>Example</h3>
                <pre class="example highlight">
// Example to demonstrate use of RTCIceCandidateComplete
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

// Create ICE gather options
var gatherOptions = {
  gatherPolicy: "relay",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword", 
      credentialType: "password" }
   ]
};
// Create IceGatherer object
var iceGatherer = new RTCIceGatherer(gatherOptions);

// Handle state changes
iceGatherer.onstatechange = function(event) {
  myIceGathererStateChange("iceGatherer", event.state);
};

// Prepare to signal local candidates
iceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate);
};

// Start gathering
iceGatherer.gather();

// Set up response function
mySignaller.onResponse = function(responseSignaller, response) {
  // We may get N responses
  // ... deal with the N responses as shown in Example 5 of Section 3.11.
};

mySignaller.send({
  "ice": iceGatherer.getLocalParameters()
});
                </pre>
                <pre class="example highlight">
// Helper functions used in all the examples (helper.js)
export function trace(text) {
  // This function is used for logging.
  text = text.trimRight();
  if (window.performance) {
    var now = (window.performance.now() / 1000).toFixed(3);
    console.log(now + ": " + text);
  } else {
    console.log(text);
  }
}

export function errorHandler(error) {
  trace("Error encountered: " + error.name);
}

export function mySendLocalCandidate(candidate, component, kind, parameters) {
  // Set default values
  kind = kind || "all";
  component = component || "RTP";
  parameters = parameters || null;

  // Signal the local candidate
  mySignaller.mySendLocalCandidate({
    "candidate": candidate,
    "component": component,
    "kind": kind,
    "parameters": parameters
  });
}

export function myIceGathererStateChange(name, state) {
  switch (state) {
    case "new": 
      trace("IceGatherer: " + name + " Has been created");
      break;
    case "gathering":
      trace("IceGatherer: " + name + " Is gathering candidates");
      break;
    case "complete":
      trace("IceGatherer: " + name + " Has finished gathering (for now)");
      break;
    case "closed":
      trace("IceGatherer: " + name + " Is closed");
      break;
    default:
      trace("IceGatherer: " + name + " Invalid state");
  }
}

export function myIceTransportStateChange(name, state) {
  switch (state) {
    case "new":
      trace("IceTransport: " + name + " Has been created");
      break;
    case "checking":
      trace("IceTransport: " + name + " Is checking");
      break;
    case "connected":
      trace("IceTransport: " + name + " Is connected");
      break;
    case "disconnected":
      trace("IceTransport: " + name + " Is disconnected");
      break;
    case "completed":
      trace("IceTransport: " + name + " Has finished checking (for now)");
      break;
    case "failed":
      trace("IceTransport: " + name + " Has failed");
      break;
    case "closed":
      trace("IceTransport: " + name + " Is closed");
      break;
    default:
      trace("IceTransport: " + name + " Invalid state");
  }
}

export function myDtlsTransportStateChange(name, state){
  switch(state){
  case "new":
     trace('DtlsTransport: ' + name + ' Has been created');
     break;
  case "connecting":
     trace('DtlsTransport: ' + name + ' Is connecting');
     break;
  case "connected":
     trace('DtlsTransport: ' + name + ' Is connected');
     break;
  case "failed":
     trace('DtlsTransport: ' + name + ' Has failed');
     break;
  case "closed":
     trace('DtlsTransport: ' + name + ' Is closed');
     break;
  default:
     trace('DtlsTransport: ' + name + ' Invalid state');
  }
}
                </pre>
            </section>
        </section>
        <section id="rtcicetransport*">
            <h2>The RTCIceTransport Object</h2>
            <p>
                The <dfn><code>RTCIceTransport</code></dfn> allows an application access to information about the Interactive
                Connectivity Establishment (ICE) transport over which packets are sent and received.
                In particular, ICE manages peer-to-peer connections which involve state which the application may want to access.
            </p>
            <section id="rtcicetransport-overview*">
                <h3>Overview</h3>
                <p>
                    An <code><a>RTCIceTransport</a></code> instance is associated to a transport object (such as <code><a>RTCDtlsTransport</a></code>),
                    and provides RTC related methods to it.
                </p>
            </section>
            <section id="rtcicetransport-operation*">
                <h3>Operation</h3>
                <p>
                    An <code><a>RTCIceTransport</a></code> instance is constructed (optionally) from an <code><a>RTCIceGatherer</a></code>.
                    If <code>gatherer.state</code> is <code>closed</code> or <code>gatherer.component</code> is <code>RTCP</code>, then throw an <code>InvalidStateError</code> exception.
                </p>
                <p>
                    An <code><a>RTCIceTransport</a></code> object in the <code>closed</code> state can be garbage-collected
                    when it is no longer referenced.
                </p>
            </section>
            <section id="rtcicetransport-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCIceTransport : RTCStatsProvider">
                    <dt>Constructor(optional RTCIceGatherer gatherer)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCIceGatherer? iceGatherer</dt>
                    <dd>
                        <p>
                            The <code>iceGatherer</code> attribute is set to the value of <var>gatherer</var> if passed in the constructor or in the latest call to <code>start()</code>.
                        </p>
                    </dd>
                    <dt>readonly attribute RTCIceRole role</dt>
                    <dd>
                        <p>The current role of the ICE transport.</p>
                    </dd>
                    <dt>readonly attribute RTCIceComponent component</dt>
                    <dd>
                        <p>The component-id of the <code><a>RTCIceTransport</a></code> object.  In <code><a>RTCIceTransport</a></code>
                        objects returned by <code>createAssociatedTransport()</code>, the value of <code>component</code> is
                        <code>RTCP</code>.  In all other <code><a>RTCIceTransport</code></a> objects, the value of <code>component</code> is <code>RTP</code>.
                        </p>
                    </dd>
                    <dt>readonly attribute RTCIceTransportState state</dt>
                    <dd>
                        <p>The current state of the ICE transport.</p>
                    </dd>
                    <dt>sequence&lt;RTCIceCandidate&gt; getRemoteCandidates()</dt>
                    <dd>
                        <p>
                            Retrieve the sequence of candidates associated with the remote
                            <code><a>RTCIceTransport</a></code>. Only returns the candidates previously
                            added using <code>setRemoteCandidates()</code> or <code>addRemoteCandidate()</code>.
                            If there are no remote candidates, an empty list is returned.
                        </p>
                    </dd>
                    <dt>RTCIceCandidatePair? getSelectedCandidatePair()</dt>
                    <dd>
                        <p>
                            Retrieves the selected candidate pair on which packets are sent. If there is no selected pair yet,
                            or consent [[!RFC7675]] is lost on the selected pair, NULL is returned.
                        </p>
                    </dd>
                    <dt>void start(RTCIceGatherer gatherer, RTCIceParameters remoteParameters, optional RTCIceRole role)</dt>
                    <dd>
                        <p>
                            The first time <code>start()</code> is called, candidate connectivity checks are started and the
                            ICE transport attempts to connect to the remote <code><a>RTCIceTransport</a></code>.
                            If <code>start()</code> is called with invalid parameters, throw an <code>InvalidParameters</code> exception.
                            For example, if <var>gatherer.component</var> has a value different from <var>iceTransport.component</var>,
                            throw an <code>InvalidParameters</code> exception.  If <var>state</var> or <var>gatherer.state</var> is <code>closed</code>,
                            throw an <code>InvalidStateError</code> exception.  When <code>start()</code> is called again,
                            <code><a>RTCIceTransportState</a></code> transitions to the <code>connected</code> state, all remote candidates
                            are flushed, and <code>addRemoteCandidate()</code> or <code>setRemoteCandidates()</code> must be called
                            to add the remote candidates back or replace them.
                        </p>
                        <p>
                            If a newly constructed <code><a>RTCIceGatherer</a></code> object is passed as an argument when <code>start()</code>
                            is called again, an ICE restart as defined in [[!RFC5245]] Section 9.2.1.1 occurs.
                            Since <code>start()</code> does not change the username fragment and password of <var>gatherer</var>,
                            if <code>start()</code> is called again with the same value of <var>gatherer</var>,
                            the existing local candidates are reused and the ICE username fragment and password remains unchanged.
                            However, other aspects of the behavior are not currently defined.
                        </p>
                        <p>
                            As noted in [[!RFC5245]] Section 7.1.2.3, an incoming connectivity check utilizes the local/remote username fragment
                            and the local password, whereas an outgoing connectivity check utilizes the local/remote username fragment and the
                            remote password. Since <code>start()</code> provides role information, as well as the remote username fragment and password,
                            once <code>start()</code> is called an <code><a>RTCIceTransport</a></code> object
                            can respond to incoming connectivity checks based on its configured role, as well as initiating connectivity checks.
                        </p>
                    </dd>
                    <dt>void stop()</dt>
                    <dd>
                        <p>
                            Stops and closes the current object. Also removes the object from the
                            <code><a>RTCIceTransportController</a></code>.
                            Calling <code>stop()</code> when <var>state</var> is <code>closed</code> has no effect.
                        </p>
                    </dd>
                    <dt>RTCIceParameters? getRemoteParameters()</dt>
                    <dd>
                        <p>Obtain the current ICE parameters of the remote <code><a>RTCIceTransport</a></code>.</p>
                    </dd>
                    <dt>RTCIceTransport createAssociatedTransport ()</dt>
                    <dd>
                        <p>
                            Create an associated <code><a>RTCIceTransport</a></code> for RTCP.
                            If called more than once for the same component, or if <var>state</var> is <code>closed</code>,
                            throw an <code>InvalidStateError</code> exception. If called when
                            <code>component</code> is <code>RTCP</code>,
                            throw an <code>InvalidStateError</code> exception.
                        </p>
                    </dd>
                    <dt>void addRemoteCandidate(RTCIceGatherCandidate remoteCandidate)</dt>
                    <dd>
                        <p>
                            Add a remote candidate associated with the remote <code><a>RTCIceTransport</a></code>.
                            If <code>state</code> is <code>closed</code>, throw an <code>InvalidStateError</code> exception.
                            When the remote <code><a>RTCIceGatherer</a></code> emits its final candidate, <code>addRemoteCandidate()</code> should be called
                            with an <code>RTCIceCandidateComplete</code> dictionary as an argument, so that the local <code><a>RTCIceTransport</a></code> can
                            know there are no more remote candidates expected, and can enter the <code>completed</code> state.
                        </p>
                    </dd>
                    <dt>void setRemoteCandidates(sequence&lt;RTCIceCandidate&gt; remoteCandidates)</dt>
                    <dd>
                        <p>
                            Set the sequence of candidates associated with the remote <code><a>RTCIceTransport</a></code>.
                            If <code>state</code> is <code>closed</code>, throw an <code>InvalidStateError</code> exception.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onstatechange</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code><a>statechange</a></code>,
                            <em class="rfc2119" title="MUST">MUST</em> be fired 
                            any time the <code><a>RTCIceTransportState</a></code> changes.
                        <p>
                    </dd>
                    <dt>attribute EventHandler oncandidatepairchange</dt>
                    <dd>
                        <p>
                            This event handler, of event handler type <code>icecandidatepairchange</code>,
                            uses the <code>RTCIceCandidatePairChangedEvent</code> interface.
                            It <em class="rfc2119" title="MUST">MUST</em> be supported by
                            all objects implementing the <code><a>RTCIceTransport</a></code> interface.
                            It is called any time the selected <code><a>RTCIceCandidatePair</a></code> changes.
                        <p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicecomponent*">
                <h3>enum RTCIceComponent</h3>
                <p>
                    <dfn><code>RTCIceComponent</code></dfn> contains the component-id of the <code><a>RTCIceTransport</a></code>,
                    which will be <code>RTP</code> unless RTP and RTCP are not multiplexed and
                    the <code><a>RTCIceTransport</a></code> object was returned by <code>createAssociatedTransport()</code>.
                </p>
                <dl class="idl" title="enum RTCIceComponent">
                    <dt>RTP</dt>
                    <dd>
                        <p>
                            The RTP component ID, defined (as '1') in [[!RFC5245]] Section 4.1.1.1.
                            Protocols multiplexed with RTP (e.g. SCTP data channel) share its component ID.
                        </p>
                    </dd>
                    <dt>RTCP</dt>
                    <dd>
                        <p>The RTCP component ID, defined (as '2') in [[!RFC5245]] Section 4.1.1.1.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicerole*">
                <h3>enum RTCIceRole</h3>
                <p><dfn><code>RTCIceRole</code></dfn> contains the current role of the ICE transport.</p>
                <dl class="idl" title="enum RTCIceRole">
                    <dt>controlling</dt>
                    <dd>
                        <p>controlling state</p>
                    </dd>
                    <dt>controlled</dt>
                    <dd>
                        <p>controlled state</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicetransportstate*">
                <h3>enum RTCIceTransportState</h3>
                <p><dfn><code>RTCIceTransportState</code></dfn> represents the current state of the ICE transport.</p>
                <dl class="idl" title="enum RTCIceTransportState">
                    <dt>new</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceTransport</a></code> object is waiting for remote candidates to be supplied.
                            In this state the <code><a>RTCIceTransport</a></code> object can respond to incoming connectivity checks.
                        </p>
                    </dd>
                    <dt>checking</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceTransport</a></code> has received at least one remote candidate,
                            and a local and remote <code><a>RTCIceCandidateComplete</a></code> dictionary was not added as the last candidate.
                            In this state the <code><a>RTCIceTransport</a></code> is checking candidate pairs but has not yet found a
                            successful candidate pair, or consent checks [[!RFC7675]] have failed on
                            all previously successful candidate pairs.
                        </p>
                    </dd>
                    <dt>connected</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceTransport</a></code> has received a response to an outgoing connectivity check,
                            or has received incoming DTLS/media after a successful response to an incoming connectivity check,
                            but is still checking other candidate pairs to see if there is a better connection.  In this
                            state outgoing media is permitted. If consent checks [[!RFC7675]] fail on the connection in use,
                            and there are no other successful candidate pairs available, then the state transitions to <code>checking</code>
                            (if there are candidate pairs remaining to be checked) or <code>disconnected</code> (if there are no candidate
                            pairs to check, but the peer is still gathering and/or waiting for additional remote candidates).
                        </p>
                    </dd>
                    <dt>completed</dt>
                    <dd>
                        <p>
                            A local and remote <code><a>RTCIceCandidateComplete</a></code> dictionary was added as the
                            last candidate to the <code><a>RTCIceTransport</a></code> and all appropriate candidate
                            pairs have been tested and at least one functioning candidate pair has been found.
                            If consent checks [[!RFC7675]] subsequently fail on all successful candidate pairs,
                            the state transitions to <code>failed</code>.
                        </p>
                    </dd>
                    <dt>disconnected</dt>
                    <dd>
                        <p>
                            The <code><a>RTCIceTransport</a></code> has received at least one local and remote candidate,
                            and a local and remote <code><a>RTCIceCandidateComplete</a></code> dictionary was not added as the last
                            candidate, but all appropriate candidate pairs thus far have been tested and failed (or consent checks [[!RFC7675]]
                            once successful, have now failed). Other candidate pairs may become available for testing as new candidates
                            are trickled, and therefore the <code>failed</code> state has not been reached.
                        </p>
                    </dd>
                    <dt>failed</dt>
                    <dd>
                        <p>
                            A local and remote <code>RTCIceCandidateComplete</code> dictionary was added as the last candidate
                            to the <code><a>RTCIceTransport</a></code> and all appropriate candidate pairs have either
                            failed connectivity checks or have lost consent.
                        </p>
                    </dd>
                    <dt>closed</dt>
                    <dd>
                        <p>The <code><a>RTCIceTransport</a></code> has shut down and is no longer responding to STUN requests.
                        </p>
                    </dd>
                </dl>
                <p>Some example transitions might be:</p>
                    <ul>
                        <li>new RTCIceTransport(): <code>new</code></li>

                        <li>(<code>new</code>, remote candidates received):
                        <code>checking</code></li>

                        <li>(<code>checking</code>, found usable connection):
                        <code>connected</code></li>

                        <li>(<code>checking</code>, checks fail but gathering still in progress):
                        <code>disconnected</code></li>

                        <li>(<code>checking</code>, gave up): <code>failed</code></li>

                        <li>(<code>disconnected</code>, new local candidates):
                        <code>checking</code></li>

                        <li>(<code>connected</code>, finished all checks):
                        <code>completed</code></li>
                        
                        <li>(<code>completed</code>, lost connectivity):
                        <code>disconnected</code></li>

                        <li>(any state, ICE restart occurs): <code>new</code></li>

                        <li>close(): <code>closed</code></li>
                    </ul>
                </p>
                   <figure>
                     <img alt="The non-normative RTCIceTransportState transition diagram" src="images/ortc-icetransportstate.svg" style="width:100%" />
                     <figcaption>
                        Non-normative ICE transport state transition diagram
                     </figcaption>
                   </figure>
            </section>
            <section id="rtcicecandidatepairchangedevent-interface-definition*">
                <h3>RTCIceCandidatePairChangedEvent</h3>
                <p>
                    The <code>icecandidatepairchange</code> event of the <code><a>RTCIceTransport</a></code> object uses
                    the <code><a>RTCIceCandidatePairChangedEvent</a></code> interface.
                </p>
                <p>
                    Firing an
                    <code><a>RTCIceCandidatePairChangedEvent</a></code> event named
                    <var>e</var> with an <code><a>RTCIceCandidatePair</a></code>
                    <var>pair</var> means that an event with the name <var>e</var>,
                    which does not bubble (except where otherwise stated) and is not
                    cancelable (except where otherwise stated), and which uses the
                    <code><a>RTCIceCandidatePairChangedEvent</a></code> interface with
                    <var>pair</var> set to the selected <code>RTCIceCandidatePair</code>,
                    <em class="rfc2119" title="MUST">MUST</em> be
                    created and dispatched at the given target.
                </p>
                <dl class="idl" data-merge="RTCIceCandidatePairChangedEventInit"
                    title= "interface RTCIceCandidatePairChangedEvent : Event">
                    <dt>Constructor(DOMString type, RTCIceCandidatePairChangedEventInit eventInitDict)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCIceCandidatePair pair</dt>
                    <dd>
                        <p>
                            The <code>pair</code> attribute is the selected
                            <code><a>RTCIceCandidatePair</a></code>
                            that caused the event.
                        </p>
                    </dd>
                </dl>
                <dl class="idl" title="dictionary RTCIceCandidatePairChangedEventInit : EventInit">
                    <dt>RTCIceCandidatePair pair</dt>
                    <dd>
                        <p>
                            The <code>pair</code> attribute is the selected
                            <code><a>RTCIceCandidatePair</a></code>
                            that caused the event.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicecandidatepair*">
                <h3>dictionary RTCIceCandidatePair</h3>
                <p>
                    The <dfn><code>RTCIceCandidatePair</code></dfn> contains the currently selected ICE candidate pair.
                <p>
                <dl class="idl" title="dictionary RTCIceCandidatePair">
                    <dt>RTCIceCandidate local</dt>
                    <dd>
                        <p>The local ICE candidate.</p>
                    </dd>
                    <dt>RTCIceCandidate remote</dt>
                    <dd>
                        <p>The remote ICE candidate.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicegatherer-example*">
                <h3>Example</h3>
                <pre class="example highlight">
// Example to demonstrate forking when RTP and RTCP are not multiplexed,
// so that both RTP and RTCP IceGatherer and IceTransport objects are needed.
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

// Create ICE gather options
var gatherOptions = {
  gatherPolicy: "relay",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
      credentialType: "password" }
   ]
};

// Create ICE gatherer objects
var iceRtpGatherer = new RTCIceGatherer(gatherOptions);
var iceRtcpGatherer = iceRtpGatherer.createAssociatedGatherer();

// Prepare to signal local candidates
iceRtpGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "RTP", "audio",
    iceRtpGatherer.getLocalParameters());
};

iceRtcpGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "RTCP", "audio",
    iceRtpGatherer.getLocalParameters());
};

// Start gathering
iceRtpGatherer.gather();
iceRtcpGatherer.gather();

// Initialize the ICE transport arrays
var iceRtpTransports = [];
var iceRtcpTransports = [];

// Set up response function
mySignaller.onResponse = function(responseSignaller, response) {
  // We may get N responses

  // Create the ICE RTP and RTCP transports
  var iceRtpTransport = new RTCIceTransport(iceRtpGatherer);
  var iceRtcpTransport = iceRtpTransport.createAssociatedTransport();

  // Start the RTP and RTCP ICE transports so that outgoing ICE connectivity checks can begin
  // The RTP and RTCP ICE parameters are the same, so only the RTP parameters are used
  iceRtpTransport.start(iceRtpGatherer, response.icertp, RTCIceRole.controlling);
  iceRtcpTransport.start(iceRtcpGatherer, response.icertp, RTCIceRole.controlling);

  iceRtpTransports.push(iceRtpTransport);
  iceRtcpTransports.push(iceRtcpTransport);

  // Prepare to add ICE candidates signalled by the remote peer
  responseSignaller.onRemoteCandidate = function(remote) {
    // Locate the ICE transport that the signaled candidate relates to by matching
   //  the userNameFragment.
    var transports;
    if (remote.component === "RTP") {
      transports = iceRtpTransports;
    } else {
      transports = iceRtcpTransports;
    }

    for (var j = 0; j &lt; iceTransport.length; j++) {
      var transport = transports[j];
      if (transport.getRemoteParameters().userNameFragment === remote.parameters.userNameFragment)
        transport.addRemoteCandidate(remote.candidate);
      }
    }
  };
};

mySignaller.send({
  // The RTP and RTCP parameters are identical, so no need to send both
  "icertp": iceRtpGatherer.getLocalParameters()
});
                </pre>
            </section>
        </section>
        <section id="rtcdtlstransport*">
            <h2>The RTCDtlsTransport Object</h2>
            <p>
                The <dfn><code>RTCDtlsTransport</code></dfn> object includes information relating to Datagram Transport Layer Security (DTLS) transport.
            </p>
            <section id="rtcdtlstransport-overview*">
                <h3>Overview</h3>
                <p>
                    An <code><a>RTCDtlsTransport</a></code> instance is associated to an <code><a>RTCRtpSender</a></code>,
                    an <code><a>RTCRtpReceiver</a></code>, or an <code><a>RTCSctpTransport</a></code> instance.
                </p>
            </section>
            <section id="rtcdtlstransport-operation*">
                <h3>Operation</h3>
                <p>
                    A <code><a>RTCDtlsTransport</a></code> instance is constructed using an <code><a>RTCIceTransport</a></code>
                    and a sequence of <code>RTCCertificate</code> objects. If <code>certificates</code> is non-empty,
                    check that the <code>expires</code> attribute of each <code>RTCCertificate</code> object is in the future.
                    If a certificate has expired, throw an InvalidParameter exception; otherwise, store the certificates.
                </p>
                <p>
                    A newly constructed <code><a>RTCDtlsTransport</a></code> <em class="rfc2119" title="MUST">MUST</em>
                    listen and respond to incoming DTLS packets before <code>start()</code> is called.
                    However, to complete the negotiation it is necessary to verify the remote fingerprint,
                    which is dependent on <code>remoteParameters</code>, passed to <code>start()</code>.
                    To verify the remote fingerprint, compute the fingerprint <var>value</var> for the selected
                    remote certificate using the signature digest algorithm, and compare it against
                    <code>remoteParameters.fingerprints</code>. If the selected remote certificate 
                    <code>RTCDtlsFingerprint.value</code> matches <code>remoteParameters.fingerprints[j].value</code>
                    and <code>RTCDtlsFingerprint.algorithm</code> matches <code>remoteParameters.fingerprints[j].algorithm</code>
                    for any value of <var>j</var>, the remote fingerprint is verified. After the DTLS handshake exchange
                    completes (but before the remote fingerprint is verified) incoming media packets may be received.
                    A modest buffer <em class="rfc2119" title="MUST">MUST</em> be provided to avoid loss of
                    media prior to remote fingerprint validation (which can begin after <code>start()</code> is called).
                </p>
                <p>
                    If an attempt is made to construct a <code><a>RTCDtlsTransport</a></code> instance from an <code><a>RTCIceTransport</a></code> in the <code>closed</code> state,
                    an <code>InvalidStateError</code> exception is thrown.
                    Since the Datagram Transport Layer Security (DTLS) negotiation occurs between transport endpoints determined via ICE, implementations of this specification
                    <em class="rfc2119" title="MUST">MUST</em> support multiplexing of STUN, TURN, DTLS and RTP and/or RTCP.
                    This multiplexing, originally described in [[!RFC5764]] Section 5.1.2, is being revised in [[MUX-FIXES]].
                </p>
                <p>
                    An <code><a>RTCDtlsTransport</a></code> object in the <code>closed</code> or <code>failed</code> states can be garbage-collected
                    when it is no longer referenced.
                </p>
            </section>
            <section id="rtcdtlstransport-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="typedef (octet[]) ArrayBuffer">
                </dl>
                <dl class="idl" title="interface RTCDtlsTransport : RTCStatsProvider ">
                    <dt>Constructor (RTCIceTransport transport, sequence&lt;RTCCertificate&gt; certificates)</dt>
                    <dd></dd>
                    <dt>readonly attribute sequence&lt;RTCCertificate&gt; certificates</dt>
                    <dd>
                        <p>The certificates provided in the constructor.</p>
                    </dd>
                    <dt>readonly attribute RTCIceTransport transport</dt>
                    <dd>
                        <p>The associated <code><a>RTCIceTransport</a></code> instance.</p>
                    </dd>
                    <dt>readonly attribute RTCDtlsTransportState state</dt>
                    <dd>
                        <p>The current state of the DTLS transport.</p>
                    </dd>
                    <dt>RTCDtlsParameters getLocalParameters()</dt>
                    <dd>
                        <p>Obtain the DTLS parameters of the local <code><a>RTCDtlsTransport</a></code>.
                        If multiple certificates were provided in the constructor, then multiple
                        fingerprints will be returned, one for each certificate.</p>
                    </dd>
                    <dt>RTCDtlsParameters? getRemoteParameters()</dt>
                    <dd>
                        <p>Obtain the remote DTLS parameters passed in the <code>start()</code> method.
                        Prior to calling <code>start()</code>, null is returned.</p>
                    </dd>
                    <dt>sequence&lt;ArrayBuffer&gt; getRemoteCertificates()</dt>
                    <dd>
                        <p>Returns the certificate chain in use by the remote side, with each certificate encoded
                        in binary Distinguished Encoding Rules (DER) [[!X690]]. <code>getRemoteCertificates()</code>
                        returns an empty list prior to selection of the remote certificate, which is completed
                        once <code><a>RTCDtlsTransportState</a></code> transitions to <code>connected</code>.</p>
                    </dd>
                    <dt>void start(RTCDtlsParameters remoteParameters)</dt>
                    <dd>
                        <p>
                            Start DTLS transport negotiation with the parameters of the remote DTLS transport, including verification
                            of the remote fingerprint, then once the DTLS transport session is established, negotiate a <dfn>DTLS-SRTP</dfn>
                            [[!RFC5764]] session to establish keys so as protect media using SRTP [[!RFC3711]].
                            Since symmetric RTP [[!RFC4961]] is utilized, the <a>DTLS-SRTP</a> session is bi-directional.
                        </p>
                        <p>
                            If <var>remoteParameters</var> is invalid, throw
                            an <code>InvalidParameters</code> exception. If <code>start()</code> is called
                            after a previous <code>start()</code> call, or if <code>state</code> is <code>closed</code>,
                            throw an <code>InvalidStateError</code> exception.
                            Only a single DTLS transport can be multiplexed over an ICE transport.
                            Therefore if a <code><a>RTCDtlsTransport</a></code> object <var>dtlsTransportB</var>
                            is constructed with an <code><a>RTCIceTransport</a></code> object
                            <var>iceTransport</var> previously used to construct another <code><a>RTCDtlsTransport</a></code> object
                            <var>dtlsTransportA</var>, then if <code>dtlsTransportB.start()</code> is called prior to having called <code>dtlsTransportA.stop()</code>,
                            then throw an <code>InvalidStateError</code> exception.
                        </p>
                    </dd>
                    <dt>void stop()</dt>
                    <dd>
                        <p>
                            Stops and closes the <code><a>RTCDtlsTransport</a></code> object.
                            Calling <code>stop()</code> when <code>state</code> is <code>closed</code> has no effect.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onstatechange</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code><a>statechange</a></code>,
                            <em class="rfc2119" title="MUST">MUST</em> be fired
                            any time the <code><a>RTCDtlsTransportState</a></code> changes.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onerror</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code>error</code>,
                            <em class="rfc2119" title="MUST">MUST</em> be fired on reception of a DTLS error alert; an implementation
                            <em class="rfc2119" title="SHOULD">SHOULD</em> include DTLS error alert information in <var>error.message</var> (defined in 
                            [[!HTML5]] Section 6.1.3.6.2).
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcdtlsparameters*">
                <h3>The RTCDtlsParameters Object</h3>
                <p>
                    The <dfn><code>RTCDtlsParameters</code></dfn> object includes information relating to DTLS configuration.
                </p>
                <dl class="idl" title="dictionary RTCDtlsParameters">
                    <dt>RTCDtlsRole role="auto"</dt>
                    <dd>
                        <p>The DTLS role, with a default of <code>auto</code>.</p>
                    </dd>
                    <dt>sequence&lt;RTCDtlsFingerprint&gt; fingerprints</dt>
                    <dd>
                        <p>Sequence of fingerprints, one fingerprint for each certificate.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcdtlsfingerprint*">
                <h3>The RTCDtlsFingerprint Object</h3>
                <p>
                    The <dfn><code>RTCDtlsFingerprint</code></dfn> object includes the hash function algorithm and certificate fingerprint as described in [[!RFC4572]].
                </p>
                <dl class="idl" title="dictionary RTCDtlsFingerprint">
                    <dt>DOMString algorithm</dt>
                    <dd>
                        <p>One of the the hash function algorithms defined in the 'Hash function Textual Names' registry, initially specified in [[!RFC4572]] Section 8.
                        As noted in [[!JSEP]] Section 5.2.1, the digest algorithm used for the fingerprint matches that used in the certificate signature.</p>
                    </dd>
                    <dt>DOMString value</dt>
                    <dd>
                        <p>The value of the certificate fingerprint in lowercase hex string as expressed utilizing the syntax of 'fingerprint' in [[!RFC4572]] Section 5.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcdtlsrole*">
                <h3>enum RTCDtlsRole</h3>
                <p><dfn><code>RTCDtlsRole</code></dfn> indicates the role of the DTLS transport.
                </p>
                <dl class="idl" title="enum RTCDtlsRole">
                    <dt>auto</dt>
                    <dd>
                        <p>
                            The DTLS role is determined based on the resolved ICE role: the
                            <code>controlled</code> role acts as the DTLS client,
                            the <code>controlling</code> role acts as the DTLS server. Since <code><a>RTCDtlsRole</a></code>
                            is initialized to <code>auto</code> on construction of an <code><a>RTCDtlsTransport</a></code> object,
                            <code>transport.getLocalParameters().RTCDtlsRole</code> will have an initial value of <code>auto</code>.
                        </p>
                    </dd>
                    <dt>client</dt>
                    <dd>
                        <p>
                            The DTLS client role.
                            A transition to <code>client</code> will occur if
                            <code>start(<var>remoteParameters</var>)</code> is called with <code>remoteParameters.RTCDtlsRole</code>
                            having a value of <code>server</code>. If <code><a>RTCDtlsRole</a></code> had previously had a value of <code>server</code> (e.g. due to
                            the <code><a>RTCDtlsTransport</a></code> having previously received packets from a DTLS client), then the
                            DTLS session is reset prior to transitioning to the <code>client</code> role.
                        </p>
                    </dd>
                    <dt>server</dt>
                    <dd>
                        <p>
                            The DTLS server role. If <code><a>RTCDtlsRole</a></code> has a value of <code>auto</code> and
                            the <code><a>RTCDtlsTransport</a></code> receives a DTLS client_hello packet,
                            <code><a>RTCDtlsRole</a></code> will transition to <code>server</code>, even before <code>start()</code> is called. A transition from <code>auto</code>
                            to <code>server</code> will also occur if <code>start(<var>remoteParameters</var>)</code> is called with <code>remoteParameters.RTCDtlsRole</code>
                            having a value of <code>client</code>.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcdtlstransportstate*">
                <h3>enum RTCDtlsTransportState</h3>
                <p><dfn><code>RTCDtlsTransportState</code></dfn> indicates the state of the DTLS transport.</p>
                <dl class="idl" title="enum RTCDtlsTransportState">
                    <dt>new</dt>
                    <dd>
                        <p>The <code><a>RTCDtlsTransport</a></code> object has been created and has not started negotiating yet.</p>
                    </dd>
                    <dt>connecting</dt>
                    <dd>
                        <p>
                            DTLS is in the process of negotiating a secure connection and verifying the remote fingerprint.  Once a
                            secure connection is negotiated (but prior to verification of the remote fingerprint, enabled by calling
                            <code>start()</code>), incoming data can flow through (and media, once <a>DTLS-SRTP</a> key derivation is
                            completed).
                        </p>
                    </dd>
                    <dt>connected</dt>
                    <dd>
                        <p>
                            DTLS has completed negotiation of a secure connection and verified the remote fingerprint.  Outgoing data
                            and media can now flow through.
                        </p>
                    </dd>
                    <dt>closed</dt>
                    <dd>
                        <p>
                            The DTLS connection has been closed intentionally via a call to <code>stop()</code> or receipt of a
                            close_notify alert. Calling <code>transport.stop()</code> will also result in a transition to the 
                            <code>closed</code> state.
                        </p>
                    </dd>
                    <dt>failed</dt>
                    <dd>
                        <p>
                            The DTLS connection has been closed as the result of an error (such as receipt of an error alert or
                            a failure to validate the remote fingerprint).
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicetransport-example1*">
                <h3>Examples</h3>
                <pre class="example highlight">
// This is an example of how to offer ICE and DTLS parameters and
// ICE candidates and get back ICE and DTLS parameters and ICE candidates,
// and start both ICE and DTLS, when RTP and RTCP are multiplexed.
// Assume that we have a way to signal (mySignaller).
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange, 
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

function initiate(mySignaller) {
  // Prepare the ICE gatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };
  
  // Start gathering
  iceGatherer.gather();

  // Initialize the ICE and DTLS transport arrays
  var iceTransports = [];
  var dtlsTransports = [];

  // Create the DTLS certificate and parameters
  var certs;
  var dtlsParameters = {};
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
    // Obtain the fingerprint of the created certificate
    dtlsParameters.fingerprints[0] = certificate.fingerprint;
  }, function(){
    trace('Certificate could not be created');
  });
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    // Figure out which IceTranport a remote candidate relates to by matching
    // the userNameFragment/password
    var j = 0;
    for (j = 0; j &lt; iceTransport.length; j++) {
      var transport = iceTransports[j];
      if (transport.getRemoteParameters().userNameFragment === remote.parameters.userNameFragment)
        transport.addRemoteCandidate(remote.candidate);
      }
    }  };
  // ... create RtpSender/RtpReceiver objects as illustrated in Section 6.5 Example 8.

  mySignaller.mySendInitiate({
    "ice": iceGatherer.getLocalParameters(),
    "dtls": dtlsParameters,
    // ... marshall RtpSender/RtpReceiver capabilities as illustrated in Section 6.5 Example 8.
  }, function(remote) {
    // Create the ICE and DTLS transports
    var iceTransport = new RTCIceTransport(iceGatherer);
    iceTransport.start(iceGatherer, remote.ice, RTCIceRole.controlling);
    iceTransports.push(iceTransport);
    // Construct a RTCDtlsTransport object with the same certificate and fingerprint
    // as in the Offer so that the remote peer can verify it.
    var dtlsTransport = new RTCDtlsTransport(iceTransport, certs);
    dtlsTransport.start(remote.dtls);
    dtlsTransports.push(dtlsTransport);

    // ... configure RtpSender/RtpReceiver objects as illustrated in Section 6.5 Example 8.
  });
}
                </pre>
                <pre class="example highlight">
// This is an example of how to answer with ICE and DTLS
// and DTLS parameters and ICE candidates and start both ICE and DTLS,
// assuming that RTP and RTCP are multiplexed.
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange, 
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

// Assume that remote info is signalled to us.
function accept(mySignaller, remote) {
  // Prepare the ICE gatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };
  
  // Start gathering
  iceGatherer.gather();

  // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create ICE and DTLS transports
  var ice = new RTCIceTransport(iceGatherer);
  var dtls = new RTCDtlsTransport(ice, certs);

  // Prepare to handle remote candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };
  // ... create RtpSender/RtpReceiver objects as illustrated in Section 6.5 Example 8.

  mySignaller.mySendAccept({
    "ice": iceGatherer.getLocalParameters(),
    "dtls": dtls.getLocalParameters()
    // ... marshall RtpSender/RtpReceiver capabilities as illustrated in Section 6.5 Example 8.
  });

  // Start the ICE transport with an implicit gather policy of "all"
  ice.start(iceGatherer, remote.ice, RTCIceRole.controlled);

  // Start the DTLS transport
  dtls.start(remote.dtls);

  // ... configure RtpSender/RtpReceiver objects as illustrated in Section 6.5 Example 8.
}
                </pre>
            </section>
        </section>
        <section id="rtcrtpsender*">
            <h2>The RTCRtpSender Object</h2>
            <p>
                The <dfn><code>RTCRtpSender</code></dfn> includes information relating to the RTP sender.
            </p>
            <section id="rtcrtpsender-overview*">
                <h3>Overview</h3>
                <p>
                    An <code><a>RTCRtpSender</a></code> instance is associated to a sending <a>MediaStreamTrack</a>
                    and provides RTC related methods to it.
                </p>
            </section>
            <section id="rtcrtpsender-operation*">
                <h3>Operation</h3>
                <p>
                    A <code><a>RTCRtpSender</a></code> instance is constructed from an <a>MediaStreamTrack</a> object and
                    associated to an <code><a>RTCDtlsTransport</a></code>.
                    If an attempt is made to construct an <code><a>RTCRtpSender</a></code> object with <code>transport.state</code>
                    or <code>rtcpTransport.state</code> <code>closed</code>,
                    or if <code>track.readyState</code> is <code>ended</code>, throw an <code>InvalidStateError</code> exception.
                </p>
                <p>
                    An <code><a>RTCRtpSender</a></code> object can be garbage-collected once <code>stop()</code> 
                    is called and it is no longer referenced.
                </p>
            </section>
            <section id="rtcrtpsender-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCRtpSender : RTCStatsProvider">
                    <dt>Constructor(MediaStreamTrack track, RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)</dt>
                    <dd></dd>
                    <dt>readonly attribute MediaStreamTrack track</dt>
                    <dd>
                        <p>The associated <code><a>MediaStreamTrack</a></code> instance.</p>
                    </dd>
                    <dt>readonly attribute RTCDtlsTransport transport</dt>
                    <dd>
                        <p>
                            The <code><a>RTCDtlsTransport</a></code> instance over which RTCP is sent and received.
                            When BUNDLE is used, many <code><a>RTCRtpSender</a></code> objects will share one 
                            <code>rtcpTransport</code> and will all send and receive RTCP over the same <code><a>RTCDtlsTransport</a></code>. 
                            When RTCP mux is used, <code>rtcpTransport</code> will be null, and both RTP and RTCP traffic will flow 
                            over the <code><a>RTCDtlsTransport</a></code> <var>transport</var>.
                        </p>
                    </dd>
                    <dt>readonly attribute RTCDtlsTransport? rtcpTransport</dt>
                    <dd>
                        <p>
                            The associated RTCP <code><a>RTCDtlsTransport</a></code> instance if one was provided
                            in the constructor. When RTCP mux is used, <code>rtcpTransport</code> will be null, and
                            both RTP and RTCP traffic will flow over the <code><a>RTCDtlsTransport</a></code>
                            <var>transport</var>.
                        </p>
                    </dd>
                    <dt>void setTransport(RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)</dt>
                    <dd>
                        <p>
                            Set the RTP <code><a>RTCDtlsTransport</a></code> (and if used) RTCP <code><a>RTCDtlsTransport</a></code>.
                            If <code>setTransport()</code> is called with a single argument or if <code>rtcpTransport</code> is not set,
                            and the last call to <code>sender.send(parameters)</code>
                            had <code>parameters.rtcp.mux</code> set to <code>false</code>, throw an <code>InvalidParameters</code>
                            exception.
                            If <code>stop()</code> has been called, or <code>transport.state</code> or <code>rtcpTransport.state</code> is <code>closed</code>,
                            throw an <code>InvalidStateError</code> exception.
                        </p>
                    </dd>
                    <dt>Promise&lt;void&gt; setTrack(MediaStreamTrack track)</dt>
                    <dd>
                        <p>Attempts to replace the track being sent with another track provided.</p>
                        <p>When the <code>setTrack()</code> method is invoked, the user agent MUST run the following steps:</p>
                        <ol>
                            <li>
                                <p>
                                    Let <var>sender</var> be the <code><a>RTCRtpSender</a></code> object on which
                                    <code>setTrack()</code> is invoked.
                                </p>
                            </li>
                            <li>
                                <p>
                                    If <code>sender.stop()</code> has been called, return a promise
                                    rejected with an <code>InvalidStateError</code>.
                                 </p>
                            </li>
                            <li>
                                <p>Let <var>withTrack</var> be the argument to this method.</p>
                            </li>
                            <li>
                                <p>
                                    If <code>track.stop()</code> has been called, return a promise
                                    rejected with an <code>InvalidStateError</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    If <code><var>withTrack</var>.kind</code> differs from the
                                    <code><var>sender</var>.<a>track</a>.kind</code>,
                                    return a promise rejected with a <code>TypeError</code>.
                                </p>
                            </li>
                            <li>
                                <p>Let <var>p</var> be a new promise.</p>
                            </li>
                            <li>
                                <p>Run the following steps:</p>
                                <ol>
                                    <li>
                                        <p>
                                            Set the <code>track</code> attribute to <var>withTrack</var>,
                                            and have the sender seamlessly switch to transmitting <var>withTrack</var>
                                            in place of what it is sending.
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Resolve <var>p</var> with <code>undefined</code>.
                                        </p>
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </dd>
                    <dt>static RTCRtpCapabilities getCapabilities(DOMString kind)</dt>
                    <dd>
                        <p>
                            Obtain the sender capabilities, based on <code>kind</code>. Capabilities that can apply to multiple
                            values of <code>kind</code> (such as retransmission [[!RFC4588]], redundancy [[RFC2198]] and
                            Forward Error Correction) have <code>RTCRtpCapabilities.RTCRtpCodecCapability[i].kind</code>
                            set to the value of the <code>kind</code> argument.
                        </p>
                    </dd>
                    <dt>Promise&lt;void&gt; send(RTCRtpParameters parameters)</dt>
                    <dd>
                        <p>Attempts to set the parameters controlling the sending of media.</p>
                        <p>When the <code>send()</code> method is invoked, the user agent MUST run the following steps:</p>
                        <ol>
                            <li>
                                <p>
                                    Let <var>sender</var> be the <code><a>RTCRtpSender</a></code> object on which
                                    <code>send()</code> is invoked.
                                </p>
                            </li>
                            <li>
                                <p>
                                    If <code>sender.stop()</code> has been called, return a promise
                                    rejected with an <code>InvalidStateError</code>.
                                 </p>
                            </li>
                            <li>
                                <p>Let <var>withParameters</var> be the argument to this method.</p>
                            </li>
                            <li>
                                <p>
                                    If <var>withParameters</var> is invalid due to SSRC misusage or other reasons,
                                    return a promise rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    If <code>rtcpTransport</code> is not set and <code>withParameters.rtcp.mux</code>
                                    is set to <code>false</code>, return a promise
                                    rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    For each value of <var>i</var> from 0 to the number of codecs, check that each
                                    value of <code>withParameters.codecs[i].payloadType</code> is set. If any value
                                    is unset, return a promise rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    For each value of <var>i</var> from 0 to the number of encodings, check
                                    whether <code>withParameters.encodings[<var>i</var>].codecPayloadType</code> (if set) corresponds to
                                    a value of <code>withParameters.codecs[<var>j</var>].payloadType</code> where <var>j</var> goes from 0
                                    to the number of codecs. If there is no correspondence, or if
                                    <var>withParameters</code>.<code>codecs[<var>j</var>].name</code> is equal to "red", "cn", "telephone-event",
                                    "rtx" or a forward error correction codec ("ulpfec" [[RFC5109]] or
                                    "flexfec" [[FLEXFEC]]), return a promise rejected with
                                    <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    For each value of <var>i</var> from 0 to the number of codecs, check that each
                                    value of <code>withParameters.codecs[<var>i</var>].name</code> not equal to "red", "rtx" or
                                    a forward error correction codec ("ulpfec" [[RFC5109]] or "flexfec" [[FLEXFEC]]),
                                    is included in <code>getCapabilities(track.kind).codecs[<var>j</var>].name</code>, where <var>j</var> goes
                                    from 0 to the number of codecs. If a match is not found for any value of <var>i</var>,
                                    return a promise rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>Let <var>p</var> be a new promise.</p>
                            </li>
                            <li>
                                <p>Run the following steps:</p>
                                <ol>
                                    <li>
                                        <p>
                                            If <code>send()</code> is called for the first time, start sending. If
                                            <code>send()</code> was called previously, have the sender
                                            switch to sending using <var>withParameters</var>.
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Resolve <var>p</var> with <code>undefined</code>.
                                        </p>
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </dd>
                    <dt>void stop()</dt>
                    <dd>
                        <p>
                            Stops sending the track on the wire, and sends an RTCP BYE.
                            Stop is final as in <code>MediaStreamTrack.stop()</code>.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onssrcconflict</dt>
                    <dd>
                        <p>
                            The <dfn><code>onssrcconflict</code></dfn> event handler, of event handler type <code>RTCSsrcConflictEvent</code>, is fired
                            if an SSRC conflict is detected within the RTP session or an SSRC misconfiguration is detected after
                            <code>send()</code> or <code>receive()</code> returns or when <code>setTransport()</code> is called.
                            In this situation, the <code><a>RTCRtpSender</a></code> automatically sends an RTCP BYE on the conflicted SSRC,
                            if RTP packets were sent using that SSRC.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcsssrcconflictevent-interface-definition*">
                <h3>RTCSsrcConflictEvent</h3>
                <p>
                    The <code>ssrcconflict</code> event of the <code><a>RTCRtpSender</a></code> object uses
                    the <code><a>RTCSsrcConflictEvent</a></code> interface.
                </p>
                <p>
                    Firing an
                    <dfn><code>RTCSsrcConflictEvent</code></dfn> event named
                    <var>e</var> with an
                    <code>ssrc</code> means that an event with the name <var>e</var>,
                    which does not bubble (except where otherwise stated) and is not
                    cancelable (except where otherwise stated), and which uses the
                    <code><a>RTCSsrcConflictEvent</a></code> interface with the
                    <code>ssrc</code> attribute set to the conflicting SSRC
                    <em class="rfc2119" title="MUST">MUST</em> be
                    created and dispatched at the given target.
                </p>
                <dl class="idl" data-merge="RTCSsrcConflictEventInit"
                    title="interface RTCSsrcConflictEvent : Event">
                    <dt>Constructor(DOMString type, RTCSsrcConflictEventInit eventInitDict)</dt>
                    <dd></dd>
                    <dt>readonly attribute unsigned long ssrc</dt>
                    <dd>
                        <p>
                            The <code>ssrc</code> attribute represents the conflicting SSRC
                            that caused the event.
                        </p>
                    </dd>
                </dl>
                <dl class="idl" title="dictionary RTCSsrcConflictEventInit : EventInit">
                    <dt>unsigned long ssrc</dt>
                    <dd>
                        <p>
                            The <code>ssrc</code> attribute represents the conflicting SSRC
                            that caused the event.
                        </p>
                    </dd>
                </dl>
            </section>
        </section>
        <section id="rtcrtpreceiver*">
            <h2>The RTCRtpReceiver Object</h2>
            <p>
                The <dfn><code>RTCRtpReceiver</code></dfn> includes information relating to the RTP receiver.
            </p>
            <section id="rtcrtpreceiver-overview*">
                <h3>Overview</h3>
                <p>
                    An <code><a>RTCRtpReceiver</a></code> instance produces an associated receiving
                    <a>MediaStreamTrack</a> and provides RTC related methods to it.
                </p>
            </section>
            <section id="rtcrtpreceiver-operation*">
                <h3>Operation</h3>
                <p>
                    A <code><a>RTCRtpReceiver</a></code> instance is constructed from a value of
                    <code>kind</code> and an <code><a>RTCDtlsTransport</a></code> object.
                    If an attempt is made to construct an <code><a>RTCRtpReceiver</a></code>
                    object with <code>transport.state</code> or
                    <code>rtcpTransport.state</code> with a value of <code>closed</code>,
                    throw an <code>InvalidStateError</code> exception.
                    Upon construction, <code>track</code> is set, and the value of
                    <code>track.kind</code> is determined based on the
                    value of <code>kind</code> passed in the constructor.
                </p>
                <p>
                    An <code><a>RTCRtpReceiver</a></code> object can be garbage-collected once <code>stop()</code> 
                    is called and it is no longer referenced.
                </p>
            </section>
            <section id="rtcrtpreceiver-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCRtpReceiver : RTCStatsProvider">
                    <dt>Constructor(DOMString kind, RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)</dt>
                    <dd></dd>
                    <dt>readonly attribute MediaStreamTrack track</dt>
                    <dd>
                        <p>
                             The associated <code><a>MediaStreamTrack</a></code> instance.
                             Upon construction, <code>track</code> is set. The value of
                             <code>track.kind</code> is set to the value of
                             <code>kind</code> passed in the constructor.
                             <div class="note">
                                 Prior to verification of the remote DTLS fingerprint within
                                 the <code><a>RTCDtlsTransport</a></code> <var>transport</var>,
                                 and (if set) <var>rtcpTransport</var>, <code>track</code>
                                 <em title="MUST NOT" class="rfc2119">MUST NOT</em> emit media
                                 for rendering.
                             </div>
                        </p>
                    </dd>
                    <dt>readonly attribute RTCDtlsTransport transport</dt>
                    <dd>
                        <p>The associated RTP <code><a>RTCDtlsTransport</a></code> instance.</p>
                    </dd>
                    <dt>readonly attribute RTCDtlsTransport? rtcpTransport</dt>
                    <dd>
                        <p>
                            The <code><a>RTCDtlsTransport</a></code> instance over which RTCP is sent and received.
                            When BUNDLE is used, multiple <code><a>RTCRtpReceiver</a></code> objects will share one 
                            <code>rtcpTransport</code> and will send and receive RTCP over the same <code><a>RTCDtlsTransport</a></code>. 
                            When RTCP mux is used, <code>rtcpTransport</code> will be null, and both RTP and RTCP traffic will flow 
                            over the <code><a>RTCDtlsTransport</a></code> <var>transport</var>.
                        </p>
                    </dd>
                    <dt>void setTransport(RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport)</dt>
                    <dd>
                        <p>
                            Set the RTP <code><a>RTCDtlsTransport</a></code> (and if used)
                            RTCP <code><a>RTCDtlsTransport</a></code>.
                            If <code>setTransport()</code> is called with a single argument
                            or if <code>rtcpTransport</code> is not set,
                            and the last call to <code>receiver.receive(parameters)</code>
                            had <code>parameters.rtcp.mux</code> set to <code>false</code>,
                            throw an <code>InvalidParameters</code> exception. If <code>stop()</code>
                            has been called, or <code>transport.state</code>
                            or <code>rtcpTransport.state</code> is <code>closed</code>,
                            throw an <code>InvalidStateError</code> exception.
                        </p>
                    </dd>
                    <dt>static RTCRtpCapabilities getCapabilities(DOMString kind)</dt>
                    <dd>
                        <p>
                            Obtain the receiver capabilities, based on <code>kind</code>. Capabilities that can apply to multiple
                            values of <code>kind</code> (such as retransmission [[!RFC4588]], redundancy [[RFC2198]] and
                            Forward Error Correction) have <code>RTCRtpCapabilities.RTCRtpCodecCapability[<var>i</var>].kind</code>
                            set to the value of the <code>kind</code> argument.
                        </p>
                    </dd>
                    <dt>Promise&lt;void&gt; receive(RTCRtpParameters parameters)</dt>
                    <dd>
                        <p>Attempts to set the parameters controlling the receiving of media.</p>
                        <p>When the <code>receive()</code> method is invoked, the user agent MUST run the following steps:</p>
                        <ol>
                            <li>
                                <p>
                                    Let <var>receiver</var> be the <code><a>RTCRtpReceiver</a></code> object on which
                                    <code>receive()</code> is invoked.
                                </p>
                            </li>
                            <li>
                                <p>
                                    If <code>receiver.stop()</code> has been called, return a promise
                                    rejected with an <code>InvalidStateError</code>.
                                 </p>
                            </li>
                            <li>
                                <p>Let <var>withParameters</var> be the argument to this method.</p>
                            </li>
                            <li>
                                <p>
                                    If <var>withParameters</var> is invalid due to SSRC misusage,
                                    <code>ssrc_table</code>, <code>muxId_table</code> or <code>pt_table</code>
                                    conflicts described in Section 8.3 or other reasons,
                                    return a promise rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    If <code>rtcpTransport</code> is not set and <var>withParameters.rtcp.mux</var>
                                    is set to <code>false</code>, return a promise rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    For each value of <var>i</var> from 0 to the number of codecs, check that each
                                    value of <code>withParameters.codecs[<var>i</var>].payloadType</code> is set. If any value
                                    is unset, return a promise rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    For each value of <var>i</var> from 0 to the number of encodings, check
                                    whether <code>withParameters.encodings[<var>i</var>].codecPayloadType</code> corresponds to
                                    a value of <var>withParameters.codecs[j].payloadType</var> where <var>j</var> goes from 0
                                    to the number of codecs. If there is no correspondence, or if
                                    <var>withParameters.codecs[j].name</var> is equal to "red", "cn", "telephone-event",
                                    "rtx" or a forward error correction codec ("ulpfec" [[RFC5109]] or "flexfec" [[FLEXFEC]]),
                                    return a promise rejected with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>
                                    For each value of <var>i</var> from 0 to the number of codecs, check that each
                                    value of <code>withParameters.codecs[<var>i</var>].name</code> not equal to "red", "rtx" or a
                                    forward error correction codec is included in <code>getCapabilities(kind).codecs[<var>j</var>].name</code>,
                                    where j goes from 0 to the number of codecs, and <code>kind</code> takes the value
                                    passed in the <code><a>RTCRtpReceiver</a></code> constructor. If no match is found
                                    for any value of <var>i</var>, return a promise rejected
                                    with <code>InvalidParameters</code>.
                                 </p>
                            </li>
                            <li>
                                <p>Let <var>p</var> be a new promise.</p>
                            </li>
                            <li>
                                <p>Run the following steps:</p>
                                <ol>
                                    <li>
                                        <p>
                                            If <code>receive()</code> is called for the first time, start receiving. If
                                            <code>receive()</code> was called previously, have the receiver
                                            switch to receiving using <var>withParameters</var>.
                                        </p>
                                    </li>
                                    <li>
                                        <p>
                                            Resolve <var>p</var> with <code>undefined</code>.
                                        </p>
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </dd>
                    <dt>sequence&lt;RTCRtpContributingSource&gt; getContributingSources()</dt>
                    <dd>
                        <p>
                            Returns an <code><a>RTCRtpContributingSource</a></code> object for each unique CSRC or SSRC received by this
                            <code><a>RTCRtpReceiver</a></code>. The browser MUST keep information from RTP packets
                            received in the last 10 seconds. If no contributing sources are available, an empty list is returned. 
                        </p>
                    </dd>
                    <dt>void stop()</dt>
                    <dd>
                        <p>
                            Stops the <code><a>RTCRtpReceiver</a></code>. <code>receiver.stop()</code> is final like
                            <code>receiver.track.stop()</code>.  <code>receiver.track.stop()</code> does not affect
                            track clones and also does not stop the <code><a>RTCRtpReceiver</a></code> so that
                            Receiver Reports continue to be sent.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpcontributingsource*">
                <h3>dictionary RTCRtpContributingSource</h3>
                <p>
                    The <dfn><code>RTCRtpContributingSource</code></dfn> object contains information
                    about a contributing source.
                    Each time an RTP packet is received, the <code><a>RTCRtpContributingSource</a></code> objects are updated.
                    If the RTP packet contains CSRCs, then the <code><a>RTCRtpContributingSource</a></code> objects corresponding to those
                    CSRCs are updated, and the level values for those CSRCs are updated based on the mixer-client header extension [[!RFC6464]] if present.
                    If the RTP packet contains no CSRCs, then the <code><a>RTCRtpContributingSource</a></code> object corresponding to the
                    SSRC is updated, and the level value for the SSRC is updated based on the client-mixer header extension [[!RFC6464]] if present.
                </p>
                <dl class="idl" title="dictionary RTCRtpContributingSource">
                    <dt>DOMHighResTimeStamp timestamp</dt>
                    <dd>
                        <p>
                            The <code>timestamp</code> of type <code>DOMHighResTimeStamp</code>
                            [[!HIGHRES-TIME]], indicating the time of reception of the most recent RTP packet
                            containing the source. The
                            <code>timestamp</code> is defined in [[!HIGHRES-TIME]] and corresponds to
                            a local clock.
                        </p>
                    </dd>
                    <dt>unsigned long source</dt>
                    <dd>
                        <p>The CSRC or SSRC value of the contributing source.</p>
                    </dd>
                    <dt>byte audioLevel</dt>
                    <dd>
                        <p>
                            The audio level contained in the last RTP packet
                            received from this source. If the source was set from
                            an SSRC, this will be the level value in
                            [[!RFC6464]]. If the source was set from a CSRC,
                            this will be the level value in
                            [[!RFC6465]]. Both [[!RFC6464]] and [[!RFC6465]]
                            define the level as a integral value from 0 to
                            127 representing the audio level in negative decibels relative to
                            the loudest signal that they system could possibly
                            encode. Thus, 0 represents the loudest signal the system could
                            possibly encode, and 127 represents silence.
                        </p>
                    </dd>
                    <dt>boolean voiceActivityFlag</dt>
                    <dd>
                        <p>
                            Whether the last RTP packet received from this source contains voice activity (<code>true</code>) or not (<code>false</code>). Since
                            the "V" bit is supported in [[!RFC6464]] but not [[!RFC6465]], the <code>voiceActivityFlag</code> attribute will only be set
                            when receivers enable the client-mixer header extension (setting the <code>vad</code> attribute to <code>true</code>),
                            and when RTP packets are received from senders enabling the client-mixer header extension
                            (setting the <code>vad</code> attribute to <code>true</code>).
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpreceiver-example*">
                <h3>Examples</h3>
                <pre class="example highlight">
// Assume we already have a way to signal, a transport
// (RTCDtlsTransport), and audio and video tracks. This is an example
// of how to offer them and get back an answer with audio and
// video tracks, and begin sending and receiving them.
// The example assumes that RTP and RTCP are multiplexed.
function myInitiate(mySignaller, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver("audio", transport);
  var videoReceiver = new RTCRtpReceiver("video", transport);

  // Retrieve the audio and video receiver capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
  var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");

  // Retrieve the audio and video sender capabilities
  var sendAudioCaps = RTCRtpSender.getCapabilities("audio");
  var sendVideoCaps = RTCRtpSender.getCapabilities("video");

  mySignaller.myOfferTracks({
    // The initiator offers its receiver and sender capabilities.
    "recvAudioCaps": recvAudioCaps,
    "recvVideoCaps": recvVideoCaps,
    "sendAudioCaps": sendAudioCaps,
    "sendVideoCaps": sendVideoCaps
  }, function(answer) {
    // The responder answers with its receiver capabilities

    // Derive the send and receive parameters
    var audioSendParams = myCapsToSendParams(sendAudioCaps, answer.recvAudioCaps);
    var videoSendParams = myCapsToSendParams(sendVideoCaps, answer.recvVideoCaps);
    var audioRecvParams = myCapsToRecvParams(recvAudioCaps, answer.sendAudioCaps);
    var videoRecvParams = myCapsToRecvParams(recvVideoCaps, answer.sendVideoCaps);
    audioSender.send(audioSendParams).then(function() {
      trace("Set audio sender parameters");
      }, function() {
        trace("Could not set audio sender parameters");
      }
    );
    videoSender.send(videoSendParams).then(function() {
      trace("Set video sender parameters");
      }, function() {
        trace("Could not set video sender parameters");
      }
    );
    audioReceiver.receive(audioRecvParams).then(function() {
      trace("Set audio receiver parameters");
      }, function() {
        trace("Could not set audio receiver parameters");
      }
    );
    videoReceiver.receive(videoRecvParams).then(function() {
      trace("Set video receiver parameters");
      }, function() {
        trace("Could not set video receiver parameters");
      }
    );
    // Now we can render/play
    // audioReceiver.track and videoReceiver.track.
  });
}
                </pre>
                <pre class="example highlight">
// Assume we already have a way to signal, a transport (RTCDtlsTransport)
// and audio and video tracks. This is an example of how to answer an
// offer with audio and video tracks, and begin sending and receiving them.
// The example assumes that RTP and RTCP are multiplexed.
function myAccept(mySignaller, remote, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver("audio", transport);
  var videoReceiver = new RTCRtpReceiver("video", transport);

  // Retrieve the send and receive capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
  var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");
  var sendAudioCaps = RTCRtpSender.getCapabilities("audio");
  var sendVideoCaps = RTCRtpSender.getCapabilities("video");

  mySignaller.myAnswerTracks({
    "recvAudioCaps": recvAudioCaps,
    "recvVideoCaps": recvVideoCaps,
    "sendAudioCaps": sendAudioCaps,
    "sendVideoCaps": sendVideoCaps
  });

  // Derive the send and receive parameters using Javascript functions defined in Section 17.2.
  var audioSendParams = myCapsToSendParams(sendAudioCaps, remote.recvAudioCaps);
  var videoSendParams = myCapsToSendParams(sendVideoCaps, remote.recvVideoCaps);
  var audioRecvParams = myCapsToRecvParams(recvAudioCaps, remote.sendAudioCaps);
  var videoRecvParams = myCapsToRecvParams(recvVideoCaps, remote.sendVideoCaps);
  audioSender.send(audioSendParams).then(function() {
    trace("Set audio sender parameters");
    }, function() {
      trace("Could not set audio sender parameters");
    }
  );
  videoSender.send(videoSendParams).then(function() {
    trace("Set video sender parameters");
    }, function() {
      trace("Could not set video sender parameters");
    }
  );
  audioReceiver.receive(audioRecvParams).then(function() {
    trace("Set audio receiver parameters");
    }, function() {
      trace("Could not set audio receiver parameters");
    }
  );
  videoReceiver.receive(videoRecvParams).then(function() {
    trace("Set video receiver parameters");
    }, function() {
      trace("Could not set video receiver parameters");
    }
  );
  // Now we can render/play
  // audioReceiver.track and videoReceiver.track.
}
                </pre>
            </section>
        </section>
        <section id="rtcicetransportcontroller*">
            <h2>The RTCIceTransportController Object</h2>
            <p>
                The <dfn><code>RTCIceTransportController</code></dfn> object assists in the managing of ICE freezing and bandwidth estimation.
            </p>
            <section id="rtctransportcontroller-overview*">
                <h3>Overview</h3>
                <p>
                    An <code><a>RTCIceTransportController</a></code> object provides methods to add and retrieve <code><a>RTCIceTransport</a></code>
                    objects with a <code>component</code> of <code>RTP</code> (associated <code><a>RTCIceTransport</a></code> objects with a <code>component</code>
                    of <code>RTCP</code> are included implicitly).
                </p>
            </section>
            <section id="rtctransportcontroller-operation*">
                <h3>Operation</h3>
                <p>An <code><a>RTCIceTransportController</a></code> instance is automatically constructed.</p>
            </section>
            <section id="rtcicetransportcontroller-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="[Constructor()] interface RTCIceTransportController">
                    <dt>void addTransport(RTCIceTransport transport, optional unsigned long index)</dt>
                    <dd>
                        <p>
                            Adds <code>transport</code> to the <code><a>RTCIceTransportController</a></code>
                            object for the purposes of managing
                            ICE freezing and sharing bandwidth estimation.
                            Since <code>addTransport</code> manages ICE freezing, candidate pairs that are not in the
                            frozen state maintain their state when <code>addTransport(transport)</code> is called.
                            <code><a>RTCIceTransport</a></code> objects will be unfrozen
                            according to their <var>index</var>. <var>transport</var> is inserted at <var>index</var>,
                            or at the end if <var>index</var> is not specified.
                            If <var>index</var> is greater than the current number of <code><a>RTCIceTransport</a></code>s
                            with a <var>component</var> of <code>RTP</code>,
                            throw an <code>InvalidParameters</code> exception.
                            If <code>transport.state</code> is <code>closed</code>, throw an <code>InvalidStateError</code> exception.
                            If <code>transport</code> has already been added to another
                            <code><a>RTCIceTransportController</a></code> object,
                            or if <code>transport.component</code> is <code>RTCP</code>, throw an <code>InvalidStateError</code> exception.
                        </p>
                    </dd>
                    <dt>sequence&lt;RTCIceTransport&gt; getTransports()</dt>
                    <dd>
                        <p>
                            Returns the <code><a>RTCIceTransport</a></code> objects with a <code>component</code> of <code>RTP</code>.
                            If <code>addTransport()</code> has not been called, an empty list is returned.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcicetransportcontroller-example1*">
                <h3>Examples</h3>
                <pre class="example highlight">
// This is an example of how to utilize distinct ICE transports for Audio and Video
// as well as for RTP and RTCP. If both sides can multiplex audio/video
// and RTP/RTCP then the multiplexing will occur.
//
// Assume we have an audioTrack and a videoTrack to send.
//
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';
// Create the ICE gather options
var gatherOptions = {
  gatherPolicy: "all",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
      credentialType: "password" }
   ]
};

// Create the RTP and RTCP ICE gatherers for audio and video
var audioRtpIceGatherer = new RTCIceGatherer(gatherOptions);
var audioRtcpIceGatherer = audioRtpIceGatherer.createAssociatedGatherer();
var videoRtpIceGatherer = new RTCIceGatherer(gatherOptions);
var videoRtcpIceGatherer = videoRtpIceGatherer.createAssociatedGatherer();

// Set up the ICE gatherer error handlers
audioRtpIceGatherer.onerror = errorHandler;
audioRtcpIceGatherer.onerror = errorHandler;
videoRtpIceGatherer.onerror = errorHandler;
videoRtcpIceGatherer.onerror = errorHandler;

// Create the RTP and RTCP ICE transports for audio and video
var audioRtpIceTransport = new RTCIceTransport(audioRtpIceGatherer);
var audioRtcpIceTransport = audioRtpIceTransport.createAssociatedTransport();
var videoRtpIceTransport = new RTCIceTransport(videoRtpIceGatherer);
var videoRtcpIceTransport = videoRtpIceTransport.createAssociatedTransport();

// Enable local ICE candidates to be signaled to the remote peer.
audioRtpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "RTP", "audio");
};
audioRtcpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "RTCP", "audio");
};
videoRtpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "RTP", "video");
};
videoRtcpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "RTCP", "video");
};

// Start gathering
audioRtpIceGatherer.gather();
audioRtcpIceGatherer.gather();
videoRtpIceGatherer.gather();
videoRtcpIceGatherer.gather();

// Set up the ICE state change event handlers
audioRtpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("audioRtpIceTransport", event.state);
};
audioRtcpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("audioRtcpIceTransport", event.state);
};
videoRtpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("videoRtpIceTransport", event.state);
};
videoRtcpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("videoRtcpIceTransport", event.state);
};

// Prepare to add ICE candidates signaled by the remote peer on any of the ICE transports
mySignaller.onRemoteCandidate = function(remote) {
  switch (remote.kind) {
    case "audio":
      if (remote.component === "RTP") {
        audioRtpIceTransport.addRemoteCandidate(remote.candidate);
      } else {
        audioRtcpIceTransport.addRemoteCandidate(remote.candidate);
      }
      break;
    case "video":
      if (remote.component === "RTP") {
        videoRtpIceTransport.addRemoteCandidate(remote.candidate);
      } else {
        videoRtcpIceTransport.addRemoteCandidate(remote.candidate);
      }
      break;
    default:
      trace("Invalid media type received: " + remote.kind);
  }
};
// Create the DTLS certificate
var certs;
var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
  certs[0] = certificate;
}, function(){
  trace('Certificate could not be created');
});

// Create the DTLS transports (using the same certificate)
var audioRtpDtlsTransport = new RTCDtlsTransport(audioRtpIceTransport, certs);
var audioRtcpDtlsTransport = new RTCDtlsTransport(audioRtcpIceTransport, certs);
var videoRtpDtlsTransport = new RTCDtlsTransport(videoRtpIceTransport, certs);
var videoRtcpDtlsTransport = new RTCDtlsTransport(videoRtcpIceTransport, certs);

// Create the sender and receiver objects
var audioSender = new RTCRtpSender(audioTrack, audioRtpDtlsTransport, audioRtcpDtlsTransport);
var videoSender = new RTCRtpSender(videoTrack, videoRtpDtlsTransport, videoRtcpDtlsTransport);
var audioReceiver = new RTCRtpReceiver("audio", audioRtpDtlsTransport, audioRtcpDtlsTransport);
var videoReceiver = new RTCRtpReceiver("video", videoRtpDtlsTransport, videoRtcpDtlsTransport);

// Retrieve the receiver and sender capabilities
var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");
var sendAudioCaps = RTCRtpSender.getCapabilities("audio");
var sendVideoCaps = RTCRtpSender.getCapabilities("video");

// Exchange ICE/DTLS parameters and Send/Receive capabilities

mySignaller.myOfferTracks({
  // Indicate that the initiator would prefer to multiplex both A/V and RTP/RTCP
  "bundle": true,
  // Indicate that the initiator is willing to multiplex RTP/RTCP without A/V mux
  "rtcpMux": true,
  // Offer the ICE parameters
  "audioRtpIce": audioRtpIceGatherer.getLocalParameters(),
  "audioRtcpIce": audioRtcpIceGatherer.getLocalParameters(),
  "videoRtpIce": videoRtpIceGatherer.getLocalParameters(),
  "videoRtcpIce": videoRtcpIceGatherer.getLocalParameters(),
  // Offer the DTLS parameters
  "audioRtpDtls": audioRtpDtlsTransport.getLocalParameters(),
  "audioRtcpDtls": audioRtcpDtlsTransport.getLocalParameters(),
  "videoRtpDtls": videoRtpDtlsTransport.getLocalParameters(),
  "videoRtcpDtls": videoRtcpDtlsTransport.getLocalParameters(),
  // Offer the receiver and sender audio and video capabilities.
  "recvAudioCaps": recvAudioCaps,
  "recvVideoCaps": recvVideoCaps,
  "sendAudioCaps": sendAudioCaps,
  "sendVideoCaps": sendVideoCaps
}, function(answer) {
  // The responder answers with its preferences, parameters and capabilities
  // Since we didn"t create transport arrays, we are assuming that there
  // is no forking (only one response)
  //
  // Derive the send and receive parameters, assuming that RTP/RTCP mux will be enabled.
  var audioSendParams = myCapsToSendParams(sendAudioCaps, answer.recvAudioCaps);
  var videoSendParams = myCapsToSendParams(sendVideoCaps, answer.recvVideoCaps);
  var audioRecvParams = myCapsToRecvParams(recvAudioCaps, answer.sendAudioCaps);
  var videoRecvParams = myCapsToRecvParams(recvVideoCaps, answer.sendVideoCaps);
  //
  // If the responder wishes to enable bundle, we will enable it
  if (answer.bundle) {
    // Since bundle implies RTP/RTCP multiplexing, we only need a single
    // ICE transport and DTLS transport. No need for the ICE transport controller.
    audioRtpIceTransport.start(audioRtpIceGatherer, answer.audioRtpIce, RTCIceRole.controlling);
    audioRtpDtlsTransport.start(remote.audioRtpDtls);
    //
    // Replace the transport on the Sender and Receiver objects
    //
    audioSender.setTransport(audioRtpDtlsTransport);
    videoSender.setTransport(audioRtpDtlsTransport);
    audioReceiver.setTransport(audioRtpDtlsTransport);
    videoReceiver.setTransport(audioRtpDtlsTransport);
    // If BUNDLE was requested, then also assume RTP/RTCP mux
    answer.rtcpMux = true;
  } else {
    var controller = new RTCIceTransportController();
    if (answer.rtcpMux) {
      // The peer doesn"t want BUNDLE, but it does want to multiplex RTP/RTCP
      // Now we need audio and video ICE transports
      // as well as an ICE Transport Controller object
      controller.addTransport(audioRtpIceTransport);
      controller.addTransport(videoRtpIceTransport);
      // Start the audio and video ICE transports
      audioRtpIceTransport.start(audioRtpIceGatherer, answer.audioRtpIce, RTCIceRole.controlling);
      videoRtpIceTransport.start(videoRtpIceGatherer, answer.videoRtpIce, RTCIceRole.controlling);
      // Start the audio and video DTLS transports
      audioRtpDtlsTransport.onerror = errorHandler;
      audioRtpDtlsTransport.start(answer.audioRtpDtls);
      videoRtpDtlsTransport.onerror = errorHandler;
      videoRtpDtlsTransport.start(answer.videoRtpDtls);
      // Replace the transport on the Sender and Receiver objects
      //
      audioSender.setTransport(audioRtpDtlsTransport);
      videoSender.setTransport(videoRtpDtlsTransport);
      audioReceiver.setTransport(audioRtpDtlsTransport);
      videoReceiver.setTransport(videoRtpDtlsTransport);
    } else {
      // We arrive here if the responder does not want BUNDLE
      // or RTP/RTCP multiplexing
      //
      // Now we need all the audio and video RTP and RTCP ICE transports
      // as well as an ICE Transport Controller object
      controller.addTransport(audioRtpIceTransport);
      controller.addTransport(videoRtpIceTransport);
      // Start the ICE transports
      audioRtpIceTransport.start(audioRtpIceGatherer, answer.audioRtpIce, RTCIceRole.controlling);
      audioRtcpIceTransport.start(audioRtcpIceGatherer, answer.audioRtcpIce, 
        RTCIceRole.controlling);
      videoRtpIceTransport.start(videoRtpIceGatherer, answer.videoRtpIce, RTCIceRole.controlling);
      videoRtcpIceTransport.start(videoRtcpIceGatherer, answer.videoRtcpIce,
        RTCIceRole.controlling);
      // Start the DTLS transports that are needed
      audioRtpDtlsTransport.start(answer.audioRtpDtls);
      audioRtcpDtlsTransport.start(answer.audioRtcpDtls);
      videoRtpDtlsTransport.start(answer.videoRtpDtls);
      videoRtcpDtlsTransport.start(answer.videoRtcpDtls);
      // Disable RTP/RTCP multiplexing
      audioSendParams.rtcp.mux = false;
      videoSendParams.rtcp.mux = false;
      audioRecvParams.rtcp.mux = false;
      videoRecvParams.rtcp.mux = false;
    }
  }
  // Set the audio and video send and receive parameters.
  audioSender.send(audioSendParams).then(function() {
    trace("Set audio sender parameters");
    }, function() {
      trace("Could not set audio sender parameters");
    }
  );
  videoSender.send(videoSendParams).then(function() {
    trace("Set video sender parameters");
    }, function() {
      trace("Could not set video sender parameters");
    }
  );
  audioReceiver.receive(audioRecvParams).then(function() {
    trace("Set audio receiver parameters");
    }, function() {
      trace("Could not set audio receiver parameters");
    }
  );
  videoReceiver.receive(videoRecvParams).then(function() {
    trace("Set video receiver parameters");
    }, function() {
      trace("Could not set video receiver parameters");
    }
  );
// Now we can render/play audioReceiver.track and videoReceiver.track
                </pre>
            </section>
        </section>
        <section id="rtcrtplistener*">
            <h2>The RTCRtpListener Object</h2>
            <p>
                The <dfn><code>RTCRtpListener</code></dfn> listens to RTP packets received from the <code><a>RTCDtlsTransport</a></code>, determining whether an
                incoming RTP stream is configured to be processed by an existing <code><a>RTCRtpReceiver</a></code> object. If no match is found,
                the <code><a>unhandledrtp</a></code> event is fired. This can be due to packets having an unknown SSRC, payload type or any other
                error that makes it impossible to attribute an RTP packet to a specific <code><a>RTCRtpReceiver</a></code> object. The event is
                not fired once for each arriving packet; multiple discarded packets for the same SSRC  <em class="rfc2119" title="SHOULD">SHOULD</em> result in a single event.
            </p>
            <p>
                Note that application handling of the <code><a>unhandledrtp</a></code> event may not be sufficient to enable the unhandled RTP stream to be rendered. The amount of buffering to be provided for unhandled
                RTP streams is not mandated by this specification and is recommended to be strictly limited to protect against denial of service
                attacks. Therefore an application attempting to create additional <code><a>RTCRtpReceiver</a></code> objects to handle
                the incoming RTP stream may find that portions of the incoming RTP stream were lost due to insufficient buffers, and therefore
                could not be rendered.
            </p>
            <section id="rtcrtplistener-overview*">
                <h3>Overview</h3>
                <p>An <code><a>RTCRtpListener</a></code> instance is associated to an <code><a>RTCDtlsTransport</a></code>.</p>
            </section>
            <section id="rtcrtplistener-operation*">
                <h3>Operation</h3>
                <p()
                    An <code><a>RTCRtpListener</a></code> instance is constructed from an <code><a>RTCDtlsTransport</a></code> object.
                </p>
            </section>
            <section id="rtpmatchingrules*">
                <h3>RTP matching rules</h3>
                <p>
                    When the <code><a>RTCRtpListener</a></code> object receives an RTP packet over an <code><a>RTCDtlsTransport</a></code>,
                    the <code><a>RTCRtpListener</a></code> attempts to determine which <code><a>RTCRtpReceiver</a></code> object to deliver the
                    packet to, based on the values of the SSRC and payload type fields in the RTP header, as well as the value of the <a>MID</a>
                    RTP header extension, if present.
                </p>
                <p>
                    The <code><a>RTCRtpListener</a></code> maintains three tables in order to facilitate matching: the <var>ssrc_table</var> which maps SSRC
                    values to <code><a>RTCRtpReceiver</a></code> objects; the <var>muxId_table</var> which maps values of the <a>MID</a> header extension
                    to <code><a>RTCRtpReceiver</a></code> objects and the <var>pt_table</var> which maps payload type values to
                    <code><a>RTCRtpReceiver</a></code> objects.
                </p>
                <p>
                    For an <code><a>RTCRtpReceiver</a></code> object <var>receiver</var>, table entries are added when
                    <code>receiver.receive()</code> is called, and are removed when <code>receiver.stop()</code> is called.
                    If <code>receiver.receive()</code> is called again, all entries referencing <var>receiver</var> are removed
                    prior to adding new entries.
                </p>
                <p>
                    SSRC table: Set <var>ssrc_table</var>[<code>parameters.encodings[<var>i</var>].ssrc</code>] to
                    <var>receiver</var> for each entry where <code>parameters.encodings[<var>i</var>].ssrc</code> is set,
                    for values of <var>i</var> from 0 to the number of encodings.
                    Set <var>ssrc_table</var>[<code>parameters.encodings[<var>i</var>].rtx.ssrc</code>] to
                    <var>receiver</var> for each entry where <code>parameters.encodings[<var>i</var>].rtx.ssrc</code> is set,
                    for values of <var>i</var> from 0 to the number of encodings.
                    Set <var>ssrc_table</var>[<code>parameters.encodings[<var>i</var>].fec.ssrc</code>] to
                    <var>receiver</var> for each entry where <code>parameters.encodings[<var>i</var>].fec.ssrc</code> is set,
                    for values of <var>i</var> from 0 to the number of encodings.
                    If <var>ssrc_table</var>[<var>ssrc</var>] is already set to a value other than <var>receiver</var>,
                    then <code>receiver.receive()</code> will throw an <code>InvalidParameters</code> exception.
                </p>
                <p>
                    muxId table: If <code>parameters.muxId</code> is set, <var>muxId_table</var>[<var>parameters.muxId</var>] is set
                    to <var>receiver</var>.
                    If <var>muxId_table</var>[<var>muxId</var>] is already set to a value other than <var>receiver</var>, then
                    <code>receiver.receive()</code> will throw an <code>InvalidParameters</code> exception.
                </p>
                <p>
                    payload type table: If <var>parameters.muxId</var> is unset and <code>parameters.encodings[i].ssrc</code>
                    is unset for all values of <var>i</var> from 0 to the number of encodings,
                    then add entries to <var>pt_table</var> by setting
                    <var>pt_table</var>[<code>parameters.codecs[<var>j</var>].payloadType</code>] to <var>receiver</var>,
                    for values of <var>j</var> from 0 to the number of codecs.
                    If <var>pt_table</var>[<var>pt</var>] is already set to a value other than <var>receiver</var>
                    then <code>receiver.receive()</code> will throw an <code>InvalidParameters</code> exception.
                </p>
                <p>
                    When an RTP packet arrives, the implementation determines the <code><a>RTCRtpReceiver</a></code> <var>rtp_receiver</var> to send it to as follows:
                    If <var>ssrc_table</var>[<var>packet.ssrc</var>] is set: set <var>rtp_receiver</var> to <var>ssrc_table</var>[<var>packet.ssrc</var>] and check
                    whether the value of <var>packet.pt</var> is equal to one of the values of <code>parameters.codecs[<var>j</var>].payloadtype</code> for <var>rtp_receiver</var>,
                    where <var>j</var> varies from 0 to the number of codecs.
                    If so, route the packet to <var>rtp_receiver</var>. If <var>packet.pt</var> does not match,
                    fire the <code><a>unhandledrtp</a></code> event.
                </p>
                <p>
                    Else if <var>packet.muxId</var> is set: If <var>muxId_table</var>[<var>packet.muxId</var>] is unset, fire the <code><a>unhandledrtp</a></code> event, else set
                    <var>rtp_receiver</var> to <var>muxId_table</var>[<var>packet.muxId</var>] and check
                    whether the value of <var>packet.pt</var> is equal to one of the values of <code>parameters.codecs[j].payloadtype</code> for the <code><a>RTCRtpReceiver</a></code> object <var>rtp_receiver</var>,
                    where <var>j</var> varies from 0 to the number of codecs.
                    If so, set <var>ssrc_table</var>[<var>packet.ssrc</var>] to <var>rtp_receiver</var> and route the packet to <var>rtp_receiver</var>.
                    If <var>packet.pt</var> does not match, fire the <code><a>unhandledrtp</a></code> event.
                </p>
                <p>
                    Else if <var>pt_table</var>[<var>packet.pt</var>] is set: set <var>rtp_receiver</var> to <var>pt_table</var>[<var>packet.pt</var>],
                    set <var>ssrc_table</var>[<var>packet.ssrc</var>] to <var>rtp_receiver</var>, set <var>pt_table</var>[<var>packet.pt</var>] to null
                    and route the packet to <var>rtp_receiver</var>. Question: Do we remove all <var>pt_table</var>[<var>packet.pt</var>] entries set to <var>rtp_receiver</var>?
                </p>
                <p>Else if no matches are found in the <var>ssrc_table</var>, <var>muxId_table</var> or <var>pt_table</var>, fire the <code><a>unhandledrtp</a></code> event.</p>
            </section>
            <section id="rtcrtplistener-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCRtpListener">
                    <dt>Constructor(RTCDtlsTransport transport)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCDtlsTransport transport</dt>
                    <dd>
                        <p>The RTP <code><a>RTCDtlsTransport</a></code> instance.</p>
                    </dd>
                    <dt>attribute EventHandler onunhandledrtp</dt>
                    <dd>
                        <p>
                            The event handler which handles the <code><a>RTCRtpUnhandledEvent</a></code>,
                            which is fired when the <code><a>RTCRtpListener</a></code> detects an
                            RTP stream that is not configured to be processed by an
                            existing <code><a>RTCRtpReceiver</a></code> object.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpunhandledevent-interface-definition*">
                <h3>RTCRtpUnhandledEvent</h3>
                <p>
                    The <code><a>unhandledrtp</a></code> event of the <code><a>RTCRtpListener</a></code> object uses
                    the <code><a>RTCRtpUnhandledEvent</a></code> interface.
                </p>
                <p>
                    Firing an
                    <code><a>RTCRtpUnhandledEvent</a></code> event named
                    <var>e</var> means that an event with the name <var>e</var>,
                    which does not bubble (except where otherwise stated) and is not
                    cancelable (except where otherwise stated), and which uses the
                    <code><a>RTCRtpUnhandledEvent</a></code> interface
                    <em class="rfc2119" title="MUST">MUST</em> be
                    created and dispatched at the given target.
                </p>
                <dl class="idl" data-merge="RTCRtpUnhandledEventInit"
                    title="interface RTCRtpUnhandledEvent : Event">
                    <dt>Constructor(DOMString type, RTCRtpUnhandledEventInit eventInitDict)</dt>
                    <dd></dd>
                    <dt>readonly attribute DOMString muxId</dt>
                    <dd>
                        <p>
                            The value of the <a>MID</a> RTP header extension [[!BUNDLE]] in the RTP stream
                            triggering the <code><a>unhandledrtp</a></code> event.
                            If <code>receive()</code> has not been called, the <a>MID</a> header
                            extension cannot be decoded, so that <code>muxId</code> will be unset.
                        </p>
                    </dd>
                    <dt>readonly attribute DOMString rid</dt>
                    <dd>
                        <p>
                            The value of the <a>RID</a> RTP header extension [[!RID]] in the RTP stream
                            triggering the <code><a>unhandledrtp</a></code> event.
                            If <code>receive()</code> has not been called, the <a>RID</a> header
                            extension cannot be decoded, so that <code>rid</code> will be unset.
                        </p>
                    </dd>
                    <dt>readonly attribute payloadtype payloadType</dt>
                    <dd>
                        <p>The Payload Type value in the RTP stream triggering the <code><a>unhandledrtp</a></code> event.</p>
                    </dd>
                    <dt>readonly attribute unsigned long ssrc</dt>
                    <dd>
                        <p>The SSRC in the RTP stream triggering the <code><a>unhandledrtp</a></code> event.</p>
                    </dd>
                </dl>
                <dl class="idl" title="dictionary RTCRtpUnhandledEventInit : EventInit">
                    <dt>DOMString muxId</dt>
                    <dd>
                        <p>
                            If present, the value of the <a>MID</a> RTP header extension [[!BUNDLE]] in the RTP stream
                            triggering the <code><a>unhandledrtp</a></code> event.
                        </p>
                    </dd>
                    <dt>DOMString rid</dt>
                    <dd>
                        <p>
                            If present, the value of the <a>RID</a> RTP header extension [[!RID]] in the RTP stream
                            triggering the <code><a>unhandledrtp</a></code> event.
                        </p>
                    </dd>
                    <dt>payloadtype payloadType</dt>
                    <dd>
                        <p>The Payload Type value in the RTP stream triggering the <code><a>unhandledrtp</a></code> event.</p>
                    </dd>
                    <dt>unsigned long ssrc</dt>
                    <dd>
                        <p>The SSRC in the RTP stream triggering the <code><a>unhandledrtp</a></code> event.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtplistener-example*">
                <h3>Example</h3>
                <pre class="example"><code class="javascript"></code></pre>
            </section>
        </section>
        <section id="rtcrtpdictionaries*">
            <h2>Dictionaries related to Rtp</h2>
            <section id="rtcrtpcapabilities*">
                <h3>dictionary RTCRtpCapabilities</h3>
                <p>
                    The <dfn><code>RTCRtpCapabilities</code></dfn> object expresses the capabilities of <code><a>RTCRtpSender</a></code> and
                    <code><a>RTCRtpReceiver</a></code> objects.
                    Features which are mandatory to implement in [[!RTP-USAGE]], such as RTP/RTCP multiplexing [[!RFC5761]],
                    audio/video multiplexing [[!RTP-MULTI-STREAM]]
                    and reduced size RTCP [[!RFC5506]] are assumed to be available and are therefore
                    not included in <code><a>RTCRtpCapabilities</a></code>,
                    although these features can be set via <code><a>RTCRtpParameters</a></code>.
                </p>
                <dl title="dictionary RTCRtpCapabilities" class="idl">
                    <dt>sequence&lt;RTCRtpCodecCapability&gt; codecs</dt>
                    <dd>
                        <p>Supported codecs.</p>
                    </dd>
                    <dt>sequence&lt;RTCRtpHeaderExtension&gt; headerExtensions</dt>
                    <dd>
                        <p>Supported RTP header extensions.</p>
                    </dd>
                    <dt>sequence&lt;DOMString&gt; fecMechanisms</dt>
                    <dd>
                        <p>
                            Supported Forward Error Correction (FEC) mechanisms. Values include
                            "red" [[!RFC2198]], "red+ulpfec" [[RFC5109]] and "flexfec" [[FLEXFEC]].
                            [[FEC]] summarizes requirements relating to FEC mechanisms.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtcpfeedback*">
                <h3>dictionary RTCRtcpFeedback</h3>
                <p><dfn>RTCRtcpFeedback</dfn> provides information on RTCP feedback messages.</p>
                <dl title="dictionary RTCRtcpFeedback" class="idl">
                    <dt>DOMString type</dt>
                    <dd>
                        <p>
                            Valid values for <code>type</code> are the "RTCP Feedback" Attribute Values enumerated in
                            [[!IANA-SDP-14]] ("ack", "ccm", "nack", etc.), as well as "goog-remb" [[REMB]] and "transport-cc" [[TRANSPORT-CC]].
                        </p>
                    </dd>
                    <dt>DOMString parameter</dt>
                    <dd>
                        <p>
                            For a <code>type</code> value of "ack" or "nack", valid values for <code>parameter</code> are the
                            "ack" and "nack" Attribute Values enumerated in [[!IANA-SDP-15]] ("sli", "rpsi", etc.).
                            For the Generic NACK feedback message defined in [[!RFC4585]] Section 6.2.1,
                            the <code>type</code> attribute is set to "nack" and the <code>parameter</code> attribute is unset.
                            For a <code>type</code> value of "ccm", valid values for <code>parameter</code> are the
                            "Codec Control Messages" enumerated in [[!IANA-SDP-19]] ("fir", "tmmbr" (includes "tmmbn"), etc.).
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpcodeccapability*">
                <h3>dictionary RTCRtpCodecCapability</h3>
                <p><dfn><code>RTCRtpCodecCapability</code></dfn> provides information on the capabilities of a codec.</p>
                <dl class="idl" title="typedef object Dictionary"></dl>
                <dl class="idl" title="typedef octet payloadtype"></dl>
                <dl class="idl" title="dictionary RTCRtpCodecCapability">
                    <dt>DOMString name</dt>
                    <dd>
                        <p>The MIME media subtype. Valid subtypes are listed in [[!IANA-RTP-2]].</p>
                    </dd>
                    <dt>DOMString mimeType</dt>
                    <dd>
                        <p>
                            The codec MIME media type/subtype. Valid media types and subtypes
                            are listed in [[IANA-RTP-2]].
                        </p>
                    </dd>
                    <dt>DOMString kind</dt>
                    <dd>
                        <p>The media supported by the codec: "audio", "video", etc.</p>
                    </dd>
                    <dt>unsigned long clockRate</dt>
                    <dd>
                        <p>Codec clock rate expressed in Hertz.  If unset, the codec is applicable to any clock rate.</p>
                    </dd>
                    <dt>payloadtype preferredPayloadType</dt>
                    <dd>
                        <p>
                            The preferred RTP payload type for the codec denoted by <code>RTCRtpCodecCapability.name</code>.
                            This attribute was added to make it possible for the sender and receiver to pick a
                            matching payload type when creating sender and receiver parameters.
                            When returned by <code>RTCRtpSender.getCapabilities()</code>, <code>RTCRtpCapabilities.codecs.preferredPayloadtype</code>
                            represents the preferred RTP payload type for sending.
                            When returned by <code>RTCRtpReceiver.getCapabilities()</code>, <code>RTCRtpCapabilities.codecs.preferredPayloadtype</code>
                            represents the preferred RTP payload type for receiving.
                            To avoid payload type conflicts, each value of <code>preferredPayloadType</code> MUST be unique.
                        </p>
                    </dd>
                    <dt>unsigned long maxptime</dt>
                    <dd>
                        <p>The maximum packetization time supported by the <code><a>RTCRtpReceiver</a></code>.</p>
                    </dd>
                    <dt>unsigned long ptime</dt>
                    <dd>
                        <p>The preferred duration of media represented by a packet in milliseconds for the <code><a>RTCRtpSender</a></code> or
                        <code><a>RTCRtpReceiver</a></code>.</p>
                    </dd>
                    <dt>unsigned long numChannels</dt>
                    <dd>
                        <p>
                            The number of channels supported (e.g. two for stereo).
                            For video, this attribute is unset.
                        </p>
                    </dd>
                    <dt>sequence&lt;RTCRtcpFeedback&gt; rtcpFeedback</dt>
                    <dd>
                        <p>Transport layer and codec-specific feedback messages for this codec.</p>
                    </dd>
                    <dt>Dictionary parameters</dt>
                    <dd>
                        <p>Codec-specific parameters that must be signaled to the remote party.</p>
                    </dd>
                    <dt>Dictionary options</dt>
                    <dd>
                        <p>
                            Codec-specific parameters that may be optionally signalled and are available
                            as additional supported information or settings about the codec.
                        </p>
                    </dd>
                    <dt>unsigned short maxTemporalLayers = 0</dt>
                    <dd>
                        <p>Maximum number of temporal layer extensions supported by this codec (e.g. a value of 1 indicates support for up to 2 temporal layers). A value of 0 indicates no support for temporal scalability.</p>
                    </dd>
                    <dt>unsigned short maxSpatialLayers = 0</dt>
                    <dd>
                        <p>Maximum number of spatial layer extensions supported by this codec (e.g. a value of 1 indicates support for up to 2 spatial layers). A value of 0 indicates no support for spatial scalability.</p>
                    </dd>
                    <dt>boolean svcMultiStreamSupport</dt>
                    <dd>
                        <p>
                            Whether the implementation can send/receive SVC layers utilizing distinct SSRCs.
                            Unset for audio codecs. For video codecs, only set if the codec supports scalable
                            video coding with <a>MRST</a>.
                        </p>
                    </dd>
                </dl>
                <section id="codec-capabilities*">
                    <h3>Codec capability options</h3>
                    <p>The capability options of commonly implemented codecs are provided below.</p>
                    <p>
                       If a defined codec option is unset when returned from
                       <code>RTCRtpReceiver/Sender.getCapabilities()</code>, then the engine does not allow adjusting the option.
                       If set when returned from <code>RTCRtpReceiver/Sender.getCapabilities()</code> then the default value for the
                       engine is given.
                    </p>
                    <section id="opus-codec-options*">
                        <h3>Opus</h3>
                        <p>The following capability options are defined for Opus:</p>
                               <table class="simple">
                               <thead>
                                   <tr>
                                       <th>Property Name</th>
                                       <th>Values</th>
                                       <th>Receiver/Sender</th>
                                       <th>Notes</th>
                                   </tr>
                               </thead>
                               <tbody>
                                <tr id="def-complexity*">
                                    <td><dfn><code>complexity</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Indicates the default value for the encoder's computational complexity.  The supported range is 0-10 with 10 representing the highest complexity.</td>
                                </tr>
                                <tr id="def-signal*">
                                    <td><dfn><code>signal</code></dfn></td>
                                    <td>
                                        <code>DOMString</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Indicates the default value for the type of signal being encoded.  Possible values are
                                        "auto", "music" and "voice".</td>
                                </tr>
                                <tr id="def-application*">
                                    <td><dfn><code>application</code></dfn></td>
                                    <td>
                                        <code>DOMString</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Indicates the default value for the encoder's intended application.  Possible values 
                                        are "voip", "audio" and "lowdelay".</td>
                                </tr>
                                <tr id="def-packetlossperc*">
                                    <td><dfn><code>packetLossPerc</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Indicates the default value for the encoder's expected packet loss percentage.  Possible values are 0-100.</td>
                                </tr>
                                <tr id="def-predictiondisabled*">
                                    <td><dfn><code>predictionDisabled</code></dfn></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Indicates the default value for whether prediction is disabled, making frames almost complete independent
                                       (if <code>true</code>) or not (if <code>false</code>).</td>
                                </tr>
                            </tbody>
                        </table>
                </section>
                </section>
                <section id="codec-capabilities*">
                    <h3>Codec capability parameters</h3>
                    <p>The capability parameters for commonly implemented codecs are provided below.</p>
                    <p>
                       If a defined codec capability parameter is unset when returned from
                       <code>RTCRtpReceiver/Sender.getCapabilities()</code>, then the engine does not allow adjusting the parameter.
                       If set when returned from <code>RTCRtpReceiver/Sender.getCapabilities()</code> then the default value for the
                       engine is given.
                    </p>
                    <section id="opus-codec-capabilities*">
                        <h3>Opus</h3>
                        <p>The following optional capability parameters are defined for "opus", as noted in [[!RFC7587]] Section 6.1:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="def-maxplaybackrate*">
                                    <td><dfn><code>maxPlaybackRate</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>A hint about the maximum output sampling rate that the receiver is capable of rendering in Hz.</td>
                                </tr>
                                <tr id="def-sprop-maxcapturerate*">
                                    <td><dfn><code>spropMaxCaptureRate</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>A hint about the maximum input sampling rate that the sender is likely to produce.</td>
                                </tr>
                                <tr id="def-maxaveragebitrate*">
                                    <td><dfn><code>maxAverageBitrate</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>Specifies the maximum average receive bitrate of a session in bits per second (bits/s).</td>
                                </tr>
                                <tr id="def-cbr*">
                                    <td><dfn><code>cbr</code></dfn></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>Specifies if the decoder prefers the use of constant bitrate (if <code>true</code>) or variable bitrate (if <code>false</code>).</td>
                                </tr>
                                <tr id="def-useinbandfec*">
                                    <td><dfn><code>useInbandFec</code></dfn></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>Specifies if the decoder has the capability to take advantage of Opus in-band fec (if <code>true</code>) or not (if <code>false</code>).</td>
                                </tr>
                                <tr id="def-usedtx*">
                                    <td><dfn><code>useDtx</code></dfn></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>Specifies if the decoder prefers the use of DTX (if <code>true</code>) or not (if <code>false</code>).</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="vp-codec-dictionary*">
                        <h3>VP8</h3>
                        <p>The following receiver capability parameters are defined for "vp8", as noted in [[RFC7741]] Section 6.1:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="def-max-fr*">
                                    <td><dfn><code>maxFr</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>This parameter indicates the maximum frame rate in frames per second that the decoder is capable of decoding.</td>
                                </tr>
                                <tr id="def-max-fs*">
                                    <td><dfn><code>maxFs</code></dfn></td>
                                    <td>
                                        <code>unsigned long long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>This parameter indicates the maximum frame size in macroblocks that the decoder is capable of decoding.</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="h264-capabilities*">
                        <h3>H.264</h3>
                        <p>The following capability parameters are defined for "h264", as noted in [[RFC6184]] Section 8.1, and [[!RFC7742]] Section 6.2.</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="def-profile-level-id*">
                                    <td><dfn><code>profileLevelId</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver/Sender</td>
                                    <td>
                                        This parameter describes the maximum capability of the decoder (for an
                                        <code><a>RTCRtpReceiver</a></code>) or the encoder (for an <code><a>RTCRtpSender</a></code>).
                                        It MUST be supported, as noted in [[!RFC7742]] Section 6.2.
                                    </td>
                                </tr>
                                <tr id="def-packetization-mode*">
                                    <td><dfn><code>packetizationMode</code></dfn></td>
                                    <td><code>sequence&lt;unsigned short&gt;</code></td>
                                    <td>Receiver/Sender</td>
                                    <td>
                                        A sequence of unsigned shorts, each ranging from 0 to 2, indicating supported <var>packetizationMode</var> values.
                                        As noted in [[!RFC7742]] Section 6.2, support for packetization-mode 1 is mandatory.
                                    </td>
                                </tr>
                                <tr id="def-other-h264-params*">
                                    <td>maxMbps, maxSmbps, maxFs, maxCpb, maxDpb, maxBr</td>
                                    <td>
                                        <code>unsigned long long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>
                                        As noted in [[!RFC7742]] Section 6.2, these optional parameters
                                        allow the implementation to specify that the decoder can support
                                        certain features of H.264 at higher rates and values than those
                                        signalled with profile-level-id.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="rtx-codec-capability*">
                        <h3>RTX</h3>
                        <p>The following capability is defined for "rtx", as noted in [[!RFC4588]] Section 8.6:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                            <tr id="def-apt*">
                                    <td><dfn><code>apt</code></dfn></td>
                                    <td>
                                        <code>payloadType</code>
                                    </td>
                                    <td>Receiver/Sender</td>
                                    <td>
                                        As defined in [[!RFC4588]], the associated payload type
                                        of the original stream being retransmitted. There will be an
                                        "rtx" entry in <code>RTCRtpCapabilities.codecs[]</code> for
                                        each media codec that can be retransmitted, each with their own
                                        <code>apt</code> parameter.
                                    </td>
                                </tr>
                                <tr id="def-rtxtime*">
                                    <td><dfn><code>rtxTime</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>
                            As defined in [[!RFC4588]], the default time in milliseconds (measured from the
                            time a packet was first sent) that the sender keeps an RTP packet
                            in its buffers available for retransmission.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="red-codec-capability*">
                        <h3>RED</h3>
                        <p>As defined in [[!RFC2198]] Section 5, "red" has no codec-specific capability parameters.</p>
                    </section>
                    <section id="ulpfec-codec-capability*">
                        <h3>Ulpfec</h3>
                        <p>As noted in [[RFC5109]], "ulpfec" has no codec-specific capability parameters.</p>
                    </section>
                    <section id="flexfec-codec-capability*">
                        <h3>Flexfec</h3>
                        <p>The following capabilities are defined for "flexfec", as noted in [[FLEXFEC]] Section 5.1.1:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="def-repairwindow*">
                                    <td><dfn><code>repairWindow</code></dfn></td>
                                    <td>
                                        <code>unsigned long long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>The default time that spans the source packets and the corresponding repair packets, in microseconds.</td>
                                </tr>
                                <tr id="def-l*">
                                    <td><dfn><code>l</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>The default number of columns of the source block that are protected by this FEC block.</td>
                                </tr>
                                <tr id="def-d*">
                                    <td><dfn><code>d</code></dfn></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>The default number of rows of the source block that are protected by this FEC block.</td>
                                </tr>
                                <tr id="def-top*">
                                    <td><dfn><code>toP</code></dfn></td>
                                    <td>
                                        <code>unsigned short</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>The default type of protection for the sender:
                                        0 for 1-D interleaved FEC protection, 1 for 1-D non-interleaved FEC protection,
                                        and 2 for 2-D parity FEC protection. The value of 3 is reserved for future use.

                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                </section>
            </section>
            <section id="rtcrtpparameters*">
                <h3>dictionary RTCRtpParameters</h3>
                <p><dfn>RTCRtpParameters</dfn> contains the RTP stack settings.</p>
                <dl title="dictionary RTCRtpParameters" class="idl">
                    <dt>DOMString muxId=""</dt>
                    <dd>
                        <p>
                            The <code>muxId</code> assigned to the RTP stream, if any, empty string if unset.
                            In an <code><a>RTCRtpReceiver</a></code> or <code><a>RTCRtpSender</a></code> object, this corresponds to
                            <a>MID</a> RTP header extension defined in [[!BUNDLE]]. This is a stable identifier that permits
                            the track corresponding to an RTP stream to be identified, rather than relying on an SSRC.
                            An SSRC is randomly generated and can change arbitrarily due to conflicts with other SSRCs, whereas
                            the <code>muxId</code> has a value whose meaning can be defined in advance between RTP
                            sender and receiver, assisting in RTP demultiplexing. Since <code>muxId</code> is included in
                            <code><a>RTCRtpParameters</a></code> but not in <code><a>RTCRtpEncodingParameters</a></code>,
                            if it is desired to send simulcast streams with different <code>muxId</code> values
                            for each stream, then multiple <code><a>RTCRtpSender</a></code> objects are needed.
                        </p>
                    </dd>
                    <dt>required sequence&lt;RTCRtpCodecParameters&gt; codecs</dt>
                    <dd>
                        <p>
                            The codecs to send or receive (could include "red" [[RFC2198]], "rtx" [[!RFC4588]] and "cn" [[RFC3389]]).
                            <code>codecs</code> MUST be set for an <code><a>RTCRtpParameters</a></code> object to be a valid
                            argument passed to <code>send()</code> or <code>receive()</code>.
                        </p>
                    </dd>
                    <dt>sequence&lt;RTCRtpHeaderExtensionParameters&gt; headerExtensions</dt>
                    <dd>
                        <p>Configured header extensions.  If unset, no header extensions are configured.</p>
                    </dd>
                    <dt>sequence&lt;RTCRtpEncodingParameters&gt; encodings</dt>
                    <dd>
                        <p>
                            The "encodings" or "layers" to be used for things like simulcast, Scalable
                            Video Coding, RTX, FEC, etc. When unset in a call to <code>send()</code>,
                            the browser behaves as though a single <code>encodings[0]</code> entry was provided, with
                            <code>encodings[0].ssrc</code> set to a browser-determined value, <code>encodings[0].active</code>
                            set to <code>true</code>, <code>encodings[0].codecPayloadType</code> set to <code>codecs[<var>j</var>].payloadType</code>
                            where <var>j</var> is the index of the first codec that is not "cn", "telephone-event",
                            "red", "rtx" or a forward error correction codec ("ulpfec" [[RFC5109]] or "flexfec" [[FLEXFEC]]),
                            and all the other <code>parameters.encodings[0]</code> attributes (e.g. <code>fec</code>, <code>rtx</code>, <code>priority</code>,
                            <code>maxBitrate</code>, <code>resolutionScale</code>, etc.) unset. When unset in a call to <code>receive()</code>,
                            the behavior is described in Section 8.3.
                        </p>
                    </dd>
                    <dt>RTCRtcpParameters rtcp</dt>
                    <dd>
                        <p>Parameters to configure RTCP. If unset, the default values described in Section 9.6.1 are assumed.<p>
                    </dd>
                    <dt>RTCDegradationPreference degradationPreference = "balanced"</dt>
                    <dd>
                        <p>
                            When bandwidth is constrained and the <code><a>RTCRtpSender</a></code> needs to choose between degrading
                            resolution or degrading framerate, <code>degradationPreference</code> indicates which is preferred.
                            <code>degradationPreference</code> is ignored in an <code><a>RTCRtpReceiver</a></code> object. If
                            unset, "balanced" is assumed.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcdegradationpreference*">
                <h3>enum RTCDegradationPreference</h3>
                <p>
                     <dfn><code>RTCDegradationPreference</code></dfn> can be used to indicate the desired choice between degrading resolution
                     and degrading framerate when bandwidth is constrained.
                </p>

                <dl class="idl" title="enum RTCDegradationPreference">
                    <dt>maintain-framerate</dt>
                    <dd>
                         <p>Degrade resolution in order to maintain framerate.</p>
                    </dd>
                    <dt>maintain-resolution</dt>
                    <dd>
                         <p>Degrade framerate in order to maintain resolution.</p>
                    </dd>
                    <dt>balanced</dt>
                    <dd>
                         <p>Degrade a balance of framerate and resolution.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtcpparameters*">
                <h3>dictionary RTCRtcpParameters</h3>
                <p><dfn><code>RTCRtcpParameters</code></dfn> provides information on RTCP settings.</p>
                <dl title="dictionary RTCRtcpParameters" class="idl">
                    <dt>unsigned long ssrc</dt>
                    <dd>
                        <p>
                            The SSRC to be used in the "SSRC of packet sender" field defined in [[!RFC3550]] Section 6.4.2 (Receiver Report)
                            and [[!RFC4585]] Section 6.1 (Feedback Messages), as well as the "SSRC" field defined in [[!RFC3611]] Section 2 (Extended Reports).
                            It can only be set for an <code><a>RTCRtpReceiver</a></code>. Other than for debugging, or situations where <code>receive()</code>
                            is called before <code>send()</code> on the same <code><a>RTCDtlsTransport</a></code> it is best to leave it unset,
                            in which case <code>ssrc</code> is chosen by the browser, though the chosen value is not reflected in <code>RTCRtcpParameters.ssrc</code>.
                            If the browser chooses the <code>ssrc</code> it may change it in event of a collision, as described in [[!RFC3550]].
                            Where <code>send(<var>parameters</var>)</code> is called before <code>receive()</code> on the same
                            <code><a>RTCDtlsTransport</a></code>, the browser can choose one of the SSRCs allocated to an
                            <code><a>RTCRtpSender</a></code> of the same <code>kind</code>. Where <code>receive()</code> is called first,
                            a random SSRC value can be chosen.
                        </p>
                    </dd>
                    <dt>DOMString cname</dt>
                    <dd>
                        <p>
                            The Canonical Name (CNAME) used by RTCP (e.g. in SDES messages). Guidelines for CNAME generation are provided in [[!RTP-USAGE]] Section 4.9 and [[!RFC7022]].
                            By default, ORTC implementations  <em class="rfc2119" title="SHOULD">SHOULD</em> set the CNAME to be the same within all <code>RTCRtcpParameter</code> objects created within the
                            same Javascript sandbox. For backward compatibility with WebRTC 1.0, applications MAY set the CNAME only for an <code><a>RTCRtpReceiver</a></code>;
                            if unset, the CNAME is chosen by the browser.
                        </p>
                    </dd>
                    <dt>boolean reducedSize=false</dt>
                    <dd>
                        <p>
                            Whether reduced size RTCP [[!RFC5506]] is configured (if <code>true</code>) or compound RTCP as specified in [[!RFC3550]] (if <code>false</code>).
                            The default is <code>false</code>.
                        </p>
                    </dd>
                    <dt>boolean mux=true</dt>
                    <dd>
                        <p>
                            Whether RTP and RTCP are multiplexed, as specified in [[!RFC5761]].
                            The default is <code>true</code>. If set to <code>false</code>, the
                            <code><a>RTCIceTransport</a></code>
                            <em class="rfc2119" title="MUST">MUST</em> have an associated <code><a>RTCIceTransport</a></code> object with
                            a <code>component</code> of <code>RTCP</code>,
                            in which case RTCP will be sent on the associated <code><a>RTCIceTransport</a></code>.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpcodecparameters*">
                <h3>dictionary RTCRtpCodecParameters</h3>
                <p><dfn>RTCRtpCodecParameters</dfn> provides information on codec settings.</p>
                <dl title="dictionary RTCRtpCodecParameters" class="idl">
                    <dt>required DOMString name</dt>
                    <dd>
                        <p>
                            The codec MIME subtype. Valid subtypes are
                            listed in [[!IANA-RTP-2]].
                        </p>
                    </dd>
                    <dt>DOMString mimeType</dt>
                    <dd>
                        <p>
                            The codec MIME media type/subtype. Valid media types and subtypes
                            are listed in [[IANA-RTP-2]].
                        </p>
                    </dd>
                    <dt>required payloadtype payloadType</dt>
                    <dd>
                        <p>
                            The value that goes in the RTP Payload Type Field [[!RFC3550]]. The <code>payloadType</code>
                            MUST always be provided, and MUST be unique.
                        </p>
                    </dd>
                    <dt>unsigned long clockRate</dt>
                    <dd>
                        <p>
                            Codec clock rate expressed in Hertz.  If unset, the implementation default is assumed.
                        </p>
                    </dd>
                    <dt>unsigned long maxptime</dt>
                    <dd>
                        <p>
                            The maximum packetization time set on the <code><a>RTCRtpSender</a></code>.
                            Not specified if unset.  If <code>ptime</code> is also set, <code>maxptime</code> is ignored.
                        </p>
                    </dd>
                    <dt>unsigned long ptime</dt>
                    <dd>
                        <p>The duration of media represented by a packet in milliseconds for the <code><a>RTCRtpSender</a></code>.
                        If unset, the <code><a>RTCRtpSender</a></code> may select any value up to <code>maxptime</code>.
                    </dd>
                    <dt>unsigned long numChannels</dt>
                    <dd>
                        <p>
                            The number of channels supported (e.g. two for stereo). If unset for audio, use the codec default.
                            For video, this can be left unset.
                        </p>
                    </dd>
                    <dt>sequence&lt;RTCRtcpFeedback&gt; rtcpFeedback</dt>
                    <dd>
                        <p>Transport layer and codec-specific feedback messages for this codec.</p>
                    </dd>
                    <dt>Dictionary parameters</dt>
                    <dd>
                        <p>Codec-specific parameters available for signaling.</p>
                    </dd>
                </dl>
                <section id="codec-parameters*">
                    <h3>Codec parameters</h3>
                    <p>The parameters of common codecs are described below.</p>
                    <section id="opus-codec-settings*">
                        <h3>Opus</h3>
                        <p>The following settings are defined for "opus":</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-maxplaybackrate*">
                                    <td><a>maxPlaybackRate</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>The maximum output sampling rate of the encoder in Hz.</td>
                                </tr>
                                <tr id="sec-sprop-maxcapturerate*">
                                    <td><a>spropMaxCaptureRate</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>The maximum input sampling rate produced by the sender.</td>
                                </tr>
                                <tr id="sec-cbr*">
                                    <td><a>cbr</a></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Specifies if the encoder is configured to generate constant bitrate (if <code>true</code>) or variable bitrate (if <code>false</code>).</td>
                                </tr>
                                <tr id="sec-useinbandfec*">
                                    <td><a>useInbandFec</a></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Specifies if the encoder is configured to generate Opus in-band fec (if <code>true</code>) or not (if <code>false</code>).</td>
                                </tr>
                                <tr id="sec-usedtx*">
                                    <td><a>useDtx</a></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Specifies if the encoder is configured to use DTX (if <code>true</code>) or not (if <code>false</code>).</td>
                                </tr>
                                <tr id="sec-complexity*">
                                    <td><a>complexity</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Configures the encoder's computational complexity. The supported range is 0-10 with 10 representing the highest complexity.</td>
                                </tr>
                                <tr id="sec-signal*">
                                    <td><a>signal</a></td>
                                    <td>
                                        <code>DOMString</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Configures the type of signal being encoded.  Possible values are "auto", "music" and "voice".</td>
                                </tr>
                                <tr id="sec-application*">
                                    <td><a>application</a></td>
                                    <td>
                                        <code>DOMString</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Configures the encoder's intended application.  Possible values are "voip", "audio" and "lowdelay".</td>
                                </tr>
                                <tr id="sec-packetlossperc*">
                                    <td><a>packetLossPerc</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Configures the encoder's expected packet loss percentage.  Possible values are 0-100.</td>
                                </tr>
                                <tr id="sec-predictiondisabled*">
                                    <td><a>predictionDisabled</a></td>
                                    <td>
                                        <code>boolean</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>Configures whether prediction is disabled, making frames almost complete independent (if <code>true</code>) or not (if <code>false</code>).</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="vp8-settings*">
                        <h3>VP8</h3>
                        <p>The following settings are defined for "vp8":</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-max-fr*">
                                    <td><a>maxFr</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>This parameter indicates the maximum frame rate in frames per second that the decoder is capable of decoding.</td>
                                </tr>
                                <tr id="sec-max-fs*">
                                    <td><a>maxFs</a></td>
                                    <td>
                                        <code>unsigned long long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>This parameter indicates the maximum frame size in macroblocks that the decoder is capable of decoding.</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="h264-settings*">
                        <h3>H.264</h3>
                        <p>The following settings are defined for "h264":</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-profile-level-id*">
                                    <td><a>profileLevelId</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Sender</td>
                                    <td>This parameter indicates the configuration of the stream to be sent, as noted in [[RFC6184]] Section 8.2.2.
                                    It MUST be supported, as noted in [[!RFC7742]] Section 6.2.</td>
                                </tr>
                                <tr id="sec-packetization-mode*">
                                    <td><a>packetizationMode</a></td>
                                    <td><code>unsigned short</code></td>
                                    <td>Sender</td>
                                    <td>
                                        An unsigned short ranging from 0 to 2, indicating the <var>packetizationMode</var> value to be used by the sender.  This setting MUST be
                                        supported, as noted in [[!RFC7742]] Section 6.2.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="rtx-codec-settings*">
                        <h3>RTX</h3>
                        <p>The following settings are defined for "rtx", as noted in [[!RFC4588]] Section 8.6:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-apt*">
                                    <td><a>apt</a></td>
                                    <td>
                                        <code>payloadType</code>
                                    </td>
                                    <td>Receiver/Sender</td>
                                    <td>
                                        As defined in [[!RFC4588]], the associated payload type
                                        of the original stream being retransmitted. There will be an
                                        "rtx" entry in <code>RTCRtpParameters.codecs[]</code> for
                                        each media codec that can be retransmitted, each with their own
                                        <code>apt</code> parameter.
                                    </td>
                                </tr>
                                <tr id="sec-rtxtime*">
                                    <td><a>rtxTime</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>
                            As defined in [[!RFC4588]], the time in milliseconds (measured from the
                            time a packet was first sent) that the sender keeps an RTP packet
                            in its buffers available for retransmission.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="red-codec-settings*">
                        <h3>RED</h3>
                        <p>The following setting is defined for "red", as noted in [[!RFC2198]] Section 5:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-payloadtypes*">
                                    <td>payloadTypes</td>
                                    <td>
                                        <code>sequence&lt;payloadtype&gt</code>
                                    </td>
                                    <td>Sender/Receiver</td>
                                    <td>
                                        A sequence of payload types to be encapsulated in RED,
                                        each of which MUST be unique.  If <code>payloadTypes</code> 
                                        is unset, this means that any codec other than "red" or
                                        "rtx" can be encapsulsated in RED.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="ulpfec-codec-settings*">
                        <h3>Ulpfec</h3>
                        <p>As noted in [[RFC5109]], "ulpfec" has no codec-specific settings.</p>
                    </section>
                    <section id="flexfec-codec-settings*">
                        <h3>Flexfec</h3>
                        <p>The following settings are defined for "flexfec", as noted in [[FLEXFEC]] Section 5.1.1:</p>
                        <table class="simple">
                            <thead>
                                <tr>
                                    <th>Property Name</th>
                                    <th>Values</th>
                                    <th>Receiver/Sender</th>
                                    <th>Notes</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr id="sec-repairwindow*">
                                    <td><a>repairWindow</a></td>
                                    <td>
                                        <code>unsigned long long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>The time that spans the source packets and the corresponding repair packets, in microseconds.</td>
                                </tr>
                                <tr id="sec-l*">
                                    <td><a>l</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>The number of columns of the source block that are protected by this FEC block.</td>
                                </tr>
                                <tr id="sec-d*">
                                    <td><a>d</a></td>
                                    <td>
                                        <code>unsigned long</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>The number of rows of the source block that are protected by this FEC block.</td>
                                </tr>
                                <tr id="sec-top*">
                                    <td><a>toP</a></td>
                                    <td>
                                        <code>unsigned short</code>
                                    </td>
                                    <td>Receiver</td>
                                    <td>The type of protection applied by the sender:  0 for 1-D interleaved FEC protection,
                                        1 for 1-D non-interleaved FEC protection, and 2 for 2-D parity FEC protection.
                                        The value of 3 is reserved for future use.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
            </section>
            </section>
            <section id="rtcrtpencodingparameters*">
                <h3>dictionary RTCRtpEncodingParameters</h3>

                <p><code><a>RTCRtpEncodingParameters</a></code> provides information relating to the encoding.  Note that all encoding parameters
                (such as <var>maxBitrate</var>, <var>maxFramerate</var> and <var>resolutionScale</var>) are applied prior to codec-specific constraints.</p>
                
                <dl class="idl" title="dictionary RTCRtpEncodingParameters">
                    <dt>unsigned long ssrc</dt>
                    <dd>
                        <p>
                            The SSRC for this layering/encoding.
                            Multiple <code>RTCRtpEncodingParameters</code> objects can share the same <code>ssrc</code> value
                            (useful, for example, to indicate that different RTX payload types associated to different codecs are carried over the same stream).
                            If <code>ssrc</code> is unset in a <code>RTCRtpEncodingParameters</code> object passed to the <code>receive()</code> method, the
                            next unhandled SSRC will match, and an <code>RTCRtpUnhandledEvent</code> will not be fired.
                            If <code>ssrc</code> is unset in a <code>RTCRtpEncodingParameters</code> object passed to the <code>send()</code>
                            method, the browser will choose, and the chosen value is not reflected in <code>RTCRtpEncodingParameters.ssrc</code>.
                            If the browser chooses the <code>ssrc</code>, it may change it due to a collision without firing an <code>RTCSsrcConflictEvent</code>.
                            If <code>ssrc</code> is set in an <code>RTCRtpEncodingParameters</code> object passed to the <code>send()</code>
                            method and an SSRC conflict is detected within the RTP session, then an <code>RTCSsrcConflictEvent</code> is fired (see Section 5.4).
                        </p>
                    </dd>
                    <dt>payloadtype codecPayloadType</dt>
                    <dd>
                        <p>
                            For per-encoding codec specifications, give the codec payload type here.
                            If unset, the browser will choose the first codec in <code>parameters.codecs[]</code>
                            of the appropriate kind.
                        </p>
                    </dd>
                    <dt>RTCRtpFecParameters fec</dt>
                    <dd>
                        <p>Specifies the FEC mechanism if set.</p>
                    </dd>
                    <dt>RTCRtpRtxParameters rtx</dt>
                    <dd>
                        <p>Specifies the RTX [[!RFC4588]] parameters if set.</p>
                    </dd>
                    <dt>RTCPriorityType priority</dt>
                    <dd>
                        <p>
                            Indicates the priority of this encoding. It is specified in [[RTCWEB-TRANSPORT]], Section 4.
                            For scalable video coding, this parameter is only relevant for the base layer.
                            This parameter is ignored in an <code><a>RTCRtpReceiver</a></code> object.
                        </p>
                    </dd>
                    <dt>unsigned long maxBitrate</dt>
                    <dd>
                        <p>
                            Ramp up resolution/quality/framerate until this bitrate, if set.  maxBitrate is the
                            Transport Independent Application Specific (TIAS) maximum bandwidth defined in [[RFC3890]]
                            Section 6.2.2, which is the maximum bandwidth needed without counting IP or other transport
                            layers like TCP or UDP. Summed when using dependent layers. This parameter is ignored
                            in scalable video coding, or in an <code><a>RTCRtpReceiver</a></code> object.
                            If unset, there is no maximum bitrate.
                        </p>
                    </dd>
                    <dt>double resolutionScale</dt>
                    <dd>
                        <p>
                            If the sender's <code>kind</code> is "video", the video's resolution will be
                            scaled down in each dimension by the given value before sending. For example,
                            if the value is 2.0, the video will be scaled down by a factor of 2 in each
                            dimension, resulting in sending a video of one quarter size. If the value is
                            1.0 (the default), the video will not be affected.  A value less than 1.0
                            will result in a <code>RangeError</code> exception when <code>send()</code>
                            or <code>receive()</code> is called. For scalable video coding, <code>resolutionScale</code> 
                            refers to the aggregate scale down of this layer when combined with all dependent layers.
                        </p>
                    </dd>
                    <dt>double framerateScale</dt>
                    <dd>
                        <p>
                            Inverse of the input framerate fraction to be encoded. Example: 1.0 = full framerate,
                            2.0 = one half of the full framerate.
                            For scalable video coding, <code>framerateScale</code> refers to the inverse of the aggregate fraction of input framerate
                            achieved by this layer when combined with all dependent layers.
                        </p>
                    </dd>
                    <dt>unsigned long maxFramerate</dt>
                    <dd>
                        <p>
                            The maximum framerate to use for this encoding.  This setting is not used for scalable video coding.
                            If <code>framerateScale</code> is set, then <code>maxFramerate</code> is ignored.
                        </p>
                    </dd>
                    <dt>boolean active=true</dt>
                    <dd>
                        <p>
                            For an <code><a>RTCRtpSender</a></code>, indicates whether this encoding is actively being sent.
                            Setting it to <code>false</code> causes this encoding to no longer be sent.
                            Setting it to <code>true</code> causes this encoding to be sent. If unset, the default (<code>true</code>) is assumed.
                            For an <code><a>RTCRtpReceiver</a></code>, indicates that this encoding is being decoded.
                            Setting it to <code>false</code> causes this encoding to no longer be decoded.
                            Setting it to <code>true</code> causes this encoding to be decoded. If unset, the default (<code>true</code>) is assumed.
                            Setting <code>active</code> to <code>false</code> is different than omitting the encoding, since
                            it can keep resources available to re-activate more quickly than re-adding the encoding.
                            As noted in [[RFC3264]] Section 5.1, RTCP is still sent, regardless of the value of the <code>active</code> attribute.
                        </p>
                    </dd>
                    <dt>DOMString encodingId</dt>
                    <dd>
                        <p>
                            An identifier for the encoding object. This identifier should be unique within the scope of the
                            localized sequence of <code><a>RTCRtpEncodingParameters</a></code> for any given <code><a>RTCRtpParameters</a></code> object.
                            Values must be composed only of case-sensitive alphanumeric characters (a-z, A-Z, 0-9) up to a maximum of 16 characters.
                            For a codec (such as VP8) where a compliant decoder is required to be able to decode anything that an encoder can send,
                            it is not necessary to specify the expected scalable video coding configuration on the receiver via use of <var>encodingId</var>
                            (or <var>dependencyEncodingIds</var>). Where specified for a receiver, the expected layering is ignored. A sender MAY
                            send fewer layers than what is specified in <code><a>RTCRtpEncodingParameters</a></code>, but MUST NOT send more.
                            An <code><a>RTCRtpSender</a></code> places the value of <code>encodingId</code> into the <a>RID</a> header extension [[!RID]].
                        </p>
                    </dd>
                    <dt>sequence&lt;DOMString&gt; dependencyEncodingIds</dt>
                    <dd>
                        <p>
                            The <code><a>encodingId</a></code>s on which this layer depends.
                            Within this specification <code><a>encodingId</a></code>s are permitted only within the
                            same <code><a>RTCRtpEncodingParameters</a></code> sequence.
                            In the future if <a>MST</a> were to be supported, then if searching within an
                            <code><a>RTCRtpEncodingParameters</a></code> sequence did not produce a match, then a global search
                            would be carried out.
                        </p>
                    </dd>
                </dl>
                <p>
                    Usage of the attributes is defined in the table below:
                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Attribute</th>
                            <th>Type</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="def-ssrc*">
                           <td><dfn><code>ssrc</code></dfn></td>
                            <td>
                                <code>unsigned long</code>
                            </td>
                            <td>Receiver/Sender</td>
                        </tr>
                        <tr id="def-codecPayloadType*">
                           <td><dfn><code>codecPayloadType</code></dfn></td>
                            <td>
                                <code>payloadType</code>
                            </td>
                            <td>Receiver/Sender</td>
                        </tr>
                        <tr id="def-fec*">
                           <td><dfn><code>fec</code></dfn></td>
                            <td>
                                <code><a>RTCRtpFecParameters</a></code>
                            </td>
                            <td>Receiver/Sender</td>
                        </tr>
                        <tr id="def-rtx*">
                           <td><dfn><code>rtx</code></dfn></td>
                            <td>
                                <code><a>RTCRtpRtxParameters</a></code>
                            </td>
                            <td>Receiver/Sender</td>
                        </tr>
                        <tr id="def-priority*">
                           <td><dfn><code>priority</code></dfn></td>
                            <td>
                                <code><a>RTCPriorityType</a></code>
                            </td>
                            <td>Sender</td>
                        </tr>
                        <tr id="def-maxbitrate*">
                           <td><dfn><code>maxBitrate</code></dfn></td>
                            <td>
                                <code>unsigned long</code>
                            </td>
                            <td>Sender</td>
                        </tr>
                        <tr id="def-resolutionscale*">
                           <td><dfn><code>resolutionScale</code></dfn></td>
                            <td>
                                <code>double</code>
                            </td>
                            <td>Sender</td>
                        </tr>
                        <tr id="def-frameratescale*">
                           <td><dfn><code>framerateScale</code></dfn></td>
                            <td>
                                <code>double</code>
                            </td>
                            <td>Sender</td>
                        </tr>
                        <tr id="def-maxframerate*">
                           <td><dfn><code>maxFramerate</code></dfn></td>
                            <td>
                                <code>unsigned long</code>
                            </td>
                            <td>Sender</td>
                        </tr>
                        <tr id="def-active*">
                           <td><dfn><code>active</code></dfn></td>
                            <td>
                                <code>boolean</code>
                            </td>
                            <td>Receiver/Sender</td>
                        </tr>                        
                        <tr id="def-encodingid*">
                           <td><dfn><code>encodingId</code></dfn></td>
                            <td>
                                <code>DOMString</code>
                            </td>
                            <td>Receiver/Sender</td>
                        </tr>
                        <tr id="def-dependencyencodingids*">
                           <td><dfn><code>dependencyEncodingIds</code></dfn></td>
                            <td>
                                <code>sequence&lt;DOMString&gt;</code>
                            </td>
                            <td>Receiver/Sender</td>
                        </tr>
                    </tbody>
                </table>
            <section id="rtcrtpencodingparameters-example*">
                <h3>Examples</h3>
                <section id="rtcrtpencodingparameters-basicexample*">
                    <h4>Basic Example</h4>
                    <pre class="example highlight">
// Send a thumbnail along with regular size, prioritizing the thumbnail (ssrc: 2)
var encodings = [{ ssrc: 1, priority: 1.0 }];
var encodings = [{ ssrc: 2, priority: 10.0 }];

// Sign Language (prefer  framerate)
var encodings = [{ degradationPreference: "maintain-framerate" }];

// Screencast (prefer resolution)
var encodings = [{ degradationPreference: "maintain-resolution" }];

// Remote Desktop (High framerate, must not downscale)
var encodings = [{ degradationPreference: "maintain-framerate" }];

// Audio more important than video
var audioEncodings = [{ priority: 10.0 }];
var videoEncodings = [{ priority: 0.1 }];

// Video more important than audio
var audioEncodings = [{ priority: 0.1 }];
var videoEncodings = [{ priority: 10.0 }];

// Crank up the quality
var encodings = [{ maxBitrate: 10000000 }];

// Keep the bandwidth low
var encodings = [{ maxBitrate: 100000 }];
                    </pre>
                </section>
                <section id="rtcrtpencodingtemporal-example*">
                    <h4>Temporal Scalability</h4>
                    <pre class="example highlight">
// Example of 3-layer temporal scalability encoding
var encodings = [{
  // Base framerate is one quarter of the input framerate
  encodingId: "0",
  framerateScale: 4.0
}, {
  // Temporal enhancement (half the input framerate when combined with the base layer)
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  framerateScale: 2.0
}, {
  // Another temporal enhancement layer (full input framerate when all layers combined)
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"],
  framerateScale: 1.0
}];

// Example of 3-layer temporal scalability with all but the base layer disabled
var encodings = [{
  encodingId: "0",
  framerateScale: 4.0
}, {
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  framerateScale: 2.0,
  active: false
}, {
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"],
  framerateScale: 1.0,
  active: false
}];
</pre>
                    <p>
                        Below is a representation of a 3-layer temporal scalability encoding. In the diagram, I0 is the base layer I-frame,
                        and P0 represents base-layer P-frames. P1 represents the first temporal enhancement layer, and P2 represents the
                        second temporal enhancement layer.
                    </p>
                    <figure>
                       <img alt="3-layer temporal scalability encoding" src="images/3-layer-temporal.svg" style="width:75%" />
                       <figcaption>
                          3-layer temporal scalability encoding
                       </figcaption>
                    </figure>
                </section>
                <section id="rtcrtpencodingspatialsim-example*">
                    <h4>Spatial Simulcast</h4>
                    <pre class="example highlight">
// Example of 3-layer spatial simulcast
var encodings = [{
  // Simulcast layer at one quarter scale
  encodingId: "0",
  resolutionScale: 4.0
}, {
  // Simulcast layer at one half scale
  encodingId: "1",
  resolutionScale: 2.0
}, {
  // Simulcast layer at full scale
  encodingId: "2",
  resolutionScale: 1.0
}];

// Example of 3-layer spatial simulcast with all but the lowest resolution layer disabled
var encodings = [{
  encodingId: "0",
  resolutionScale: 4.0
}, {
  encodingId: "1",
  resolutionScale: 2.0,
  active: false
}, {
  encodingId: "2",
  resolutionScale: 1.0,
  active: false
}];

// Example of 2-layer spatial simulcast combined with 2-layer temporal scalability
var encodings = [{
  // Low resolution base layer (half the input framerate, half the input resolution)
  encodingId: "0",
  resolutionScale: 2.0,
  framerateScale: 2.0
}, {
  // High resolution Base layer (half the input framerate, full input resolution)
  encodingId: "E0",
  resolutionScale: 1.0,
  framerateScale: 2.0
}, {
  // Temporal enhancement to the low resolution base layer (full input framerate, half resolution)
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  resolutionScale: 2.0,
  framerateScale: 1.0
}, {
  // Temporal enhancement to the high resolution base layer (full input framerate and resolution)
  encodingId: "E1",
  dependencyEncodingIds: ["E0"],
  resolutionScale: 1.0,
  framerateScale: 1.0
}];
                    </pre>
                    <p>
                        Below is a representation of 2-layer temporal scalability combined with 2-layer spatial simulcast.
                        Solid arrows represent temporal prediction.
                        In the diagram, I0 is the base-layer I-frame, and P0 represents base-layer P-frames.
                        EI0 is an enhanced resolution base-layer I-frame, and EP0 represents P-frames within the enhanced resolution base layer.
                        P1 represents the first temporal enhancement layer, and EP1 represents a temporal enhancement to the
                        enhanced resolution simulcast base-layer.
                    </p>
                    <figure>
                       <img alt="2-layer spatial simulcast and temporal scalability encoding" src="images/2-layer-spatialsim-temporal.svg" style="width:75%" />
                       <figcaption>
                           2-layer spatial simulcast and temporal scalability encoding
                       </figcaption>
                    </figure>
                </section>
                <section id="rtcrtpencodingspatialscal-example*">
                    <h4>Spatial Scalability</h4>
                    <pre class="example highlight">
// Example of 3-layer spatial scalability encoding
var encodings = [{
  // Base layer with one quarter input resolution
  encodingId: "0",
  resolutionScale: 4.0
}, {
  // Spatial enhancement layer yielding half resolution when combined with the base layer
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  resolutionScale: 2.0
}, {
  // Additional spatial enhancement layer yielding full resolution when combined with all layers
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"],
  resolutionScale: 1.0
}]

// Example of 3-layer spatial scalability with all but the base layer disabled
var encodings = [{
  encodingId: "0",
  resolutionScale: 4.0
}, {
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  resolutionScale: 2.0,
  active: false
}, {
  encodingId: "2",
  dependencyEncodingIds: ["0", "1"],
  resolutionScale: 1.0,
  active: false
}];

// Example of 2-layer spatial scalability combined with 2-layer temporal scalability
var encodings = [{
  // Base layer (half input framerate, half resolution)
  encodingId: "0",
  resolutionScale: 2.0,
  framerateScale: 2.0
}, {
  // Temporal enhancement to the base layer (full input framerate, half resolution)
  encodingId: "1",
  dependencyEncodingIds: ["0"],
  resolutionScale: 2.0,
  framerateScale: 1.0
}, {
  // Spatial enhancement to the base layer (half input framerate, full resolution)
  encodingId: "E0",
  dependencyEncodingIds: ["0"],
  resolutionScale: 1.0,
  framerateScale: 2.0
}, {
  // Temporal enhancement to the spatial enhancement layer (full input framerate, full resolution)
  encodingId: "E1",
  dependencyEncodingIds: ["E0", "1"],
  resolutionScale: 1.0,
  framerateScale: 1.0
}];
                    </pre>
                    <p>
                        Below is a representation of 2-layer temporal scalability combined with 2-layer spatial scalability.
                        Solid arrows represent temporal prediction and dashed arrows represent inter-layer prediction.
                        In the diagram, I0 is the base-layer I-frame, and EI0 is an intra spatial enhancement.
                        P0 represents base-layer P-frames, and P1 represents the first temporal enhancement layer.
                        EP0 represents a resolution enhancement to the base-layer P frames, and EP1 represents a resolution enhancement to the
                        second temporal layer P-frames.
                    </p>
                    <figure>
                       <img alt="2-layer spatial and temporal scalability encoding" src="images/2-layer-spatial-temporal.svg" style="width:75%" />
                       <figcaption>
                          2-layer spatial and temporal scalability encoding
                       </figcaption>
                    </figure>
                </section>
              </section>
            </section>
            <section id="rtcprioritytype*">
                <h3>enum RTCPriorityType</h3>
                <p>
                    <dfn><code>RTCPriorityType</code></dfn> can be used to indicate the relative priority of various flows.
                    This allows applications to indicate to the browser whether a particular media flow is high, medium, low or of very
                    low importance to the application.
                    WebRTC uses the priority and Quality of Service (QoS) framework described in [[RTCWEB-TRANSPORT]] and [[!TSVWG-RTCWEB-QOS]] to
                    provide priority and DSCP marketing for packets that will help provide QoS in some networking environments.
                    Applications that use this API should be aware that often better overall user
                    experience is obtained by lowering the priority of things that are not as important rather
                    than raising the the priority of the things that are.
                </p>
                <dl class="idl" title="enum RTCPriorityType">
                    <dt>very-low</dt>
                    <dd>
                        <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
                    </dd>
                    <dt>low</dt>
                    <dd>
                        <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
                    </dd>
                    <dt>medium</dt>
                    <dd>
                        <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
                    </dd>
                    <dt>high</dt>
                    <dd>
                        <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpfecparameters*">
                <h3>dictionary RTCRtpFecParameters</h3>
                <dl title="dictionary RTCRtpFecParameters" class="idl">
                    <dt>unsigned long ssrc</dt>
                    <dd>
                        <p>
                            The SSRC to use for FEC.
                            If unset in an <code><a>RTCRtpSender</a></code> object, the browser will choose.
                        </p>
                    </dd>
                    <dt>DOMString mechanism</dt>
                    <dd>
                        <p>The Forward Error Correction (FEC) mechanism to use: "red", "red+ulpfec" or "flexfec".</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtprtxparameters*">
                <h3>dictionary RTCRtpRtxParameters</h3>
                <dl title="dictionary RTCRtpRtxParameters" class="idl">
                    <dt>unsigned long ssrc</dt>
                    <dd>
                        <p>
                            The SSRC to use for retransmission, as specified in [[!RFC4588]].
                            If unset when passed to <code>RTCRtpSender.send()</code>, the browser will choose.
                        </p>
                    </dd>
                </dl>
                <section id="rtcrtpfecparameters-example*">
                    <h3>RTX/RED/FEC</h3>
                    <p>
                        Below is an example of how to configure an <code><a>RTCRtpReceiver</a></code> to receive
                        video encoded in VP8 or VP9, along with retransmission and forward error correction.
                        In the example, forward error correction is encapsulated in RED, and it is possible to
                        retransmit RED packets.  The configuration enables VP8 or VP9 to be received either with
                        or without RED encapsulation.  The configuration of an <code><a>RTCRtpSender</a></code>
                        would be more prescriptive, at a given time indicating a single encoding: that VP8 or VP9
                        video should be sent encapsulated within RED or without RED encapsulation.
                    </p>
                    <pre class="example highlight">
// Example of RTX and RED + ulpfec
//
// SDP from createOffer() in WebRTC 1.0
//
//   m=video 62125 UDP/TLS/RTP/SAVPF 100 101 116 117 96
//   a=sendonly
//   a=rtpmap:100 VP8/90000
//   a=rtpmap:101 VP9/90000
//   a=rtpmap:116 red/90000
//   a=rtpmap:117 ulpfec/90000
//   a=rtpmap:96 rtx/90000
//   a=fmtp:96 apt=100
//   a=rtpmap:97 rtx/90000
//   a=fmtp:97 apt=101
//   a=rtpmap:98 rtx/90000
//   a=fmtp:98 apt=116
//   a=ssrc-group:FID 2224031971 3254585230
//   a=ssrc:2224031971 cname:oC/i06PA+Lda+t1P
//   a=ssrc:3254585230 cname:oC/i06PA+Lda+t1P
//
//   Define RTCRtpCodecParameters
//
var codecs = [
//   Define VP9 codec parameters
  {
    name: "vp9",
    payloadType: 101,
    clockRate: 90000
  },
//   Define VP8 codec parameters
  {
    name: "vp8",
    payloadType: 100,
    clockRate: 90000
  },
//   Define retransmission of VP9
  {
    name: "rtx",
    payloadType: 97,
    clockrate: 90000,
    parameters: {
      apt: 101
    }
  },
//   Define retransmission of VP8
  {
    name: "rtx",
    payloadType: 96,
    clockrate: 90000,
    parameters: {
      apt: 100
    }
  },
//   Define RED codec parameters
  {
    name: "red",
    payloadType: 116,
    clockRate: 90000,
    parameters: {
      payloadTypes: []
    }
  },
//   Define ulpfec codec parameters
  {
    name: "ulpfec",
    payloadType: 117,
    clockRate: 90000
  },
//   Define RTX codec parameters
  {
    name: "rtx",
    payloadType: 98,
    clockrate: 90000,
    parameters: {
      apt: 116
    }
  }
]; 
//
//   Define rtx parameters
var rtxParams = {
  ssrc: 3254585230
}; 
//   Define FEC parameters for "red+ulpfec"
var redulpfec = {
  ssrc: 3254585230,
  mechanism: "red+ulpfec"
}; 
//   Define RTCRtpEncodingParameters
//
var encodings = [
//   Define VP8 encoding parameters (without RED)
  {
    ssrc: 2224031971,
    codecPayloadType: 100,
    rtx: rtxParams
  },
//   Define VP8 encoding parameters with RED
  {
    ssrc:  2224031971,
    codecPayloadType: 100,
    fec: redulpfec,
    rtx: rtxParams
  },
//   Define VP9 encoding parameters (without RED)
  {
    ssrc:  2224031971,
    codecPayloadType: 101,
    rtx: rtxParams
  },
//   Define VP9 encoding parameters with RED
  {
    ssrc:  2224031971,
    codecPayloadType: 101,
    fec: redulplfec,
    rtx: rtxParams
  }
];  
                    </pre>
                </section>
            </section>
            <section id="rtcrtpheaderextension*">
                <h3>dictionary RTCRtpHeaderExtension</h3>
                <p>
                    The <code><a>RTCRtpHeaderExtension</a></code> dictionary enables a
                    header extension to be configured for use within an <code><a>RTCRtpSender</a></code>
                    or <code><a>RTCRtpReceiver</a></code>. In order to provide the equivalent of the
                    "direction" parameter defined in [[!RFC5285]] Section 5, an application can do
                    the following:
                    <ol>
                        <li>
                            sendonly: Include the header extension only when calling <code>send(<var>parameters</var>)</code>.
                        </li>
                        <li>
                            recvonly: Include the header extension only when calling <code>receive(<var>parameters</var>)</code>.
                        </li>
                        <li>
                            sendrecv: Include the header extension when calling <code>send(<var>parameters</var>)</code> and <code>receive(<var>parameters</var>)</code>.
                        </li>
                        <li>
                            inactive: Don't include the header extension when calling either <code>send(<var>parameters</var>)</code> or <code>receive(<var>parameters</var>)</code>.
                        </li>
                    </ol>
                </p>
                <dl class="idl" title="dictionary RTCRtpHeaderExtension">
                    <dt>DOMString kind</dt>
                    <dd>
                        <p>
                            The media supported by the header extension: "audio" for an audio codec,
                            "video" for a video codec, etc.
                        </p>
                    </dd>
                    <dt>DOMString uri</dt>
                    <dd>
                        <p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p>
                    </dd>
                    <dt>unsigned short preferredId</dt>
                    <dd>
                        <p>The preferred ID value that goes in the packet.</p>
                    </dd>
                    <dt>boolean preferredEncrypt=false</dt>
                    <dd>
                        <p>
                            If <code>true</code>, it is preferred that the value in the header be
                            encrypted as per [[!RFC6904]]. Default is to prefer unencrypted.
                        </p>
                    </dd>
                </dl>
            </section>
            <section id="rtcrtpheaderextensionparameters*">
                <h3>dictionary RTCRtpHeaderExtensionParameters</h3>
                <dl class="idl" title="dictionary RTCRtpHeaderExtensionParameters">
                    <dt>required DOMString uri</dt>
                    <dd>
                        <p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p>
                    </dd>
                    <dt>required unsigned short id</dt>
                    <dd>
                        <p>The value that goes in the packet.</p>
                    </dd>
                    <dt>boolean encrypt=false</dt>
                    <dd>
                        <p>If <code>true</code>, the value in the header is encrypted as per [[!RFC6904]]. Default is unencrypted.</p>
                    </dd>
                    <dt>Dictionary parameters</dt>
                    <dd>
                        <p>
                            Configuration parameters for the header extension.
                            An example is the "vad" extension attribute in the
                            client-to-mixer header extension, described in
                            [[!RFC6464]] Section 4.
                        </p>
                        <div class="note">
                            At the time of publication there were no implementations of the
                            <code>parameters</code> dictionary. Most header extensions
                            do not require configuration parameters, and the ORTC Lib
                            implementation assumes that the "V" bit from [[!RFC6464]]
                            is always enabled so that a <code>vad</code> parameter is
                            unnecessary. The need for a <code>parameters</code> dictionary
                            is therefore unclear.
                        </div>
                    </dd>
                </dl>
            </section>
            <section id="headerextensions*">
                <h3>RTP header extensions</h3>
                <p>Registered RTP header extensions are listed in [[!IANA-RTP-10]]. Header extensions mentioned in [[!RTP-USAGE]] and [[!RID]] include:
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Header Extension</th>
                            <th>Reference</th>
                            <th>Attributes</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="def-transmission-time-offset*">
                            <td><dfn>Transmission Time Offset</dfn></td>
                            <td>
                                [[RFC5450]]
                            </td>
                            <td>None</td>
                            <td>
                                This extension indicates the transmission time offset.
                            </td>
                        </tr>
                        <tr id="def-rapid-sync*">
                            <td><dfn>Rapid Synchronization</dfn></td>
                            <td>
                                [[RFC6051]]
                            </td>
                            <td>None</td>
                            <td>
                                This extension enables carriage of an NTP-format timestamp, as defined in [[!RFC6051]] Section 3.3.
                            </td>
                        </tr>
                        <tr id="def-client-to-mixer*">
                            <td><dfn>Client-to-Mixer Audio Level</dfn></td>
                            <td>
                                [[!RFC6464]]
                            </td>
                            <td>boolean vad</td>
                            <td>
                                This extension indicates the audio level of the audio sample carried in an RTP packet.
                                For an <code><a>RTCRtpSender</a></code>, the <code>vad</code> attribute indicates whether the V bit is in use (<code>true</code>) or not (<code>false</code>).
                                For an <code><a>RTCRtpReceiver</a></code>, the <code>vad</code> attribute indicates whether the V bit is provided to the 
                                application (<code>true</code>) in <code>RTCRtpContributingSource.voiceActivityFlag</code> or is unset (<code>false</code>). 
                            </td>
                        </tr>
                        <tr id="def-mixer-to-client*">
                            <td><dfn>Mixer-to-Client Audio Level</dfn></td>
                            <td>
                                [[RFC6465]]
                            </td>
                            <td>None</td>
                            <td>
                                This extension indicates the audio level of individual conference participants.
                            </td>
                        </tr>
                        <tr id="def-abs-send-time*">
                            <td><dfn>Absolute Send Time</dfn></td>
                            <td>
                                [[ABS-SEND-TIME]]
                            </td>
                            <td>None</td>
                            <td>
                                This extension indicates the absolute send time.
                            </td>
                        </tr>
                        <tr id="def-cvo*">
                            <td><dfn>CVO</dfn></td>
                            <td>
                                [[!TS26.114]] Section 7.4.5
                            </td>
                            <td>None</td>
                            <td>
                                The Coordination of Video Orientation (CVO) extension indicates whether
                                the receiver needs to change the orientation in which it renders the stream.
                            </td>
                        </tr>
                        <tr id="def-mid*">
                            <td><dfn>MID</dfn></td>
                            <td>
                                [[!BUNDLE]]
                            </td>
                            <td>None</td>
                            <td>
                                This extension defines a track identifier which can be used to identify the track corresponding to an RTP stream.
                            </td>
                        </tr>
                        <tr id="def-rid*">
                            <td><dfn>RID</dfn></td>
                            <td>
                                [[!RID]]
                            </td>
                            <td>None</td>
                            <td>
                                This extension defines an identifier used to carry the <code>encodingId</code>.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </section>
        <section id="rtcdtmfsender*">
            <h2>The RTCDtmfSender Object</h2>
            <section id="rtcdtmfsender-overview*">
                <h3>Overview</h3>
                <p>An <dfn>RTCDtmfSender</dfn> instance allows sending DTMF tones to/from the remote peer, as per [[!RFC4733]].</p>
            </section>
            <section id="rtcdtmfsender-operation*">
                <h3>Operation</h3>
                <p>
                    An <a>RTCDtmfSender</a> object is constructed from an <code><a>RTCRtpSender</a></code> <var>sender</var>.
                    If <code>sender.track.kind</code> is not "audio", throw an <code>InvalidParameters</code> exception.
                </p>
            </section>
            <section id="rtcdtmfsender-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCDtmfSender">
                    <dt>Constructor(RTCRtpSender sender)</dt>
                    <dd></dd>
                    <dt>readonly attribute boolean <a>canInsertDTMF</a></dt>
                    <dd>
                        <p>Whether the <a>RTCDtmfSender</a> is capable of sending DTMF.</p>
                    </dd>
                    <dt>
                        void insertDTMF(in DOMString tones, optional long duration, long
                        interToneGap)
                    </dt>
                    <dd>
                        <p>
                            The <code>insertDTMF()</code> method is used to send DTMF tones.
                            Since DTMF tones cannot be sent without configuring the DTMF codec,
                            if <code>insertDTMF()</code> is called prior to
                            <code>sender.send(<var>parameters</var>)</code>, or if
                            <code>sender.send(<var>parameters</var>)</code> was called with
                            <code>parameters.codecs[]</code> not including the 
                            "telephone-event" codec, throw an <code>InvalidStateError</code> exception.
                        </p>
                        <p>
                            The tones parameter is treated as a series of characters. The
                            characters 0 through 9, A through D, #, and * generate the associated
                            DTMF tones. The characters a to d are equivalent to A to D. The
                            character ',' indicates a delay of 2 seconds before processing the
                            next character in the tones parameter. All other characters <em title="MUST" class="rfc2119">MUST</em> be
                            considered <dfn id="dtmf-unrecognized">unrecognized</dfn>.
                            As noted in [[!RFC7874]] Section 3, support for the characters
                            0 through 9, A through D, #, and * are required.
                        </p>
                        <p>
                            The duration parameter indicates the duration in ms to use for
                            each character passed in the tones parameters. The duration cannot be
                            more than 6000 ms or less than 40 ms. The default duration is 100 ms
                            for each tone.
                        </p>
                        <p>
                            The interToneGap parameter indicates the gap between tones. It
                            <em title="MUST" class="rfc2119">MUST</em> be at least 30 ms. The default value is 70 ms.
                        </p>
                        <p>
                            The browser <em title="MAY" class="rfc2119">MAY</em> increase the duration and interToneGap times to
                            cause the times that DTMF start and stop to align with the boundaries
                            of RTP packets but it <em title="MUST" class="rfc2119">MUST</em> not increase either of them by more than
                            the duration of a single RTP audio packet.
                        </p>
                        <p>
                            When the <code><a class="internalDFN" href="#dom-RTCDTMFSender-insertDTMF"><code>insertDTMF()</code></a></code> method is invoked, the
                            user agent <em title="MUST" class="rfc2119">MUST</em> run the following steps:
                        </p>
                        <ol>
                            <li>
                                Set the object's <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> attribute to
                                the value of the first argument, the <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> attribute to the
                                value of the second argument, and the <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> attribute
                                to the value of the third argument.
                            </li>
                            <li>
                                If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> contains any
                                <a href="#dtmf-unrecognized">unrecognized</a> characters, throw an
                                <code>InvalidCharacterError</code> exception and abort these steps.
                            </li>
                            <li>
                                If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> is an empty
                                string, return.
                            </li>
                            <li>
                                If the value of the <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> attribute is less
                                than 40, set it to 40. If, on the other hand, the value is greater
                                than 6000, set it to 6000.
                            </li>
                            <li>
                                If the value of the <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> attribute
                                is less than 30, set it to 30.
                            </li>
                            <li>
                                If a <em>Playout task</em> is scheduled to be run; abort these
                                steps; otherwise queue a task that runs the following steps
                                (<em>Playout task</em>):
                                <ol>
                                    <li>
                                        If <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> is an
                                        empty string, fire an event named <code><a href="#event-RTCDTMFSender-tonechange">tonechange</a></code> with an
                                        empty string at the <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDtmfSender</code></a></code> object
                                        and abort these steps.
                                    </li>
                                    <li>
                                        Remove the first character from <code><a href="#dom-RTCDTMFSender-tonebuffer">toneBuffer</a></code> and let
                                        that character be <var>tone</var>.
                                    </li>
                                    <li>
                                        Start playout of <var>tone</var> for <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> ms on the
                                        associated RTP media stream, using the appropriate codec.
                                    </li>
                                    <li>
                                        Queue a task to be executed in <code><a href="#dom-RTCDTMFSender-duration">duration</a></code> +
                                        <code><a href="#dom-RTCDTMFSender-intertonegap">interToneGap</a></code> ms
                                        from now that runs the steps labelled <em>Playout task</em>.
                                    </li>
                                    <li>
                                        Fire an event named <code><a href="#event-RTCDTMFSender-tonechange">tonechange</a></code> with a
                                        string consisting of <var>tone</var> at the
                                        <code><a class="idlType" href="#idl-def-RTCDTMFSender"><code>RTCDtmfSender</code></a></code> object.
                                    </li>
                                </ol>
                            </li>
                        </ol>
                        <p>
                            Calling <code><a href="#dom-RTCDTMFSender-insertDTMF">insertDTMF()</a></code> with an empty
                            tones parameter can be used to cancel all tones queued to play after
                            the currently playing tone.
                        </p>
                    </dd>
                    <dt>readonly attribute <a>RTCRtpSender</a> sender</dt>
                    <dd>
                        <p>The <a>RTCRtpSender</a> instance</p>
                    </dd>
                    <dt>attribute EventHandler ontonechange</dt>
                    <dd>
                        <p>
                            The <dfn>ontonechange</dfn> event handler uses the
                            <a>RTCDTMFToneChangeEvent</a> interface to return the
                            character for each tone as it is played out.
                        </p>
                    </dd>
                    <dt>readonly attribute DOMString toneBuffer</dt>
                    <dd>
                        <p>
                            The <dfn>toneBuffer</dfn> attribute returns a list of the
                            tones remaining to be played out.
                        </p>
                    </dd>
                    <dt>readonly attribute long duration</dt>
                    <dd>
                        <p>
                            The <dfn>duration</dfn> attribute returns the current tone duration
                            value in milliseconds. This value will be the value last set via the
                            <code>insertDTMF()</code> method, or the default value of 100 ms if
                            <code>insertDTMF()</code> was called without specifying the duration.
                        </p>
                    </dd>
                    <dt>readonly attribute long interToneGap</dt>
                    <dd>
                        <p>
                            The <dfn>interToneGap</dfn> attribute returns the current value of
                            the between-tone gap. This value will be the value last set via the
                            <code>insertDTMF()</code> method, or the default value of 70
                            ms if <code>insertDTMF()</code> was called without specifying
                            the <code>interToneGap.</code>
                        </p>
                    </dd>
                </dl>
            </section>
            <section>
                <h3>RTCDTMFToneChangeEvent</h3>
                <p>
                    The tonechange event uses the
                    <a>RTCDTMFToneChangeEvent</a> interface.
                </p>
                <p>
                    Firing a tonechange event named
                    <var>e</var> with a DOMString <var>tone</var> means
                    that an event with the name <var>e</var>, which does not bubble (except
                    where otherwise stated) and is not cancelable (except where otherwise
                    stated), and which uses the <a>RTCDTMFToneChangeEvent</a>
                    interface with the <a>tone</a>
                    attribute set to
                    <var>tone</var>, MUST be created and dispatched at the given target.
                </p>
                <dl class="idl" data-merge="RTCDTMFToneChangeEventInit"
                    title="interface RTCDTMFToneChangeEvent : Event">
                    <dt>Constructor(DOMString type, RTCDTMFToneChangeEventInit eventInitDict)</dt>
                    <dd></dd>
                    <dt>readonly attribute DOMString tone</dt>
                    <dd>
                        <p>
                            The <dfn>tone</dfn>
                            attribute contains the character for the tone that has just begun
                            playout (see <code>insertDTMF()</code>). If the value is the
                            empty string, it indicates that the previous tone has completed
                            playback.
                        </p>
                    </dd>
                </dl>
                <dl class="idl" title="dictionary RTCDTMFToneChangeEventInit : EventInit">
                    <dt>DOMString tone=""</dt>
                    <dd>
                        <p>
                            The <a>tone</a> parameter is treated as a series of characters.
                            The characters 0 through 9, A through D, #, and * generate the associated DTMF tones.
                            The characters a to d are equivalent to A to D.
                            The character ',' indicates a delay of 2 seconds before processing the next character in the tones parameter.
                            Unrecognized characters are ignored.
                        </p>
                    </dd>
                </dl>
            </section>
            <section>
                <h3>DTMF Example</h3>
                <p>Examples assume that <var>sendObject</var> is an <code><a>RTCRtpSender</a></code> object.</p>
                <p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>
                <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
  var duration = 500;
  sender.insertDTMF("1234", duration);
} else {
  trace("DTMF function not available");
}
                </pre>
                <p>
                    Send the DTMF signal "1234", and light up the active key using
                    <code>lightKey(key)</code> while the tone is playing (assuming that
                    <code>lightKey("")</code> will darken all the keys):
                </p>
                <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function(e) {
  if (!e.tone) return;

  // light up the key when playout starts
  lightKey(e.tone);

  // turn off the light after tone duration
  setTimeout(lightKey, sender.duration, "");
};
sender.insertDTMF("1234");
                </pre>
                <p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>
                <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function(e) {
  if (e.tone === "1") sender.insertDTMF("2", 2000);
};
sender.insertDTMF("1", 1000);
                </pre>
                <p>It is always safe to append to the tone buffer. This example appends
                    before any tone playout has started as well as during playout.
                </p>
                <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
sender.insertDTMF("123");

// append more tones to the tone buffer before playout has begun
sender.insertDTMF(sender.toneBuffer + "456");

sender.ontonechange = function(e) {
  if (e.tone === "1") {
    // append more tones when playout has begun
    sender.insertDTMF(sender.toneBuffer + "789");
  }
};
                </pre>
                <p>Send the DTMF signal "123" and abort after sending "2".</p>
                <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
sender.ontonechange = function(e) {
  if (e.tone === "2") {
    // empty the buffer to not play any tone after "2"
    sender.insertDTMF("");
  }
};
sender.insertDTMF("123");
                </pre>
            </section>
        </section>
        <section id="rtcdatachannel*">
            <h2>The RTCDataChannel Object</h2>
            <section id="rtcdatachannel-overview*">
                <h3>Overview</h3>
                <p>
                    An <dfn><code>RTCDataChannel</code></dfn> class instance allows sending data messages to/from the remote peer.
                </p>
            </section>
            <section id="rtcdatachannel-operation*">
                <h3>Operation</h3>
                <p>
                    An <code><a>RTCDataChannel</a></code> object is constructed from a <code><a>RTCDataTransport</a></code> object and
                    an <code><a>RTCDataChannelParameters</a></code> object. If <var>parameters</var> is invalid, throw an
                    <code>InvalidParameters</code> exception. If <code>transport.state</code> is <code>closed</code>, throw an
                    <code>InvalidState</code> exception.
                </p>
                <p>
                    An <code><a>RTCDataChannel</a></code> object can be garbage-collected once <var>readyState</var> 
                    is <code>closed</code> and it is no longer referenced.
                </p>
            </section>
            <section id="rtcdatachannel-interface-definition*">
                <h3>Interface Definition</h3>
                <p>
                    The <code><a>RTCDataChannel</a></code> interface represents a bi-directional data channel between two peers.
                    There are two ways to establish a connection with <code><a>RTCDataChannel</a></code>.
                    The first way is to construct an <code><a>RTCDataChannel</a></code> at one of the peers with the
                    <code><a>RTCDataChannelParameters</a></code>.<a>negotiated</a> attribute unset or set to its default value false.
                    This will announce the new channel in-band and trigger an <a>ondatachannel</a> event with the
                    corresponding <code><a>RTCDataChannel</a></code> object at the other peer.
                    The second way is to let the application negotiate the <code><a>RTCDataChannel</a></code>.
                    To do this, create an <code><a>RTCDataChannel</a></code> object with the <code><a>RTCDataChannelParameters</a></code>.<a>negotiated</a>
                    dictionary member set to true, and signal out-of-band (e.g. via a web server) to the other
                    side that it should create a corresponding <code><a>RTCDataChannel</a></code> with the
                    <code><a>RTCDataChannelParameters</a></code>.<a>negotiated</a> dictionary member set to true and the same <var>id</var>.
                    This will connect the two separately created <code><a>RTCDataChannel</a></code> objects.
                    The second way makes it possible to create channels with asymmetric properties and to
                    create channels in a declarative way by specifying matching <var>id</var>s.
                    Each <code><a>RTCDataChannel</a></code> has an associated <dfn>underlying data transport</dfn> that is used
                    to transport actual data to the other peer.
                    The transport properties of the underlying data transport, such as in order delivery
                    settings and reliability mode, are configured by the peer as the channel is created.
                    The properties of a channel cannot change after the channel has been created.
                </p>
                <dl class="idl" title="interface RTCDataChannel : EventTarget">
                    <dt>Constructor(RTCDataTransport transport, RTCDataChannelParameters parameters)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCDataTransport transport</dt>
                    <dd>
                        <p>The readonly attribute referring to the related transport object.</p>
                    </dd>
                    <dt>readonly attribute RTCDataChannelState readyState</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-readystate"><code>readyState</code></dfn> attribute represents the state of the <a>RTCDataChannel</a> object.
                            It <em class="rfc2119" title="MUST">MUST</em> return the value to which the user agent last set it (as defined by the processing model algorithms).
                        </p>
                    </dd>
                    <dt>readonly attribute unsigned long bufferedAmount</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-bufferedamount"><code>bufferedAmount</code></dfn> attribute
                            <em class="rfc2119" title="MUST">MUST</em> return the number of bytes of application data
                            (UTF-8 text and binary data) that have been queued using send() but that, as of the last time
                            the event loop started executing a task, had not yet been transmitted to the network.
                            This includes any text sent during the execution of the current task, regardless of whether the
                            user agent is able to transmit text asynchronously with script execution.
                            This does not include framing overhead incurred by the protocol, or buffering done by the
                            operating system or network hardware.
                            If the channel is closed, this attribute's value will only increase with each call to the
                            send() method (the attribute does not reset to zero once the channel closes).
                        </p>
                    </dd>
                    <dt>attribute unsigned long bufferedAmountLowThreshold</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-bufferedamountlowthreshold">
                            <code>bufferedAmountLowThreshold</code></dfn> attribute sets the
                            threshold at which the <code><a href=
                            "#dom-datachannel-bufferedamount">bufferedAmount</a></code> is
                            considered to be low.  When the <code><a href=
                            "#dom-datachannel-bufferedamount">bufferedAmount</a></code>
                            decreases from above this threshold to equal or below it, the
                            <code title="event-RTCDataChannel-bufferedamountlow"><a href=
                            "#event-datachannel-bufferedamountlow">bufferedamountlow</a></code>
                            event fires. The
                            <code><a href="#dom-datachannel-bufferedamountlowthreshold">
                            bufferedAmountLowThreshold</a></code> is
                            initially zero on each new <code><a>RTCDataChannel</a></code>, but
                            the application may change its value at any time.
                        </p>
                    </dd>
                    <dt>attribute DOMString binaryType</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-binarytype"><code>binaryType</code></dfn> attribute
                            <em class="rfc2119" title="MUST">MUST</em>, on getting, return the value to which it was last set.
                            On setting, the user agent <em class="rfc2119" title="MUST">MUST</em> set the IDL attribute to the new value.
                            When an <a>RTCDataChannel</a> object is constructed, the <code>binaryType</code> attribute
                            <em class="rfc2119" title="MUST">MUST</em> be initialized to the string 'blob'.
                            This attribute controls how binary data is exposed to scripts.
                            See the [[WEBSOCKETS-API]] for more information.
                        </p>
                    </dd>
                    <dt>RTCDataChannelParameters getParameters()</dt>
                    <dd>
                        <p>Returns the parameters applying to this data channel.</p>
                    </dd>
                    <dt>void close()</dt>
                    <dd>
                        <p>
                            Closes the <a>RTCDataChannel</a>.
                            It may be called regardless of whether the <a>RTCDataChannel</a> object was created by this peer or the remote peer.
                            When the <code>close()</code> method is called, the user agent
                            <em class="rfc2119" title="MUST">MUST</em> run the following steps:
                        </p>
                        <p>1. Let channel be the <a>RTCDataChannel</a> object which is about to be closed.</p>
                        <p>2. If channel's <code>readyState</code> is closing or closed, then abort these steps.</p>
                        <p>3. Set channel's <code>readyState</code> attribute to closing.</p>
                        <p>4. If the closing procedure has not started yet, start it.</p>
                    </dd>
                    <dt>attribute EventHandler onopen</dt>
                    <dd>
                        <p>
                            This event handler, of event handler type <code>open</code>,
                            <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the RTCDataChannel interface.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onbufferedamountlow</dt>
                    <dd>
                        <p>
                            The event type of this event handler is <code><a href=
                            "#event-datachannel-bufferedamountlow">bufferedamountlow</a></code>.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onerror</dt>
                    <dd>
                        <p>
                            This event handler, of event handler type <code>error</code>,
                            <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the RTCDataChannel interface.
                            One reason an <code>error</code> event can be fired is if the value of <var>parameters</var> passed in the constructor is
                            subsequently determined to be invalid. This can happen if
                            <code>parameters.negotiated</code> is set to false and then a call to <code>RTCDtlsTransport.start()</code> causes the
                            DTLS role to be set to a value inconsistent with the value of <code>parameters.id</code>, as noted in
                            [[!DATA-PROT]] Section 4.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onclose</dt>
                    <dd>
                        <p>
                            This event handler, of event handler type <code>close</code>,
                            <em class="rfc2119" title="MUST">MUST</em> be supported by all objects implementing the RTCDataChannel interface.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onmessage</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code>message</code>,
                            <em class="rfc2119" title="MUST">MUST</em> be fired to
                            allow a developer's JavaScript to receive data from a remote peer.
                        </p>
                        <table border="1">
                            <tr>
                                <td><em>Event Argument</em></td>
                                <td><em>Description</em></td>
                            </tr>
                            <tr>
                                <td>Object data</td>
                                <td>The received remote data.</td>
                            </tr>
                        </table>
                    </dd>
                    <dt>void send (USVString data)</dt>
                    <dd>
                        <p>Run the steps described by the <code>send()</code> algorithm with argument type <code>string</code> object.</p>
                    </dd>
                    <dt>void send (Blob data)</dt>
                    <dd>
                        <p>Run the steps described by the <code>send()</code> algorithm with argument type <code>Blob</code> object.</p>
                    </dd>
                    <dt>void send (ArrayBuffer data)</dt>
                    <dd>
                        <p>Run the steps described by the <code>send()</code> algorithm with argument type <code>ArrayBuffer</code> object.</p>
                    </dd>
                    <dt>void send (ArrayBufferView data)</dt>
                    <dd>
                        <p>Run the steps described by the <code>send()</code> algorithm with argument type <code>ArrayBufferView</code> object.</p>
                    </dd>
                </dl>
                <p>
                    The <dfn><code>send()</code></dfn> method is
                    overloaded to handle different data argument types. When any version of
                    the method is called, the user agent MUST run the following steps:
                </p>
                <ol>
                    <li>
                        <p>
                            Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
                            object on which data is to be sent.
                        </p>
                    </li>
                    <li>
                        <p>
                            If <code>readyState</code> attribute
                            is <code>connecting</code>, throw an <code>InvalidStateError</code>
                            exception and abort these steps.
                        </p>
                    </li>
                    <li>
                        <p>
                            Execute the sub step that corresponds to the type of the methods
                            argument:
                        </p>
                        <ul>
                            <li>
                                <p><code>string</code> object:</p>
                                <p>
                                    Let <var>data</var> be the object and increase the
                                    <code><a href="#dom-datachannel-bufferedamount">bufferedAmount</a></code>
                                    attribute by the number of bytes needed to express
                                    <var>data</var> as UTF-8.
                                </p>
                            </li>
                            <li>
                                <p><code>Blob</code> object:</p>
                                <p>
                                    Let <var>data</var> be the raw data represented by the
                                    <code>Blob</code> object and increase the
                                    <code><a href="#dom-datachannel-bufferedamount">bufferedAmount</a></code>
                                    attribute by the size of data, in bytes.
                                </p>
                            </li>
                            <li>
                                <p><code>ArrayBuffer</code> object:</p>
                                <p>
                                    Let <var>data</var> be the data stored in the buffer described
                                    by the <code>ArrayBuffer</code> object and increase the <code>
                                    <a href="#dom-datachannel-bufferedamount">bufferedAmount</a>
                                    </code> attribute by the length of the <code>ArrayBuffer</code>
                                    in bytes.
                                </p>
                            </li>
                            <li>
                                <p><code>ArrayBufferView</code> object:</p>
                                <p>
                                    Let <var>data</var> be the data stored in the section of the
                                    buffer described by the <code>ArrayBuffer</code> object that the
                                    <code>ArrayBufferView</code> object references and increase the
                                    <code><a href="#dom-datachannel-bufferedamount">bufferedAmount</a>
                                    </code> attribute by the length of the
                                    <code>ArrayBufferView</code> in bytes.
                                </p>
                            </li>
                        </ul>
                    <li>
                        <p>
                            If <code>channel</code>'s underlying data transport is not
                            established yet, or if the closing procedure has
                            started, then abort these steps.
                        </p>
                    </li>
                    <li>
                        <p>
                            Attempt to send <var>data</var> on <code>channel</code>'s
                            underlying data transport; if the data cannot be sent, e.g.
                            because it would need to be buffered but the buffer is full, the user
                            agent MUST abruptly close
                            <code>channel</code>'s underlying data transport with an error.
                        </p>
                    </li>
                </ol>
            </section>
            <section id="rtcdatatransport-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCDataTransport : RTCStatsProvider"></dl>
            </section>
            <section id="rtcdatachannelstate*">
                <h3>enum RTCDataChannelState</h3>
                <dl class="idl" title="enum RTCDataChannelState">
                    <dt>connecting</dt>
                    <dd>
                        <p>
                            The user agent is attempting to establish the underlying data transport.
                            This is the initial state of an <code><a>RTCDataChannel</a></code> object.
                        </p>
                    </dd>
                    <dt>open</dt>
                    <dd>
                        <p>
                            The underlying data transport is established and communication is possible.
                            This is the initial state of an <code><a>RTCDataChannel</a></code> object dispatched as a
                            part of an <code>RTCDataChannelEvent</code>.
                        </p>
                    </dd>
                    <dt>closing</dt>
                    <dd>
                        <p>The procedure to close down the underlying data transport has started.</p>
                    </dd>
                    <dt>closed</dt>
                    <dd>
                        <p>The underlying data transport has been closed or could not be established.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcdatachannelparameters*">
                <h3>dictionary RTCDataChannelParameters</h3>
                <p>
                    An <code><a>RTCDataChannel</a></code> can be configured to operate in different reliability modes.
                    A reliable channel ensures that the data is delivered at the other peer through retransmissions.
                    An unreliable channel is configured to either limit the number of retransmissions (maxRetransmits ) or set
                    a time during which transmissions (including retransmissions) are allowed (maxPacketLifeTime).
                    These properties can not be used simultaneously and an attempt to do so will result in an error.
                    Not setting any of these properties results in a reliable channel.
                </p>
                <dl class="idl" title="dictionary RTCDataChannelParameters">
                    <dt>USVString label=""</dt>
                    <dd>
                        <p>
                            The <dfn><code>label</code></dfn> attribute represents a label that can be used to distinguish this <code><a>RTCDataChannel</a></code> object from other <a>RTCDataChannel</a> objects.
                            The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the <code><a>RTCDataChannel</a></code> object was constructed.
                            For an SCTP data channel, the label is carried in the DATA_CHANNEL_OPEN message defined in
                            [[!DATA-PROT]] Section 5.1.
                        </p>
                    </dd>
                    <dt>boolean ordered=true</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-ordered"><code>ordered</code></dfn>
                            attribute returns <code>true</code> if the <code><a>RTCDataChannel</a></code> is ordered, and
                            <code>false</code> if out of order delivery is allowed. Default is <code>true</code>.
                            The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the
                            <a>RTCDataChannel</a> was constructed.
                        </p>
                    </dd>
                    <dt>unsigned long maxPacketLifetime</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-maxpacketlifetime"><code>maxPacketLifetime</code></dfn>
                            attribute represents the length of the time window (in milliseconds) during which
                            retransmissions may occur in unreliable mode.
                            The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the
                            <a>RTCDataChannel</a> was constructed.
                        </p>
                    </dd>
                    <dt>unsigned long maxRetransmits</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-maxretransmits"><code>maxRetransmits</code></dfn>
                            attribute returns the maximum number of
                            retransmissions that are attempted in unreliable mode.
                            The attribute <em class="rfc2119" title="MUST">MUST</em> be initialized to null by default and
                            <em class="rfc2119" title="MUST">MUST</em> return the
                            value to which it was set when the <a>RTCDataChannel</a> was constructed.
                        </p>
                    </dd>
                    <dt>USVString protocol=""</dt>
                    <dd>
                        <p>
                            The name of the sub-protocol used with this <code><a>RTCDataChannel</a></code>if any,
                            or the empty string otherwise (in which case the protocol is unspecified).
                            The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the
                            <code><a>RTCDataChannel</a></code> was constucted. Sub-protocols are registered in the
                            'Websocket Subprotocol Name Registry' created in [[RFC6455]] Section 11.5.
                        </p>
                    </dd>
                    <dt>boolean negotiated=false</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannel-negotiated"><code>negotiated</code></dfn>
                            attribute returns true if this <code><a>RTCDataChannel</a></code>
                            was negotiated by the application, or false otherwise. The attribute <em class="rfc2119" title="MUST">MUST</em>
                            be initialized to <code>false</code> by default and <em class="rfc2119" title="MUST">MUST</em> return the value to which it
                            was set when the <code><a>RTCDataChannel</a></code> was constructed.
                            If set to true, the application developer <em class="rfc2119" title="MUST">MUST</em> signal to the remote peer to
                            construct an <code><a>RTCDataChannel</a></code> object with the same id for the data channel
                            to be open. As noted in [[!DATA-PROT]], DATA_CHANNEL_OPEN is not sent to the remote peer nor is DATA_CHANNEL_ACK expected in return.
                            If set to false, the remote party will receive an ondatachannel event with
                            a system constructed <code><a>RTCDataChannel</a></code> object.
                        </p>
                    </dd>
                    <dt>unsigned short id</dt>
                    <dd>
                        <p>
                            The id attribute returns the id for this <code><a>RTCDataChannel</a></code>.
                            The id was either assigned by the user agent at channel creation time or was selected by the script.
                            For SCTP, the id represents a stream identifier, as discussed in [[!DATA]] Section 6.5.
                            The attribute <em class="rfc2119" title="MUST">MUST</em> return the value to which it was set when the
                            <code><a>RTCDataChannel</a></code> was constructed.
                        </p>
                    </dd>
                </dl>
            </section>
        </section>
        <section id="sctp-transport*">
            <h2>The RTCSctpTransport Object</h2>
            <p>
                The <dfn><code>RTCSctpTransport</code></dfn> includes information relating to Stream Control Transmission Protocol (SCTP) transport.
            </p>
            <section id="sctp-transport-overview*">
                <h3>Overview</h3>
                <p>An <a>RTCSctpTransport</a> inherits from an <a>RTCDataTransport</a> object, which is associated to an <a>RTCDataChannel</a> object.</p>
            </section>
            <section id="sctptransport-operation*">
                <h3>Operation</h3>
                <p>
                    An <code><a>RTCSctpTransport</a></code> is constructed from an <code><a>RTCDtlsTransport</a></code> object,
                    and optionally a port number (with a default of 5000,
                    or the next unused port). If a port already in use is provided in the constructor, throw an <code>InvalidParameters</code> exception.
                    Creation of an <code><a>RTCSctpTransport</a></code> causes an SCTP INIT request to be issued over the <code><a>RTCDtlsTransport</a></code>
                    from the local <code><a>RTCSctpTransport</a></code> to the remote <code><a>RTCSctpTransport</a></code> where the remote <code><a>RTCSctpTransport</a></code>
                    responds with an SCTP INIT-ACK. Since both local and remote parties must mutually create an <code><a>RTCSctpTransport</a></code>,
                    SCTP SO (Simultaneous Open) is used to establish a connection over SCTP.
                </p>
                <p>
                    An <code><a>RTCSctpTransport</a></code> object can be garbage-collected once <code>stop()</code> is called
                    and it is no longer referenced.
                </p>
            </section>
            <section id="sctptransport-interface-definition*">
                <h3>Interface Definition</h3>
                <dl class="idl" title="interface RTCSctpTransport : RTCDataTransport">
                    <dt>Constructor(RTCDtlsTransport transport, optional unsigned short port)</dt>
                    <dd></dd>
                    <dt>readonly attribute <a>RTCDtlsTransport</a> transport</dt>
                    <dd>
                        <p>The <a>RTCDtlsTransport</a> instance the <a>RTCSctpTransport</a> object is sending over.</p>
                    </dd>
                    <dt>readonly attribute RTCSctpTransportState state</dt>
                    <dd>
                        <p>The current state of the SCTP transport.</p>
                    </dd>
                    <dt>readonly attribute unsigned short port</dt>
                    <dd>
                        <p>The SCTP port number used by the data channel.</p>
                    </dd>
                    <dt>static <a>RTCSctpCapabilities</a> getCapabilities()</dt>
                    <dd>
                        <p>Retrieves the <a>RTCSctpCapabilities</a> of the <a>RTCSctpTransport</a> instance.</p>
                    </dd>
                    <dt>void start(<a>RTCSctpCapabilities</a> remoteCaps)</dt>
                    <dd></dd>
                    <dt>void stop()</dt>
                    <dd>
                        <p>Stops the <a>RTCSctpTransport</a> instance.</p>
                    </dd>
                    <dt>attribute EventHandler ondatachannel</dt>
                    <dd>
                        <p>
                            The <dfn><code>ondatachannel</code></dfn> event handler, of type <code>datachannel</code>, <em class="rfc2119" title="MUST">MUST</em> be
                            supported by all objects implementing the
                            <code><a>RTCSctpTransport</a></code> interface.
                            If the remote peers sets <code><a>RTCDataChannelParameters</a></code>.<code><a>negotiated</a></code> to false,
                            then the event will fire indicating a new <code><a>RTCDataChannel</a></code> object has been
                            constructed to connect with the <code><a>RTCDataChannel</a></code> constructed by the remote peer.
                        </p>
                    </dd>
                    <dt>attribute EventHandler onstatechange</dt>
                    <dd>
                        <p>
                            This event handler, of event handler event type <code><a>statechange</a></code>,
                            <em class="rfc2119" title="MUST">MUST</em> be fired
                            any time the <code><a>RTCSctpTransportState</a></code> changes.
                        <p>
                    </dd>
                </dl>
                <section id="rtcsctptransportstate*">
                <h3>enum RTCSctpTransportState</h3>
                <p><dfn><code>RTCSctpTransportState</code></dfn> indicates the state of the SCTP transport.</p>
                <dl class="idl" title="enum RTCSctpTransportState">
                    <dt>new</dt>
                    <dd>
                        <p>The <code><a>RTCSctpTransport</a></code> object has been created and has not started negotiating yet.</p>
                    </dd>
                    <dt>connecting</dt>
                    <dd>
                        <p>
                            SCTP is in the process of negotiating an association.
                        </p>
                    </dd>
                    <dt>connected</dt>
                    <dd>
                        <p>
                            SCTP has completed negotiation of an association.
                        </p>
                    </dd>
                    <dt>closed</dt>
                    <dd>
                        <p>
                            The SCTP association has been closed intentionally via a call to <code>stop()</code> or receipt of a
                            SHUTDOWN or ABORT chunk.
                        </p>
                    </dd>
                </dl>
            </section>
                <section id="rtcsctpcapabilities*">
                    <h3>dictionary RTCSctpCapabilities</h3>
                    <dl class="idl" title="dictionary RTCSctpCapabilities">
                        <dt>unsigned short maxMessageSize</dt>
                        <dd>
                            <p>Maximum message size.</p>
                        </dd>
                    </dl>
                </section>
            </section>
            <section>
                <h3>RTCDataChannelEvent</h3>
                <p>
                    The <code><a href="#event-datachannel">datachannel</a></code> event
                    uses the <code><a>RTCDataChannelEvent</a></code> interface.
                </p>
                <p>
                    Firing a datachannel event named
                    <var>e</var> with a <code><a>RTCDataChannel</a></code>
                    <var>channel</var> means that an event with the name <var>e</var>, which
                    does not bubble (except where otherwise stated) and is not cancelable
                    (except where otherwise stated), and which uses the
                    <code><a>RTCDataChannelEvent</a></code> interface with the <code><a href=
                        "#dom-datachannelevent-channel">channel</a></code> attribute set to
                    <var>channel</var>, MUST be created and dispatched at the given
                    target.
                </p>
                <dl class="idl" data-merge="RTCDataChannelEventInit"
                    title="interface RTCDataChannelEvent : Event">
                    <dt>Constructor(DOMString type, RTCDataChannelEventInit eventInitDict)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCDataChannel channel</dt>
                    <dd>
                        <p>
                            The <dfn id="dom-datachannelevent-channel"><code>channel</code></dfn> attribute
                            represents the <code><a>RTCDataChannel</a></code> object associated
                            with the event.
                        </p>
                    </dd>
                </dl>
                <dl class="idl" title="dictionary RTCDataChannelEventInit : EventInit">
                    <dt>RTCDataChannel channel</dt>
                    <dd>
                        <p>The <code><a>RTCDataChannel</a></code> object associated with the event.</p>
                    </dd>
                </dl>
            </section>
            <section id="rtcsctpexample*">
                <h2>Example</h2>
                <pre class="example highlight">
function initiate(signaller) {
  // Prepare the ICE gatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };
  
  // Start gathering
  iceGatherer.gather();

  // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create ICE and DTLS transports
  var ice = new RTCIceTransport(iceGatherer);
  var dtls = new RTCDtlsTransport(ice, certs);

  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };
  var sctp = new RTCSctpTransport(dtls);

  // Construct RTCDataChannelParameters dictionary
  var parameters = {
    label: "channel1", 
    ordered: true,
    protocol: "ship",
    negotiated: false
  };

  signaller.sendInitiate({
    // ... include ICE/DTLS info from other example.
    "sctpCapabilities": RTCSctpTransport.getCapabilities()
  }, function(remote) {
    sctp.start(remote.sctpCapabilities);
  // Create the data channel object
  var channel = new RTCDataChannel(sctp, parameters);
  channel.send("foo");
  });
}

function accept(signaller, remote) {
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };
  
  // Start gathering
  iceGatherer.gather();
  
  // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create ICE and DTLS transports
  var ice = new RTCIceTransport(iceGatherer);
  var dtls = new RTCDtlsTransport(ice, certs);

  // Prepare to handle remote candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };

  signaller.sendAccept({
    // ... include ICE/DTLS info from other examples.
    "sctpCapabilities": RTCSctpTransport.getCapabilities()
  });

  // Create the SctpTransport object and start it
  var sctp = new RTCSctpTransport(dtls);
  sctp.start(remote.sctpCapabilties);

  // Assume in-band signalling. We could also have sent
  // RTCDataChannelParameters in signalling and constructed
  // the data channel with negotiated: true.

  sctp.ondatachannel = function(channel) {
    channel.onmessage = function(message) {
      if (message === "foo") {
        channel.send("bar");
      }
    };
  };
}
                </pre>
            </section>
        </section>
        <section>
            <h3>Statistics API</h3>
            <p>The Statistics API enables retrieval of statistics relating to <code><a>RTCRtpSender</a></code>,
                <code><a>RTCRtpReceiver</a></code>,
                <code><a>RTCDtlsTransport</a></code>, <code><a>RTCIceGatherer</a></code>, <code><a>RTCIceTransport</a></code> and
                <code><a>RTCSctpTransport</a></code> objects.
                For detailed information on the Statistics API, consult [[!WEBRTC-STATS]].
            </p>
            <dl class="idl" title="interface RTCStatsProvider">
                <dt>Promise&lt;RTCStatsReport&gt; getStats()</dt>
                <dd>
                    <p>
                        Gathers stats for the given object
                        and reports the result asynchronously.
                        If the object has not yet begun to send or receive data, the returned
                        stats will reflect this. If the object is in the closed state, the returned stats
                        will reflect the stats at the time the object transitioned to the closed state.
                    </p>
                    <p>
                        When the <dfn>getStats()</dfn> method is
                        invoked, the user agent MUST queue a task to run the following
                        steps:
                    </p>
                    <ol>
                        <li>
                            <p>Let <var>p</var> be a new promise.</p>
                        </li>
                        <li>
                            <p>Return, but continue the following steps in the background.</p>
                        </li>
                        <li>
                            <p>Start gathering the stats.</p>
                        </li>
                        <li>
                            <p>
                                When the relevant stats have been gathered, return a
                                new <code><a>RTCStatsReport</a></code> object, representing the
                                gathered stats.
                            </p>
                        </li>
                    </ol>
                </dd>
            </dl>
            <section>
                <h4>RTCStatsReport Object</h4>
                <p>
                    The <code><a>getStats()</a></code>
                    method delivers a successful result in the form of a
                    <code><a>RTCStatsReport</a></code> object. A
                    <code><a>RTCStatsReport</a></code> object represents a map between
                    strings, identifying the inspected objects (<a href="#dom-rtcstats-id">RTCStats.id</a>), and their corresponding
                    <code><a>RTCStats</a></code> objects.
                </p>
                <p>
                    An <code><a>RTCStatsReport</a></code> may be composed of several
                    <code><a>RTCStats</a></code> objects, each reporting stats for one
                    underlying object.
                    One achieves the total for the object by summing over all stats of a
                    certain type; for instance, if an <code><a>RTCRtpSender</a></code> object is sending
                    RTP streams involving multiple SSRCs over the network, the
                    <code><a>RTCStatsReport</a></code> may contain one <code>RTCStats</code>
                    object per SSRC (which can be distinguished by the value of the <var>ssrc</var>
                    stats attribute).
                </p>
                <dl class="idl" title="interface RTCStatsReport">
                    <dt>getter RTCStats (DOMString id)</dt>
                    <dd>
                        <p>
                            Getter to retrieve the <code><a>RTCStats</a></code> objects that
                            this stats report is composed of.
                        </p>
                        <p>
                            The set of supported property names [[!WEBIDL]] is defined as the
                            ids of all the <code><a>RTCStats</a></code> objects that has been
                            generated for this stats report. The order of the property names is
                            left to the user agent.
                        </p>
                    </dd>
                </dl>
            </section>
            <section>
                <h4>RTCStats Dictionary</h4>
                <p>
                    An <code><a>RTCStats</a></code> dictionary represents the stats
                    gathered by inspecting a specific object.
                    The <code><a>RTCStats</a></code>
                    dictionary is a base type that specifies as set of default attributes,
                    such as <code>timestamp</code> and
                    <code>type</code>. Specific stats are added by extending the
                    <code><a>RTCStats</a></code> dictionary.
                </p>
                <p>
                    Note that while stats names are standardized, any given implementation
                    may be using experimental values or values not yet known to the Web
                    application. Thus, applications MUST be prepared to deal with unknown
                    stats.
                </p>
                <p>
                    Statistics need to be synchronized with each other in order to yield
                    reasonable values in computation; for instance, if "bytesSent" and
                    "packetsSent" are both reported, they both need to be reported over the
                    same interval, so that "average packet size" can be computed as "bytes /
                    packets" - if the intervals are different, this will yield errors. Thus
                    implementations MUST return synchronized values for all stats in a
                    <code><a>RTCStats</a></code> object.
                </p>
                <dl class="idl" title="dictionary RTCStats">
                    <dt>DOMHighResTimeStamp timestamp</dt>
                    <dd>
                        <p>
                            The <dfn><code>timestamp</code></dfn>, of type <code>DOMHighResTimeStamp</code>
                            [[!HIGHRES-TIME]], associated with this object. The time is relative
                            to the UNIX epoch (Jan 1, 1970, UTC). The timestamp for local
                            measurements corresponds to the local clock and for remote
                            measurements corresponds to the timestamp indicated in the incoming
                            RTCP Sender Report (SR), Receiver Report (RR) or Extended Report (XR).
                        </p>
                    </dd>
                    <dt>RTCStatsType type</dt>
                    <dd>
                        <p>The type of this object.</p>
                        <p>
                            The <dfn id="dom-rtcstats-type"><code>type</code></dfn> attribute
                            <em class="rfc2119" title="MUST">MUST</em> be initialized to the name
                            of the most specific type this <code><a>RTCStats</a></code> dictionary
                            represents.
                        </p>
                    </dd>
                    <dt>DOMString id</dt>
                    <dd>
                        <p>
                            A unique <code>id</code> that is associated with the object that
                            was inspected to produce this <code>RTCStats</code> object.
                            Two <code>RTCStats</code> objects, extracted from two different
                            <code>RTCStatsReport</code> objects,
                            <em class="rfc2119" title="MUST">MUST</em> have the same
                            <code>id</code> if they were produced by inspecting the same
                            underlying object. User agents are free to pick any format for the
                            <code>id</code> as long as it meets the requirements above.
                        </p>
                    </dd>
                </dl>
                <section id="rtcstatstype*">
                    <h3>RTCStatsType DOMString</h3>
                    <p><var>RTCStatsType</var> is equal to one of the following strings defined in [IANA-TOBE]:</p>
                    <dl>
                        <dt><code>"inboundrtp"</code></dt>
                        <dd>
                            <p>
                                Statistics for the inbound RTP stream. It is
                                accessed via the <code>RTCInboundRTPStreamStats</code> defined
                                in [[!WEBRTC-STATS]] Section 4.2.3. Local inbound RTP
                                statistics can be obtained from the <code><a>RTCRtpReceiver</a></code>
                                object; remote inbound RTP statistics can be obtained from the
                                <code><a>RTCRtpSender</a></code> object.
                            </p>
                        </dd>
                        <dt><code>"outboundrtp"</code></dt>
                        <dd>
                            <p>
                                Statistics for the outbound RTP stream. It is
                                accessed via the <code>RTCOutboundRTPStreamStats</code> defined in
                                [[!WEBRTC-STATS]] Section 4.2.4. Local outbound RTP
                                statistics can be obtained from the <code><a>RTCRtpSender</a></code>
                                object; remote outbound RTP statistics can be obtained from the
                                <code><a>RTCRtpReceiver</a></code> object.
                            </p>
                        </dd>
                        <dt><code>"session"</code></dt>
                        <dd>
                            <p>
                                Statistics relating to <code><a>RTCDataChannel</a></code> objects.
                                It is accessed via the <code>RTCPeerConnectionStats</code>
                                defined in [[!WEBRTC-STATS]] Section 4.3.
                            </p>
                        </dd>
                        <dt><code>"datachannel"</code></dt>
                        <dd>
                            <p>
                                Statistics relating to each <code><a>RTCDataChannel</a></code> id.
                                It is accessed via the <code>RTCDataChannelStats</code>
                                defined in [[!WEBRTC-STATS]] Section 4.5.
                            </p>
                        </dd>
                        <dt><code>"track"</code></dt>
                        <dd>
                            <p>
                                Statistics relating to the <code>MediaStreamTrack</code> object.
                                It is accessed via the <code>RTCMediaStreamTrackStats</code> defined in [[!WEBRTC-STATS]] Section 4.4.2.
                            </p>
                        </dd>
                        <dt><code>"transport"</code></dt>
                        <dd>
                            <p>
                                Transport statistics related to the <code><a>RTCDtlsTransport</a></code> object.
                                It is accessed via the <code>RTCTransportStats</code> and <code>RTCCertificateStats</code>
                                defined in [[!WEBRTC-STATS]] Sections 4.6 and 4.9.
                            </p>
                        </dd>
                        <dt><code>"candidatepair"</code></dt>
                        <dd>
                            <p>
                                ICE candidate pair statistics related to
                                <code><a>RTCIceTransport</a></code> objects.
                                It is accessed via the <code>RTCIceCandidatePairStats</code> defined in [[!WEBRTC-STATS]] Section 4.8.
                            </p>
                        </dd>
                        <dt><code>"localcandidate"</code></dt>
                        <dd>
                            <p>
                                ICE local candidates, related to
                                <code><a>RTCIceGatherer</a></code> objects.
                                It is accessed via the <code>RTCIceCandidateAttributes</code> defined in [[!WEBRTC-STATS]] Section 4.7.
                            </p>
                        </dd>
                        <dt><code>"remotecandidate"</code></dt>
                        <dd>
                            <p>
                                ICE remote candidate, related to
                                <code><a>RTCIceTransport</a></code> objects.
                                It is accessed via the <code>RTCIceCandidateAttributes</code> defined in [[!WEBRTC-STATS]] Section 4.7.
                            </p>
                        </dd>
                    </dl>
                </section>
            </section>
            <section id="rtcpmatchingrules*">
                <h3>RTCP matching rules</h3>
                <p>
                    Since statistics are retrieved from objects within the ORTC API, and information within RTCP packets
                    is used to maintain some of the statistics, the handling of RTCP packets is important to the operation
                    of the statistics API.
                </p>
                <p>
                    RTCP packets arriving on an <code><a>RTCDtlsTransport</a></code> are decrypted and a notification is sent to all
                    <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects utilizing
                    that transport.
                    <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects then
                    examine the RTCP packets to determine the information relevant to their operation and the statistics
                    maintained by them.
                </p>
                <p>
                    RTCP packets should be queued for 30 seconds and all <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code>
                    objects on the related <code><a>RTCDTlsTransport</a></code> have access to those packets until the packet is removed from the queue,
                    should the <code><a>RTCRtpSender</a></code> or <code><a>RTCRtpReceiver</a></code> objects need to examine them.
                </p>
                <p>
                    Relevant SSRC fields within selected RTCP packets are summarized
                    within [[!RFC3550]] Section 6.4.1 (Sender Report),
                    Section 6.4.2 (Receiver Report), Section 6.5 (SDES),
                    Section 6.6 (BYE), [[!RFC4585]] Section 6.1 (Feedback Messages),
                    and [[!RFC3611]] Section 2 (Extended Reports).
                </p>
            </section>
            <section>
                <h4>Example</h4>
                <p>
                    Consider the case where the user is experiencing bad sound and the application wants to
                    determine if the cause of it is packet loss. The following example code might be used:
                </p>
                <pre class="example highlight">
var mySender = new RTCRtpSender(myTrack);
var myPreviousReport = null;

// ... wait a bit
setTimeout(function() {
  mySender.getStats().then(function(report) {
    processStats(report);
    myPreviousReport = report;
  });
}, aBit);

function processStats(currentReport) {
  if (myPreviousReport === null) return;

  // currentReport + myPreviousReport are an RTCStatsReport interface
  // compare the elements from the current report with the baseline
  for (var i in currentReport) {
    var now = currentReport[i];
    if (now.type !== "outboundrtp") continue;

    // get the corresponding stats from the previous report
    base = myPreviousReport[now.id];

    // base + now will be of RTCRtpStreamStats dictionary type
    if (base) {
      remoteNow = currentReport[now.associateStatsId];
      remoteBase = myPreviousReport[base.associateStatsId];
      var packetsSent = now.packetsSent - base.packetsSent;
      var packetsReceived = remoteNow.packetsReceived - remoteBase.packetsReceived;
      // if fractionLost is > 0.3, we have probably found the culprit
      var fractionLost = (packetsSent - packetsReceived) / packetsSent;
    }
  }
}
                </pre>
            </section>
        </section>
        <section id="identity-api">
            <h2>Identity</h2>
            <div class="note">
                This section of the ORTC API specification depends on the WebRTC 1.0 Identity API,
                which is still a work in progress.
            </div>
            <section id="rtcidentity-overview*">
                <h3>Overview</h3>
                <p>
                    An <dfn>RTCIdentity</dfn> instance enables authentication of a DTLS transport using a
                    web-based identity provider (IdP).
                    The idea is that the initiator acts as the Authenticating Party
                    (AP) and obtains an identity assertion from the IdP which is then conveyed in signaling.
                    The responder acts as the Relying Party (RP) and verifies the assertion.
                </p>
                <p>
                    The interaction with the IdP is designed to decouple the browser from any particular
                    identity provider, so that the browser need only know how to load the IdP's
                    Javascript (which is deterministic from the IdP's identity), and the generic protocol
                    for requesting and verifying assertions. The IdP provides whatever logic
                    is necessary to bridge the generic protocol to the IdP's specific requirements.
                    Thus, a single browser can support any number of identity protocols, including being
                    forward compatible with IdPs which did not exist at the time the Identity Provider API was implemented.
                    The generic protocol details are described in [[!RTCWEB-SECURITY-ARCH]].
                    This section specifies the procedures required to instantiate the IdP proxy,
                    request identity assertions, and consume the results.
                </p>
            </section>
            <section id="rtcidentity-operation*">
                <h3>Operation</h3>
                <p>An <code><a>RTCIdentity</a></code> instance is constructed from an <code><a>RTCDtlsTransport</a></code> object.</p>
            </section>
            <section>
                <h4 id="sec.identity-proxy-communications">Identity Provider Selection</h4>
                <p>
                    In order to communicate with the IdP, the browser instantiates an
                    isolated interpreted context, effectively an invisible IFRAME. The
                    initial contents of the context are loaded from a URI derived from the
                    IdP's domain name, as described in [[!RTCWEB-SECURITY-ARCH]].
                </p>
                <p>
                    For purposes of generating assertions, the IdP shall be chosen as follows:
                </p>
                <ol>
                    <li>
                        If the <code>getIdentityAssertion()</code> method has been called,
                        the IdP provided shall be used.
                    </li>
                    <li>
                        If the <code>getIdentityAssertion()</code> method has not been
                        called, then the browser can use an IdP configured into the
                        browser.
                    </li>
                </ol>
                <p>
                    In order to verify assertions, the IdP domain name and protocol are
                    taken from the <code>domain</code> and <code>protocol</code> fields of
                    the identity assertion.
                </p>
            </section>
            <section>
                <h4 id="sec.create-identity-proxy">Instantiating an IdP Proxy</h4>
                <p>
                    The browser creates an IdP proxy by loading an isolated, invisible
                    IFRAME with HTML content from the IdP URI. The URI for the IdP is a
                    well-known URI formed from the <q>domain</q> and <q>protocol</q>
                    fields, as specified in [[!RTCWEB-SECURITY-ARCH]].
                </p>
                <p>When an IdP proxy is required, the browser performs the following steps:</p>
                <ol>
                    <li>
                        An invisible, sandboxed IFRAME is created within the browser
                        context. The IFRAME <code>sandbox</code> attribute is set to
                        "allow-forms allow-scripts allow-same-origin" to limit the
                        capabilities available to the IdP. The browser MUST prevent the IdP
                        proxy from navigating the browsing context to a different location.
                        The browser MUST prevent the IdP proxy from interacting with the user
                        (this includes, in particular, popup windows and user dialogs).
                    </li>
                    <li>
                        Once the IdP proxy is created, the browser creates a
                        <code>MessageChannel</code> [[!webmessaging]] within the context of
                        the IdP proxy and assigns one port from the channel to a variable
                        named <var>rtcwebIdentityPort</var> on the <var>window</var>. This
                        message channel forms the basis of communication between the browser
                        and the IdP proxy. Since it is an essential security property of the
                        web sandbox that a page is unable to insert objects into content from
                        another origin, this ensures that the IdP proxy can trust that
                        messages originating from <var>window.rtcwebIdentityPort</var> are
                        from <code><a>RTCIdentity</a></code> and not some other page. This
                        protection ensures that pages from other origins are unable to
                        instantiate IdP proxies and obtain identity assertions.
                    </li>
                    <li>
                        The IdP proxy completes loading and informs the
                        <code><a>RTCIdentity</a></code> object that it is ready by sending a "READY"
                        message to the message channel port [[!RTCWEB-SECURITY-ARCH]]. Once
                        this message is received by the <code><a>RTCIdentity</a></code> object, the
                        IdP is considered ready to receive requests to generate or verify
                        identity assertions.
                    </li>
                </ol>
                <p>
                    [TODO: This is not sufficient unless we expect the IdP to protect
                    this information. Otherwise, the identity information can be copied
                    from a session with "good" properties to any other session with the same
                    fingerprint information. Since we want to reuse credentials, that would
                    be bad.] The identity mechanism MUST provide an indication to the remote
                    side of whether it requires the stream contents to be
                    protected. Implementations MUST have an user interface that indicates
                    the different cases and identity for these.
                </p>
            </section>
            <section>
                <h3 id="sec.identity-proxy-assertion-request">Requesting Identity Assertions</h3>
                <p>The identity assertion request process involves the following steps:</p>
                <ol>
                    <li>
                        The <code><a>RTCIdentity</a></code> instantiates an IdP proxy as
                        described in <a href="#sec.identity-proxy-communications">Identity
                        Provider Selection section</a> and waits
                        for the IdP to signal that it is ready.
                    </li>
                    <li>
                        The IdP sends a "SIGN" message to the IdP proxy. This message
                        includes the material the <code><a>RTCIdentity</a></code> object
                        desires to be bound to the user's identity.
                    </li>
                    <li>
                        If the user has been authenticated by the IdP, and the IdP is
                        willing to generate an identity assertion, the IdP generates an identity
                        assertion. This step depends entirely on the IdP. The methods by which
                        an IdP authenticates users or generates assertions is not specified,
                        though this could involve interacting with the IdP server or other
                        servers.
                    </li>
                    <li>
                        The IdP proxy sends a response containing the identity assertion to
                        the <code><a>RTCIdentity</a></code> object over the message channel.
                    </li>
                    <li>The <code><a>RTCIdentity</a></code> object MAY store the identity assertion.</li>
                </ol>
                <p>
                    The format and contents of the messages that are exchanged are
                    described in detail in [[!RTCWEB-SECURITY-ARCH]].
                </p>
                <p>
                    The IdP proxy can return an "ERROR" response. If an error is
                    encountered, the <code>getIdentityAssertion</code> Promise MUST
                    be rejected.
                </p>
                <p>
                    The browser  <em class="rfc2119" title="SHOULD">SHOULD</em> limit the time that it will allow for this process.
                    This includes both the loading of
                    the <a href="#sec.identity-proxy-communications">IdP proxy</a> and the
                    identity assertion generation. Failure to do so potentially causes the
                    corresponding operation to take an indefinite amount of time. This timer
                    can be cancelled when the IdP produces a response. The timer running to
                    completion can be treated as equivalent to an error from the IdP.
                </p>
                <section>
                    <h4 id="sec.idp-loginneeded">User Login Procedure</h4>
                    <p>
                        An IdP could respond to a request to generate an identity assertion
                        with a "LOGINNEEDED" error. This indicates that the site does not have
                        the necessary information available to it (such as cookies) to authorize
                        the creation of an identity assertion.
                    </p>
                    <p>
                        The "LOGINNEEDED" response includes a URL for a page where the
                        authorization process can be completed. This URL is exposed to the
                        application through the <code><a href="#">loginUrl</a></code> attribute
                        of the <code>RTCIdentityError</code> object.
                        This URL might be to a page where a user is able to enter their (IdP)
                        username and password, or otherwise provide any information the IdP
                        needs to authorize a assertion request.
                    </p>
                    <p>
                        An application can load the login URL in an IFRAME or popup; the
                        resulting page then provides the user with an opportunity to provide
                        information necessary to complete the authorization process.
                    </p>
                    <p>
                        Once the authorization process is complete, the page loaded in the
                        IFRAME or popup sends a message using <var>postMessage</var>
                        [[!webmessaging]] to the page that loaded it (through the
                        <var><a href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-opener">window.opener</a></var>
                        attribute for popups, or through
                        <var><a href="http://www.w3.org/html/wg/drafts/html/master/browsers.html#dom-parent">window.parent</a></var>
                        for pages loaded in an IFRAME). The message MUST be the
                        <var>DOMString</var> "LOGINDONE". This message informs the application
                        that another attempt at generating an identity assertion is likely to be
                        successful.
                    </p>
                </section>
            </section>
            <section>
                <h3 id="sec.identity-verify-assertion">Verifying Identity Assertions</h3>
                <p>
                    Identity assertion validation happens
                    when <code>setIdentityAssertion()</code>
                    is invoked. The process runs
                    asynchronously.
                </p>
                <p>The identity assertion validation process involves the following steps:</p>
                <ol>
                    <li>
                        The <code><a>RTCIdentity</a></code> instantiates an IdP proxy as
                        described in <a href="#sec.identity-proxy-communications"> Identity
                        Provider Selection section </a> and waits
                        for the IdP to signal that it is ready.
                    </li>
                    <li>
                        The IdP sends a "VERIFY" message to the IdP proxy. This message
                        includes the assertion which is to be
                        verified.
                    </li>
                    <li>
                        The IdP proxy verifies the identity assertion (depending on the
                        authentication protocol this could involve interacting with the IDP
                        server).
                    </li>
                    <li>
                        Once the assertion is verified, the IdP proxy sends a response
                        containing the verified assertion results to the
                        <code><a>RTCIdentity</a></code> object over the message channel.
                    </li>
                    <li>
                        The <code><a>RTCIdentity</a></code> object validates that the fingerprint
                        provided by the IdP in the validation response matches the certificate
                        fingerprint that is, or will be, used for communications. This is done by
                        waiting for the DTLS connection to be established and checking
                        that the certificate fingerprint on the connection matches the one
                        provided by the IdP.
                    </li>
                    <li>
                        The <code><a>RTCIdentity</a></code> validates that the domain portion
                        of the identity matches the domain of the IdP as described in [[!RTCWEB-SECURITY-ARCH]].
                    </li>
                    <li>
                        The <code><a>RTCIdentity</a></code> stores the assertion in the
                        <code><a>peerIdentity</a></code>, and returns an <code>RTCIdentityAssertion</code> object
                        when the Promise from <code>setIdentityAssertion()</code> is fulfilled.
                        The assertion
                        information to be displayed MUST contain the domain name of the IdP as
                        provided in the assertion.
                    </li>
                    <li>
                        The browser MAY display identity information to a user in browser
                        UI. Any user identity information that is displayed in this fashion
                        MUST use a mechanism that cannot be spoofed by content.
                    </li>
                </ol>
                <p>
                    The IdP might fail to validate the identity assertion by providing an
                    "ERROR" response to the validation request. Validation can also fail due
                    to the additional checks performed by the browser. In both cases, the
                    process terminates and no identity information is exposed to the
                    application or the user.
                </p>
                <p>
                    The browser MUST cause the Promise of <code>setIdentityAssertion()</code> to be rejected if
                    validation of an identity assertion fails for any reason.
                </p>
                <p>
                    The browser  <em class="rfc2119" title="SHOULD">SHOULD</em> limit the time that it will allow for this process.
                    This includes both the loading of
                    the <a href="#sec.identity-proxy-communications">IdP proxy</a> and the
                    identity assertion validation. Failure to do so potentially causes the
                    corresponding operation to take an indefinite amount of time. This timer
                    can be cancelled when the IdP produces a response. The timer running to
                    completion can be treated as equivalent to an error from the IdP.
                </p>
                <p>
                    The format and contents of the messages that are exchanged are
                    described in detail in [[!RTCWEB-SECURITY-ARCH]].
                </p>
                <p>
                    As defined in [[!WEBRTC10]] Section 10.4, the <code>peerIdentity</code> parameter           
                    to <code>getUserMedia()</code> enables media to be sent to a specifically identified 
                    peer, without the contents of mediastreams being accessible to applications.
                    If a  <code>MediaStreamTrack</code> with a <code>peerIdentity</code> constraint
                    applied is attached to an  <code><a>RTCRtpSender</a></code>, media is not sent
                    unless the attached <code><a>RTCDtlsTransport</a></code> has validated
                    the same <code><a>peerIdentity</a></code> as the MediaStreamTrack 's constraint.
                </p>
            </section>
            <section>
                <h3>RTCIdentity Interface</h3>
                <p>The Identity API is described below.</p>
                <dl class="idl" title="interface RTCIdentity">
                    <dt>Constructor(RTCDtlsTransport transport)</dt>
                    <dd></dd>
                    <dt>readonly attribute RTCIdentityAssertion? peerIdentity</dt>
                    <dd>
                        <p>
                            <dfn>peerIdentity</dfn> contains the peer identity assertion information if an identity
                            assertion was provided and verified. Once this value is set to a
                            non-<var>null</var> value, it cannot change.
                        </p>
                    </dd>
                    <dt>readonly attribute RTCDtlsTransport transport</dt>
                    <dd>
                        <p>The <code>RTCDtlsTransport</code> to be authenticated.</p>
                    </dd>
                    <dt>Promise&lt;DOMString&gt; getIdentityAssertion (DOMString provider, optional DOMString protocol = "default", optional DOMString username)</dt>
                    <dd>
                        <p>Sets the identity provider to be used for a given <code><a>RTCIdentity</a></code> object, and initiates the process of obtaining an identity assertion.</p>
                        <p>When <dfn>getIdentityAssertion()</dfn> is invoked, the user agent MUST run the following steps:</p>
                        <ol>
                            <li>
                                <p>
                                    If <code>transport.state</code>
                                    is <code>closed</code>, throw an
                                    <code>InvalidStateError</code> exception and abort these
                                    steps.
                                </p>
                            </li>
                            <li>
                                <p>
                                    Set the current identity provider values to the triplet
                                    (<code>provider</code>, <code>protocol</code>,
                                    <code>username</code>).
                                </p>
                            </li>
                            <li>
                                <p>
                                    If any identity provider value has changed, discard any stored
                                    identity assertion.
                                </p>
                            </li>
                            <li>
                                <p><a href="#sec.identity-proxy-assertion-request">Request an identity assertion</a> from the IdP.</p>
                            </li>
                            <li>
                                <p>
                                    If the IdP proxy provides an assertion over the message channel,
                                    the Promise is fulfilled, and the assertion is returned (equivalent to <code>onidentityresult</code> in the
                                    WebRTC 1.0 API). If the IdP proxy returns an "ERROR" response, the Promise is rejected, and an <code>RTCIdentityError</code> object is returned,
                                    (equivalent to <code>onidpassertionerror</code> in the WebRTC 1.0 API).
                                </p>
                            </li>
                        </ol>
                    </dd>
                    <dt>Promise&lt;RTCIdentityAssertion&gt; setIdentityAssertion (DOMString assertion)</dt>
                    <dd>
                        <p>
                            Validates the identity assertion. If the Promise is fulfilled,
                            an <code>RTCIdentityAssertion</code> is returned.
                            If the Promise is rejected, an <code>RTCIdentityError</code> object is returned, (equivalent to
                            <code>onidpvalidationerror</code> in the WebRTC 1.0 API).
                        </p>
                    </dd>
                </dl>
            </section>
            <section>
                <h3>dictionary RTCIdentityError</h3>
                <dl class="idl" title="dictionary RTCIdentityError">
                    <dt>DOMString idp</dt>
                    <dd>
                        <p>The domain name of the identity provider that is providing the error response.</p>
                    </dd>
                    <dt>DOMString? loginUrl</dt>
                    <dd>
                        <p>
                            An IdP that is unable to generate an identity assertion due to a
                            lack of sufficient user authentication information can provide a URL
                            to a page where the user can complete authentication.
                            If the IdP provides this URL, this attribute includes the value provided
                            by the IdP.
                        </p>
                    </dd>
                    <dt>DOMString protocol</dt>
                    <dd>
                        <p>The IdP protocol that is in use.</p>
                    </dd>
                </dl>
            </section>
            <section>
                <h3>dictionary RTCIdentityAssertion</h3>
                <dl class="idl" title="dictionary RTCIdentityAssertion">
                    <dt>DOMString idp</dt>
                    <dd>
                        <p>A domain name representing the identity provider.</p>
                    </dd>
                    <dt>DOMString name</dt>
                    <dd>
                        <p>
                            A representation of the verified peer identity conforming to [[!RFC5322]].
                            This identity will have been verified via the
                            procedures described in [[!RTCWEB-SECURITY-ARCH]].
                        </p>
                    </dd>
                </dl>
            </section>
            <section>
                <h3>Example</h3>
                <p>
                    The identity system is designed so that applications need not take any
                    special action in order for users to generate and verify identity
                    assertions; if a user has configured an IdP into their browser, then the
                    browser will automatically request/generate assertions and the other side
                    will automatically verify them and display the results. However,
                    applications may wish to exercise tighter control over the identity
                    system as shown by the following examples.
                </p>
                <div>
                    <p>
                        This example shows how to configure the identity provider and
                        protocol, and consume identity assertions.
                    </p>
                    <pre class="example highlight">
// Set ICE gather options and construct the RTCIceGatherer object, assuming that
// we are using RTP/RTCP mux and A/V mux so that only one RTCIceTransport is needed.
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange, 
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';
var gatherOptions = {
  gatherPolicy: "all",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
      credentialType: "password" }
   ]
};
var iceGatherer = new RTCIceGatherer(gatherOptions);
iceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate);
};
// Start gathering
iceGatherer.gather();
// Construct the ICE transport
var ice = new RTCIceTransport(iceGatherer);
// Create the DTLS certificate
var certs;
var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
  certs[0] = certificate;
}, function(){
  trace('Certificate could not be created');
});

// Create the RTCDtlsTransport object.
var dtls = new RTCDtlsTransport(ice, certs);
var identity = new RTCIdentity(dtls);
identity
  .getIdentityAssertion("example.com", "default", "alice@example.com")
  .then(signalAssertion(assertion), function(e) {
    trace("Could not obtain an Identity Assertion. idp: " + e.idp + " Protocol: " 
      + e.protocol + " loginUrl: " + e.loginUrl);
  });

function signalAssertion(assertion) {
  mySignalInitiate({
    "myAssertion": assertion,
    "ice": iceGatherer.getLocalParameters(),
    "dtls": dtls.getLocalParameters()
  }, function(response) {
    ice.start(iceGatherer, response.ice, RTCIceRole.controlling);
    // Call dtls.start() before setIdentityAssertion so the peer assertion can be validated.
    dtls.start(response.dtls);
    identity.setIdentityAssertion(response.myAssertion).then(function(peerAssertion) {
      trace("Peer identity assertion validated. idp: " + peerAssertion.idp + " name: " 
        + peerAssertion.name);
    }, function(e) {
      trace("Could not validate peer assertion. idp: " + e.idp + " Protocol: " + e.protocol);
    });
  });
}
                    </pre>
                </div>
            </section>
        </section>
        <section id="certificate-api">
            <h2>Certificate Management</h2>
            <div class="note">
                This section of the ORTC API specification is based on the WebRTC 1.0 Certificate Management API,
                which was recently introduced and is still a work-in-progress.
            </div>
            <section id="rtccertificate-overview*">
                <h3>Overview</h3>
                <p>
                    The <dfn><code>RTCCertificate</code></dfn> interface enables the certificates used by an <code><a>RTCDtlsTransport</a></code>
                    to be provided in the constructor.
                    This makes it possible to support forking, where the offerer will create multiple <code><a>RTCDtlsTransport</a></code> objects
                    using the same local certificate and fingerprint.
                </p>
            </section>
            <section>
                <h3>RTCCertificate Interface</h3>
                <p>The Certificate API is described below.</p>
                <dl class="idl" title="interface RTCCertificate">
                    <dt>readonly attribute DOMTimeStamp expires</dt>
                    <dd>
                        <p>
                            The <code>expires</code> attribute indicates the date and time in milliseconds relative to
                            1970-01-01T00:00:00Z after which the certificate will be considered invalid by the browser.
                            After this time, attempts to construct an <code><a>RTCDtlsTransport</a></code> object using
                            this certificate will fail.
                        </p>
                        <p>
                            Note that this value might not be reflected in
                            a <code>notAfter</code> parameter in the certificate itself.
                        </p>
                    </dd>
                    <dt>readonly attribute RTCDtlsFingerprint fingerprint</dt>
                    <dd>
                        <p>The fingerprint of the certificate.  As noted in [[!JSEP]] Section 5.2.1,
                        the digest algorithm used for the fingerprint matches that used in the certificate
                        signature.</p>
                    </dd>
                    <dt>AlgorithmIdentifier getAlgorithm()</dt>
                    <dd>
                        <p>
                            Returns the value of <code>keygenAlgorithm</code> passed in the call
                            to <code>generateCertificate()</code>.
                        </p>
                    </dd>	
                    <dt>static Promise&lt;RTCCertificate&gt; generateCertificate (AlgorithmIdentifier keygenAlgorithm)</dt>
                    <dd>
                        <p>
                            The <code>generateCertificate</code> method causes the <a class="internalDFN" href="#dfn-user-agent">user
                            agent</a> to create and store an X.509 certificate [[!X509V3]] and
                            corresponding private key. A handle to information is provided in the
                            form of the <code><a>RTCCertificate</a></code> interface. The
                            returned <code><a>RTCCertificate</a></code> can be used to control the
                            certificate that is offered in the DTLS session established
                            by <code><a>RTCDtlsTransport</a></code>.
                        </p>
                        <p>
                            The <code>keygenAlgorithm</code> argument is used to control how the
                            private key associated with the certificate is generated.
                            The <code>keygenAlgorithm</code> argument uses the WebCrypto [[!WebCryptoAPI]]
                            <a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-AlgorithmIdentifier">AlgorithmIdentifier</a>
                            type. The <code>keygenAlgorithm</code> value <em title="MUST" class="rfc2119">MUST</em> be a valid argument
                            to <a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#SubtleCrypto-method-generateKey"><code>window.crypto.subtle.generateKey</code></a>;
                            that is, the value <em title="MUST" class="rfc2119">MUST</em> produce a non-error result when normalized
                            according to the
                            WebCrypto <a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#algorithm-normalization">algorithm
                            normalization process</a> [[!WebCryptoAPI]] with an operation name
                            of <code>generateKey</code> and a
                            [[<a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-supportedAlgorithms">supportedAlgorithms</a>]]
                            value specific to production of certificates for <code><a>RTCDtlsTransport</a></code>.
                            If the algorithm normalization process produces an error, the call to <code>generateCertificate()</code>
                            <em title="MUST" class="rfc2119">MUST</em> be rejected with that error.
                        </p>
                        <p>
                            Signatures produced by the generated key are used to authenticate
                            the DTLS connection. The identified algorithm (as identified by
                            the <code>name</code> of the
                            normalized <code>AlgorithmIdentifier</code>) <em title="MUST" class="rfc2119">MUST</em> be an asymmetric
                            algorithm that can be used to produce a signature.
                        </p>
                        <p>
                            The certificate produced by this process also contains a signature.
                            The validity of this signature is only relevant for compatibility
                            reasons. Only the public key and the resulting certificate
                            fingerprint are used by <code><a>RTCDtlsTransport</a></code>, but it is more
                            likely that a certificate will be accepted if the certificate is well
                            formed. The browser selects the algorithm used to sign the
                            certificate; a browser <em title="SHOULD" class="rfc2119">SHOULD</em> select SHA-256 [[!FIPS-180-4]] if a hash
                            algorithm is needed.
                        </p>
                        <p>
                            The resulting certificate <em title="MUST NOT" class="rfc2119">MUST NOT</em> include information that can be
                            linked to a user or <a class="internalDFN" href="#dfn-user-agent">user agent</a>. Randomized values for
                            distinguished name and serial number <em title="SHOULD" class="rfc2119">SHOULD</em> be used.
                        </p>
                        <p>
                            An optional <code>expires</code> attribute <em title="MAY" class="rfc2119">MAY</em> be added to the
                            <var>keygenAlgorithm</var> parameter. If this contains a <code><a>DOMTimeStamp</a></code> value,
                            it indicates the maximum time that the <code><a>RTCCertificate</a></code> is valid for relative to
                            the current time.  A <a>user agent</a> sets the <code><a href="#widl-RTCCertificate-expires">expires</a></code>
                            attribute of the returned <code><a>RTCCertificate</a></code> to the current time plus the value of the <code>expires</code>
                            attribute. However, a <a>user agent</a> MAY choose to limit the period over which an <code><a>RTCCertificate</a></code>
                            is valid.
                        </p>
                        <p>
                            A <a class="internalDFN" href="#dfn-user-agent">user agent</a> <em title="MUST" class="rfc2119">MUST</em> reject a call
                            to <code>generateCertificate()</code> with a <code>DOMError</code> of
                            type "NotSupportedError" if the <var>keygenAlgorithm</var> parameter
                            identifies an algorithm that the <a class="internalDFN" href="#dfn-user-agent">user agent</a> cannot or will not
                            use to generate a certificate for <code><a>RTCDtlsTransport</a></code>.
                        </p>
                        <p>
                            The following values <em title="MUST" class="rfc2119">MUST</em> be supported by a <a class="internalDFN" href="#dfn-user-agent">user agent</a>:
                            <code>{ name:
                            "<a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#rsassa-pkcs1">RSASSA-PKCS1-v1_5</a>",
                            modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" }</code>, and <code>{
                            name:
                            "<a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#ecdsa">ECDSA</a>",
                            namedCurve:
                            "<a href="https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-NamedCurve">P-256</a>"
                            }</code>.
                        </p>
                        <p>
                          It is expected that a <a class="internalDFN" href="#dfn-user-agent">user agent</a> will have a
                          small or even fixed set of values that it will accept.
                        </p>
                    </dd>
                </dl>
            </section>
        </section>
        <section class="informative">
            <h2>Event summary</h2>
            <p>The following events fire on <code><a>RTCDtlsTransport</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><code>error</code></td>
                        <td><code><a>ErrorEvent</a></code></td>
                        <td>The <code><a>RTCDtlsTransport</a></code> object has received a DTLS Alert.</td>
                    </tr>
                    <tr>
                        <td><dfn>statechange</dfn></td>
                        <td><code><a>Event</a></code></td>
                        <td>The <code><a>RTCDtlsTransportState</a></code> changed.</td>
                    </tr>
                </tbody>
            </table>
            <p>The following events fire on <code><a>RTCIceTransport</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><code>statechange</code></td>
                        <td><code><a>Event</a></code></td>
                        <td>The <code><a>RTCIceTransportState</a></code> changed.</td>
                    </tr>
                    <tr>
                        <td><code>icecandidatepairchange</code></td>
                        <td><code><a>RTCIceCandidatePairChangedEvent</a></code></td>
                        <td>The selected <code><a>RTCIceCandidatePair</a></code> changed.</td>
                    </tr>
                </tbody>
            </table>
            <p>The following events fire on <code><a>RTCIceGatherer</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><dfn>icecandidateerror</dfn></td>
                        <td><code><a>RTCIceGathererIceErrorEvent</a></code></td>
                        <td>The <code><a>RTCIceGatherer</a></code> object has experienced an ICE gathering failure (such as an authentication failure with TURN credentials).</td>
                    </tr>
                    <tr>
                        <td><code>statechange</code></td>
                        <td><code><a>Event</a></code></td>
                        <td>The <code><a>RTCIceGathererState</a></code> changed.</td>
                    </tr>
                    <tr>
                        <td><code>icecandidate</code></td>
                        <td><code><a>RTCIceGatherer</a></code></td>
                        <td>A new <code><a>RTCIceGatherCandidate</a></code> is made available to the script.</td>
                    </tr>
                </tbody>
            </table>
            <p>The following events fire on <code><a>RTCRtpSender</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><dfn id="event-ssrcconflict"><code>ssrcconflict</code></dfn></td>
                        <td><code><a>RTCSsrcConflictEvent</a></code></td>
                        <td>An SSRC conflict has been detected within the RTP session.</td>
                    </tr>
                </tbody>
            </table>
            <p>The following events fire on <code><a>RTCRtpListener</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><dfn id="event-RTCRtpListener-unhandledrtp"><code>unhandledrtp</code></dfn></td>
                        <td><code><a>RTCRtpUnhandledEvent</a></code></td>
                        <td>The <code><a>RTCRtpListener</a></code> object has received an RTP packet that it cannot deliver to an <code><a>RTCRtpReceiver</a></code> object.</td>
                    </tr>
                </tbody>
            </table>
            <p>The following events fire on <code><a>RTCDTMFSender</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><dfn id="event-RTCDTMFSender-tonechange"><code>tonechange</code></dfn></td>
                        <td><code><a>Event</a></code></td>
                        <td>
                            The <code><a>RTCDTMFSender</a></code> object has either just
                            begun playout of a tone (returned as the <code><a>tone</a></code>
                            attribute) or just ended playout of a tone (returned as an empty
                            value in the <code><a>tone</a></code> attribute).
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>The following events fire on <code><a>RTCDataChannel</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><dfn id="event-datachannel-open"><code>open</code></dfn></td>
                        <td><code><a>Event</a></code></td>
                        <td>
                            The <code><a>RTCDataChannel</a></code> object's <a>underlying data transport</a>
                            has been established (or re-established).
                        </td>
                    </tr>
                    <tr>
                        <td><dfn id="event-datachannel-message"><code>message</code></dfn></td>
                        <td><code><a href="http://www.w3.org/TR/webmessaging/#the-messageevent-interfaces">MessageEvent</a></code> [[!webmessaging]]</td>
                        <td>A message was successfully received.</td>
                    </tr>
                    <tr>
                        <td><dfn id="event-datachannel-bufferedamountlow"><code>bufferedamountlow</code></dfn></td>
                        <td><code><a>Event</a></code></td>
                        <td>The <code><a>RTCDataChannel</a></code> object's <code><a href=
                        "#dom-datachannel-bufferedamount">bufferedAmount</a></code>
                        decreases from above its <code><a href="#dom-datachannel-bufferedamountlowthreshold">
                        bufferedAmountLowThreshold</a></code> to less than or equal to its <code><a href=
                        "#dom-datachannel-bufferedamountlowthreshold">bufferedAmountLowThreshold</a></code>.
                        </td>
                    </tr>
                        <tr>
                        <td><dfn id="event-datachannel-error"><code>error</code></dfn></td>
                        <td><code><a>ErrorEvent</a></code></td>
                        <td>An error has been detected within the <code><a>RTCDataChannel</a></code> object. This is not used for programmatic exceptions.</td>
                    </tr>
                    <tr>
                        <td><dfn id="event-datachannel-close"><code>close</code></dfn></td>
                        <td><code><a>Event</a></code></td>
                        <td>
                            The <code><a>RTCDataChannel</a></code> object's <a>underlying data transport</a>
                            has been closed.
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>The following events fire on <code><a>RTCSctpTransport</a></code> objects:</p>
            <table border="1" style="border-width:0; width:60%">
                <tr>
                    <th>Event name</th>
                    <th>Interface</th>
                    <th>Fired when...</th>
                </tr>
                <tbody>
                    <tr>
                        <td><dfn id="event-datachannel"><code>datachannel</code></dfn></td>
                        <td><code><a>RTCDataChannelEvent</a></code></td>
                        <td>
                            A new <code><a>RTCDataChannel</a></code>
                            is dispatched to the script in response to the
                            other peer creating a channel.
                        </td>
                    </tr>
                    <tr>
                        <td><code>statechange</code></td>
                        <td><code><a>Event</a></code></td>
                        <td>The <code><a>RTCSctpTransportState</a></code> changed.</td>
                    </tr>
                </tbody>
            </table>
        </section>
        <section class="informative" id="webrtc-compat*">
            <h2>WebRTC 1.0 Compatibility</h2>
            <p>
                It is a goal of the ORTC API to provide the functionality of the WebRTC 1.0 API [[!WEBRTC10]], as well as to enable the
                WebRTC 1.0 API to be implemented on top of the ORTC API, utilizing a Javascript "shim" library. This section
                discusses WebRTC 1.0 compatibility issues that have been encountered by ORTC API implementers.
            </p>
            <section id="bundle*">
                <h3>BUNDLE</h3>
                <p>
                    Via the use of [[!BUNDLE]] it is possible for WebRTC 1.0 implementations to multiplex audio and
                    video on the same RTP session.
                    Within ORTC API, equivalent behavior can be obtained by constructing multiple
                    <code><a>RTCRtpReceiver</a></code> and <code><a>RTCRtpSender</a></code>
                    objects from the same <code><a>RTCDtlsTransport</a></code> object.
                    As noted in [[!RTP-USAGE]] Section 4.4, support for audio/video multiplexing is required,
                    as described in [[!RTP-MULTI-STREAM]].
                </p>
            </section>
            <section id="voice-activity*">
                <h3>Voice Activity Detection</h3>
                <p>
                    [[!WEBRTC10]] Section 4.2.4 defines the <code>RTCOfferOptions</code> dictionary, which includes the <code>voiceActivityDetection</code> attribute,
                    which determines whether Voice Activity Detection (VAD) is enabled within the Offer produced by <code>createOffer()</code>.
                    The effect of setting <code>voiceActivityDetection</code> to <code>true</code> is to include the Comfort Noice (CN) codec defined in
                    [[!RFC3389]] within the Offer.
                </p>
                <p>
                    Within ORTC API, equivalent behavior can be obtained by configuring the Comfort Noise (CN) codec for use within <code>RTCRtpParameters</code>,
                    and/or configuring a codec with built-in support for Discontinuous Operation (DTX), such as Opus.
                    As noted in [[!RFC7874]] Section 3, support for CN is required.
                </p>
            </section>
            <section id="h264*">
                <h3>H.264/AVC</h3>
                <p>
                    [[RFC6184]] Section 8.1 defines the <code>level-asymmetry-allowed</code> SDP parameter
                    supported by some WebRTC 1.0 API implementations. Within  ORTC API, the <code>profileLevelId</code>
                    capability is supported for both the <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code>,
                    and the <code>profileLevelId</code> setting is provided for the <code><a>RTCRtpSender</a></code>.
                    Since in ORTC API sender and receiver <code>profileLevelId</code> capabilities are independent
                    and there is no <code>profileLevelId</code> setting for an <code><a>RTCRtpReceiver</a></code>,
                    ORTC API assumes that implementations support level asymmetry.  Therefore a WebRTC 1.0 API shim library
                    for ORTC API should provide a <code>level-asymmetry-allowed</code> value of <code>1</code>.
                </p>
            </section>
            <section id="nonmux-identity*">
                <h3>Identity and non-multiplexed RTP/RTCP</h3>
                <p>
                    Where RTP and RTCP are not multiplexed, distinct <code><a>RTCIceTransport</a></code>,
                    <code><a>RTCDtlsTransport</a></code> and <code><a>RTCIdentity</a></code> objects can be
                    constructed for RTP and RTCP. While it is possible for
                    <code>getIdentityAssertion()</code> to be called with different values of
                    <code>provider</code>, <code>protocol</code> and <code>username</code> for the RTP and RTCP
                    <code><a>RTCIdentity</a></code> objects, application developers desiring backward
                    compatibility with WebRTC 1.0 are strongly discouraged from doing so, since this is
                    likely to result in an error.
                </p>
                <p>
                    Also, where RTP and RTCP are not multiplexed, it is possible that the assertions for both the RTP and RTCP will be validated,
                    but that the identities will not be equivalent. Applications requiring backward compatibility with WebRTC 1.0
                    are advised to consider this an error. However, if backward compatibility with WebRTC 1.0 is not required the application 
                    can consider an alternative, such as ignoring the RTCP identity assertion.
                </p>
            </section>
        </section>
        <section class="informative" id="examples*">
            <h2>Examples</h2>
            <section id="simple-peer-to-peer-example*">
                <h3>Simple Peer-to-peer Example</h3>
                <p>This example code provides a basic audio and video session between two browsers.</p>
                <pre class="example"><code></code></pre>
            </section>
            <section id="js-library-example*">
                <h3>myCapsToSendParams Example</h3>
                <pre class="example highlight">
RTCRtpParameters function myCapsToSendParams(RTCRtpCapabilities sendCaps,
  RTCRtpCapabilities remoteRecvCaps) {
  // Function returning the sender RTCRtpParameters, based on the local
  // sender and remote receiver capabilities.
  // The goal is to enable a single stream audio and video call with minimum fuss.
  //
  // Steps to be followed:
  // 1. Determine the RTP features that the receiver and sender have in common.
  // 2. Determine the codecs that the sender and receiver have in common.
  // 3. Within each common codec, determine the common formats, header extensions 
  //    and rtcpFeedback mechanisms.
  // 4. Determine the payloadType to be used, based on the receiver preferredPayloadType.
  // 5. Set RTCRtcpParameters such as mux to their default values.
  // 6. Return RTCRtpParameters enablig the jointly supported features and codecs.
}

RTCRtpParameters function myCapsToRecvParams(RTCRtpCapabilities recvCaps,
  RTCRtpCapabilities remoteSendCaps) {
  // Function returning the receiver RTCRtpParameters, based on the local 
  // receiver and remote sender capabilities.
  return myCapsToSendParams(remoteSendCaps, recvCaps);
}
            </pre>
            </section>
        </section>
        <section class="appendix">
            <h2>Acknowledgements</h2>
            <p>
                The editor wishes to thank Erik Lagerway (Chair of the ORTC CG and Co-chair of the WEBRTC WG) for his support.
                Substantial text in this specification was provided by many people including Peter Thatcher, Martin Thomson,
                Iaki Baz Castillo, Jose Luis Millan, Christoph Dorn, Roman Shpount, Emil Ivov, Shijun Sun and Jason Ausborn.
                Special thanks to Peter Thatcher for his design contributions relating to many of the objects in the current
                specification, and to Philipp Hancke, Jxck and Iaki Baz Castillo for their detailed review.
            </p>
        </section>
        <section id="change-log*">
            <h2>Change Log</h2>
            <p>This section will be removed before publication.</p>
            <!-- Why do the first two headings automatically convert to <h2>? -->
            <section id="since-04-May-2016*">
                <h3>Changes since 04 May 2016</h3>
                <ol>
                    <li>
                        Clarified support for simulcast reception and MRST SVC codecs, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/175">Issue 175</a>
                    </li>
                    <li>
                        Simplified text relating to event handlers, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/309">Issue 309</a>
                    </li>
                    <li>
                        Clarified meaning of <code><a>RTCRtpCodecCapability</a></code>.<var>options</var>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/412">Issue 412</a>
                    </li>
                    <li>
                        Provided <code>rtcp.ssrc</code> advice for implementations, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/462">Issue 462</a>
                    </li>
                    <li>
                        Clarified effect of <code>RTCRtpReceiver.track.stop()</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/498">Issue 498</a>
                    </li>
                    <li>
                        Updated text relating to consent failures, as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/issues/517">Issue 517</a>
                    </li>
                    <li>
                        Clarified <var>muxId</var> usage, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/528">Issue 528</a>
                    </li>
                    <li>
                        Clarified meaning of <var>name</var>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/529">Issue 529</a>
                    </li>
                    <li>
                        Updated ICE transition diagram, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/535">Issue 535</a>
                    </li>
                    <li>
                        Clarified "rtx" entries in <code><a>RTCRtpCodecCapability</a></code> and <code><a>RTCRtpCodecParameters</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/539">Issue 539</a>
                    </li>
                    <li>
                        Updated text relating to "server could not be reached", as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/issues/542">Issue 542</a>
                    </li>
                    <li>
                        Corrected codec name usage, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/544">Issue 544</a> and
                        <a href="https://github.com/openpeer/ortc/issues/548">Issue 548</a>
                    </li>
                    <li>
                        Clarified that <code>codecPayloadType</code> can be unset, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/545">Issue 545</a>
                    </li>
                    <li>
                        Converted figures to SVG format with figure/caption markup, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/572">Issue 572</a>
                    </li>
                </ol>
            </section>
            <section id="since-01-March-2016*">
                <h3>Changes since 01 March 2016</h3>
                <ol>
                   <li>
                        Added the <code>gather()</code> method, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/165">Issue 165</a>
                    </li>
                    <li>
                        Removed "public" from <code><a>RTCIceGatherPolicy</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/224">Issue 224</a>
                    </li>
                    <li>
                        Removed the <code>minQuality</code> attribute, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/351">Issue 351</a>
                    </li>
                    <li>
                        Made <code>send()</code> and <code>receive()</code> asynchronous, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/399">Issue 399</a>,
                        <a href="https://github.com/openpeer/ortc/issues/463">Issue 463</a>,
                        <a href="https://github.com/openpeer/ortc/issues/468">Issue 468</a> and
                        <a href="https://github.com/openpeer/ortc/issues/469">Issue 469</a>
                    </li>
                    <li>
                        Provided additional information on ICE candidate errors, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/402">Issue 402</a>
                    </li>
                    <li>
                        Added <code>state</code> attribute to <code><a>RTCSctpTransport</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/403">Issue 403</a>
                    </li>
                    <li>
                        Provided an example of RTX/RED/FEC configuration, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/404">Issue 404</a>
                    </li>
                    <li>
                        Clarified <code>payloadType</code> uniqueness, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/405">Issue 405</a>
                    </li>
                    <li>
                        Updated the list of header extensions, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/409">Issue 409</a>
                    </li>
                    <li>
                        Added "goog-remb" to the list of feedback mechanisms, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/410">Issue 410</a>
                    </li>
                    <li>
                        Added <var>kind</var> argument to the <code><a>RTCRtpReceiver</a></code> constructor, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/411">Issue 411</a>
                    </li>
                    <li>
                        Clarified <code>send()</code> restrictions on <var>kind</var>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/414">Issue 414</a>
                    </li>
                    <li>
                        Added <code>getAlgorithm()</code> method, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/427">Issue 427</a>
                    </li>
                   <li>
                        Changed <code><a>RTCDataChannel</a></code> <var>protocol</var> and <var>label</var> to USVString, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/429">Issue 429</a>
                    </li>
                    <li>
                        Clarified nullable attributes and methods returning empty lists, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/433">Issue 433</a>
                    </li>
                    <li>
                        Clarified support for the "direction" parameter, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/442">Issue 442</a>
                    </li>
                    <li>
                        Clarified the <var>apt</var> capability of the "red" codec, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/444">Issue 444</a>
                    </li>
                    <li>
                        Clarified usage of <code><a>RTCRtpEncodingParameters</a></code> attributes, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/445">Issue 445</a>
                    </li>
                    <li>
                        Clarified firing of <code><a>onssrcconflict</a></code> event, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/448">Issue 448</a>
                    </li>
                    <li>
                        Clarified that CNAME is only set on an <code><a>RTCRtpSender</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/450">Issue 450</a>
                    </li>
                    <li>
                        Updated references, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/457">Issue 457</a>
                    </li>
                    <li>
                        Described behavior of <code>send()</code> and <code>receive()</code> with unset <code><a>RTCRtpEncodingParameters</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/461">Issue 461</a>
                    </li>
                    <li>
                        Corrected dictionary initialization in the examples, noted in:
                        <a href="https://github.com/openpeer/ortc/issues/464">Issue 464</a> and
                        <a href="https://github.com/openpeer/ortc/issues/465">Issue 465</a>
                    </li>
                    <li>
                        Corrected use of enums in the examples, noted in:
                        <a href="https://github.com/openpeer/ortc/issues/466">Issue 466</a>
                    </li>
                    <li>
                        Clarified handling of identity constraints, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/467">Issue 467</a> and
                        <a href="https://github.com/openpeer/ortc/issues/468">Issue 468</a>
                    </li>
                    <li>
                        Clarified use of <code>RTCRtpEncodingParameters</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/470">Issue 470</a>
                    </li>
                    <li>
                        Changed <var>hostCandidate</var> type, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/474">Issue 474</a>
                    </li>
                    <li>
                        Renamed state change event handlers to onstatechange, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/475">Issue 475</a>
                    </li>
                    <li>
                        Updated description of <code><a>RTCIceGatherer</a></code> <code>closed</code> state, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/476">Issue 476</a>
                    </li>
                    <li>
                        Updated description of <code><a>RTCIceTransport</a></code> object, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/477">Issue 477</a>
                    </li>
                    <li>
                        Updated description of <code>relatedPort</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/484">Issue 484</a>
                    </li>
                    <li>
                        Updated description of <code><a>RTCIceParameters</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/485">Issue 485</a>
                    </li>
                    <li>
                        Clarified exceptions in <code><a>RTCDataChannel</a></code> construction, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/492">Issue 492</a>
                    </li>
                    <li>
                        Provided a reference to <code>error.message</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/495">Issue 495</a>
                    </li>
                    <li>
                        Clarified <code><a>RTCRtpReceiver</a></code> description, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/496">Issue 496</a>
                    </li>
                    <li>
                        Clarified default for <code>clockRate</code> attribute, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/500">Issue 500</a>
                    </li>
                    <li>
                        Removed use of "null if unset", as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/503">Issue 503</a>
                    </li>
                    <li>
                        Updated <code><a>RTCSctpTransport</a></code> constructor, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/504">Issue 504</a>
                    </li>
                    <li>
                        Clarified behavior of <code>getCapabilities()</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/509">Issue 509</a>
                    </li>
                    <li>
                        Addressed issues with <code><a>RTCDataChannelParameters</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/519">Issue 519</a>
                    </li>
                </ol>
            </section>
            <section id="since-20-November-2015*">
                <h3>Changes since 20 November 2015</h3>
                <ol>
                    <li>
                        Clarified <code>unhandledrtp</code> event contents prior to calling <code>receive()</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/243">Issue 243</a>
                    </li>
                    <li>
                        Added support for <code>ptime</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/160">Issue 160</a>
                    </li>
                    <li>
                        Clarified behavior of <code>send()</code> when <var>encodings</var> is unset, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/187">Issue 187</a>
                    </li>
                    <li>
                        Fixed invalid import in examples, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/250">Issue 250</a>
                    </li>
                    <li>
                        Added support for Forward Error Correction (FEC), as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/253">Issue 253</a>
                    </li>
                    <li>
                        Added support for "V" bit in <code><a>RTCRtpContributingSource</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/263">Issue 263</a>
                    </li>
                    <li>
                        Added definition of <code>maxBitrate</code>, as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/issues/267">Issue 267</a>
                    </li>
                    <li>
                        Clarified definition of <code>audioLevel</code>, as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/issues/377">Issue 377</a>
                    </li>
                    <li>
                        Use USVString for <code>datachannel.send()</code>, as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/pull/387">PR 387</a>
                    </li>
                    <li>
                        Clarified requirements for DTMF A-D tone support, as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/issues/391">Issue 391</a>
                    </li>
                    <li>
                        Changed <code><a>RTCRtpContributingSource</a></code> from an interface to a dictionary, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/289">Issue 289</a>
                    </li>
                    <li>
                        Added support for <code>maxFramerate</code> encoding parameter, as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/issues/412">Issue 412</a>
                    </li>
                    <li>
                        Clarified behavior of <code>getRemoteCertificates()</code>, as noted in:
                        <a href="https://github.com/w3c/webrtc-pc/issues/378">Issue 378</a>
                    </li>
                    <li>
                        Added support for remote peer ICE-lite implementation, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/293">Issue 293</a>
                    </li>
                    <li>
                        Clarified <code><a>RTCDtlsTransportState</a></code> definition, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/294">Issue 294</a>
                    </li>
                    <li>
                        Added explanation for unset <code>iceServers</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/302">Issue 302</a>
                    </li>
                    <li>
                        Sync of certificate management API with WebRTC 1.0 changes, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/303">Issue 303</a>
                    </li>
                    <li>
                        Added "public" to <code><a>RTCIceGatherPolicy</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/305">Issue 305</a>
                    </li>
                    <li>
                        Fixed problems in Examples 6, 7, 22 and 24, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/310">Issue 310</a>
                    </li>
                    <li>
                        Clarified value of the <code>component</code> attribute, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/314">Issue 314</a>
                    </li>
                    <li>
                        Clarified behavior with multiple local or remote certificates, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/317">Issue 317</a>
                    </li>
                    <li>
                        Added <code>credentialType</code> attribute to Examples, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/323">Issue 323</a>
                    </li>
                    <li>
                        Clarified alert handling in <code><a>RTCDtlsTransportState</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/327">Issue 327</a>
                    </li>
                    <li>
                        Added example <code><a>RTCIceTransportState</a></code> transitions, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/332">Issue 332</a>
                    </li>
                    <li>
                        Clarified object garbage collection, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/338">Issue 338</a>
                    </li>
                    <li>
                        Fixed certificate example errors, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/340">Issue 340</a>
                    </li>
                    <li>
                        Clarified RTP matching rules, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/344">Issue 344</a>
                    </li>
                   <li>
                        Clarified value of <code>rtcpTransport</code> for BUNDLE and RTP/RTCP mux use, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/349">Issue 349</a>
                    </li>
                    <li>
                        Fixed markup issues in respec, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/345">Issue 345</a>
                    </li>
                    <li>
                        Addressed issues with document anchor links, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/353">Issue 353</a>
                    </li>
                    </li>
                    <li>
                        Clarified meaning of <var>active</var> for an <code><a>RTCRtpReceiver</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/355">Issue 355</a>
                    </li>
                    <li>
                        Updated <code><a>RTCDataChannel</a></code> event table, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/358">Issue 358</a>
                    </li>
                    <li>
                        Clarified behavior of <var>resolutionScale</var>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/362">Issue 362</a>
                    </li>
                    <li>
                        Updated RTP matching rules in Section 8.3 to support FEC/RTX/RED, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/368">Issue 368</a>
                    </li>
                    <li>
                        Clarified certificate checking behavior, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/372">Issue 372</a>
                    </li>
                    <li>
                        Clarified <code>encodingId</code> syntax, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/375">Issue 375</a>
                    </li>
                    <li>
                        Added <code>url</code> to <code>RTCIceGathererEvent</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/376">Issue 376</a>
                    </li>
                    <li>
                        Added <code>RangeError</code> for <var>resolutionScale</var> &lt;1.0, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/379">Issue 379</a>
                    </li>
                    <li>
                        Added clarification on level asymmetry, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/382">Issue 382</a>
                    </li>
                    <li>
                        Clarified DTMF tone requirements, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/384">Issue 384</a>
                    </li>
                    <li>
                        Clarified Generic NACK settings, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/395">Issue 395</a>
                    </li>
                </ol>
            </section>
            <section id="since-05-October-2015*">
                <h3>Changes since 05 October 2015</h3>
                <ol>
                    <li>
                        Added support for Opus capabilities and settings, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/252">Issue 252</a>
                    </li>
                    <li>
                        Added <code>payloadType</code> attribute to <code><a>RTCRtpRtxParameters</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/254">Issue 254</a>
                    </li>
                    <li>
                        Clarified meaning of unset <code>RTCRtpCodecCapability.clockRate</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/255">Issue 255</a>
                    </li>
                    <li>
                        Updated VP8 and H.264 capabilities and added VP8 and H.264 settings, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/258">Issue 258</a>
                    </li>
                    <li>
                        Added RTX codec parameters, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/259">Issue 259</a>
                    </li>
                    <li>
                        Added RED codec parameters, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/260">Issue 260</a>
                    </li>
                    <li>
                        Substituted <code>degradationPreference</code> for <code>framerateBias</code> and moved it to <code><a>RTCRtpParameters</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/262">Issue 262</a>
                    </li>
                    <li>
                        Added <a>RID</a> support to the <code><a>unhandledrtp</a></code> event, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/265">Issue 265</a>
                    </li>
                    <li>
                        Updated references, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/268">Issue 268</a>
                    </li>
                    <li>
                        Changed codec parameter and option names to camelCase, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/273">Issue 273</a>
                    </li>
                    <li>
                        Added section of codec options, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/274">Issue 274</a>
                    </li>
                    <li>
                        Clarified meaning of codec capabilities and options, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/275">Issue 275</a> and
                        <a href="https://github.com/openpeer/ortc/issues/277">Issue 277</a>
                    </li>
                    <li>
                        Clarified behavior in <code><a>RTCRtpSender</a></code> constructor and <code>setTrack()</code> when <code>track.readyState</code> is "ended", as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/278">Issue 278</a>
                    </li>
                 </ol>
            </section>
            <section id="since-22-June-2015*">
                <h3>Changes since 22 June 2015</h3>
                <ol>
                    <li>
                        Added support for the WebRTC 1.0 certificate management API, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/195">Issue 195</a>
                    </li>
                    <li>
                        Added certificate argument to the <code><a>RTCDtlsTransport</a></code> constructor, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/218">Issue 218</a>
                    </li>
                    <li>
                        Added the <code>failed</code> state to <code><a>RTCDtlsTransportState</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/219">Issue 219</a>
                    </li>
                    <li>
                        Changed <code>getNominatedCandidatePair</code> to <code>getSelectedCandidatePair</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/220">Issue 220</a>
                    </li>
                    <li>
                        Added support for WebRTC 1.0 <code><a>RTCIceCredentialType</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/222">Issue 222</a>
                    </li>
                    <li>
                        Clarified behavior of <code>createAssociatedGatherer()</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/223">Issue 223</a>
                    </li>
                    <li>
                        Changed spelling from "iceservers" to "iceServers" for consistency with WebRTC 1.0, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/225">Issue 225</a>
                    </li>
                    <li>
                        Added support for SCTP port numbers, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/227">Issue 227</a>
                    </li>
                    <li>
                        Changed "outbound-rtp" to "outboundrtp" within the Statistics API, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/229">Issue 229</a>
                    </li>
                    <li>
                        Changed <code>maxPacketLifetime</code> and <code>maxRetransmits</code> from unsigned short to unsigned long, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/231">Issue 231</a>
                    </li>
                    <li>
                        Clarified DataChannel negotiation, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/233">Issue 233</a>
                    </li>
                    <li>
                        Added <code>getContributingSources()</code> method, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/236">Issue 236</a>
                    </li>
                    <li>
                        Fixes to Examples 5 and 6, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/237">Issue 237</a> and
                        <a href="https://github.com/openpeer/ortc/issues/239">Issue 239</a>
                    </li>
                    <li>
                        Clarified behavior of <code>RTCDataChannel.send()</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/240">Issue 240</a>
                    </li>
                    <li>
                        Fixed typos in Example 11, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/241">Issue 241</a> and
                        <a href="https://github.com/openpeer/ortc/issues/248">Issue 248</a>
                    </li>
                    <li>
                        Added text relating to <code><a>RTCDataChannel</a></code> exceptions and errors, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/242">Issue 242</a>
                    </li>
                    <li>
                        Reconciliation of <code><a>RTCRtpEncodingParameters</a></code> dictionary with WebRTC 1.0, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/249">Issue 249</a>
                    </li>
                </ol>
            </section>
            <section id="since-07-May-2015*">
                <h3>Changes since 7 May 2015</h3>
                <ol>
                    <li>
                        Addressed Philipp Hancke's review comments, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/198">Issue 198</a>
                    </li>
                    <li>
                        Added the <code>failed</code> state to <code><a>RTCIceTransportState</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/199">Issue 199</a>
                    </li>

                    <li>
                        Added text relating to handling of incoming media packets prior to remote fingerprint verification, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/200">Issue 200</a>
                    </li>

                    <li>
                        Added a <code>complete</code> attribute to the <code><a>RTCIceCandidateComplete</a></code> dictionary, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/207">Issue 207</a>
                    </li>

                    <li>
                        Updated the description of <code>RTCIceGatherer.close()</code> and the <code>closed</code> state, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/208">Issue 208</a>
                    </li>

                    <li>
                        Updated Statistics API error handling to reflect proposed changes to the WebRTC 1.0 API, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/214">Issue 214</a>
                    </li>

                    <li>
                        Updated Section 10 (RTCDtmfSender) to reflect changes in the WebRTC 1.0 API, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/215">Issue 215</a>
                    </li>

                    <li>
                        Clarified state transitions due to consent failure, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/216">Issue 216</a>
                    </li>

                    <li>
                        Added a reference to [[FEC]], as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/217">Issue 217</a>
                    </li>
                </ol>
            </section>
            <section id="since-25-March-2015*">
                <h3>Changes since 25 March 2015</h3>
                <ol>
                    <li>
                        <code>sender.setTrack()</code> updated to return a Promise, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/148">Issue 148</a>
                    </li>
                    <li>
                        Added <code>RTCIceGatherer</code> as an optional argument to the <code>RTCIceTransport</code> constructor, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/174">Issue 174</a>
                    </li>
                    <li>
                        Clarified handling of contradictory RTP/RTCP multiplexing settings, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/185">Issue 185</a>
                    </li>
                    <li>
                        Clarified error handling relating to <code><a>RTCIceTransport</a></code>, <code><a>RTCDtlsTransport</a></code>
                        and <code><a>RTCIceGatherer</a></code> objects in the <code>closed</code> state, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/186">Issue 186</a>
                    </li>
                    <li>
                        Added <code>component</code> attribute and <code>createAssociatedGatherer()</code> method to
                        the <code><a>RTCIceGatherer</a></code> object, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/188">Issue 188</a>
                    </li>
                    <li>
                        Added <code>close()</code> method to the <code><a>RTCIceGatherer</a></code> object as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/189">Issue 189</a>
                    </li>
                    <li>
                        Clarified behavior of TCP candidate types, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/190">Issue 190</a>
                    </li>
                    <li>
                        Clarified behavior of <code>iceGatherer.onlocalcandidate</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/191">Issue 191</a>
                    </li>
                    <li>
                        Updated terminology in Section 1.1 as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/193">Issue 193</a>
                    </li>
                    <li>
                        Updated <code><a>RTCDtlsTransportState</a></code> definitions, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/194">Issue 194</a>
                    </li>
                    <li>
                        Updated <code><a>RTCIceTransportState</a></code> definitions, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/197">Issue 197</a>
                    </li>
                </ol>
            </section>
            <section id="since-22-January-2015*">
                <h3>Changes since 22 January 2015</h3>
                <ol>
                    <li>
                        Updated Section 8.3 on RTP matching rules, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/48">Issue 48</a>
                    </li>
                    <li>
                        Further updates to the Statistics API, reflecting:
                        <a href="https://github.com/openpeer/ortc/issues/85">Issue 85</a>
                    </li>
                    <li>
                        Added support for <code>maxptime</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/160">Issue 160</a>
                    </li>
                    <li>
                        Revised the text relating to <code>RTCDtlsTransport.start()</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/168">Issue 168</a>
                    </li>
                    <li>
                        Clarified pre-requisites for <code>insertDTMF()</code>, based on:
                        <a href="https://github.com/openpeer/ortc/issues/178">Issue 178</a>
                    </li>
                    <li>
                        Added Section 13.4 and updated Section 9.5.1 to clarify aspects of RTCP sending and receiving, based on:
                        <a href="https://github.com/openpeer/ortc/issues/180">Issue 180</a>
                    </li>
                    <li>
                        Fixed miscellaneous typos, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/183">Issue 183</a>
                    </li>
                    <li>
                        Added informative reference to [[RFC3264]] Section 5.1, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/184">Issue 184</a>
                    </li>
                </ol>
            </section>
            <section id="since-14-October-2014*">
                <h3>Changes since 14 October 2014</h3>
                <ol>
                    <li>
                        Update to the Statistics API, reflecting:
                        <a href="https://github.com/openpeer/ortc/issues/85">Issue 85</a>
                    </li>
                    <li>
                        Update on 'automatic' use of scalable video coding, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/156">Issue 156</a>
                    </li>
                    <li>
                        Update to the H.264 parameters, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/158">Issue 158</a>
                    </li>
                    <li>
                        Update to the 'Big Picture', as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/159">Issue 159</a>
                    </li>
                    <li>
                        Changed 'RTCIceTransportEvent' to 'RTCIceGathererEvent' as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/161">Issue 161</a>
                    </li>
                    <li>
                        Update to <code>RTCRtpUnhandledEvent</code> as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/163">Issue 163</a>
                    </li>
                    <li>
                        Added support for <code>RTCIceGatherer.state</code> as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/164">Issue 164</a>
                    </li>
                    <li>
                        Revised the text relating to <code>RTCIceTransport.start()</code> as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/166">Issue 166</a>
                    </li>
                    <li>
                        Added text relating to DTLS interoperability with WebRTC 1.0, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/167">Issue 167</a>
                    </li>
                    <li>
                        Added a reference to the ICE consent specification, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/171">Issue 171</a>
                    </li>
                </ol>
            </section>
            <section id="since-20-August-2014*">
                <h3>Changes since 20 August 2014</h3>
                <ol>
                    <li>
                        Address questions about <code>RTCDtlsTransport.start()</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/146">Issue 146</a>
                    </li>
                    <li>
                        Address questions about <code>RTCRtpCodecCapability.preferredPayloadType</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/147">Issue 147</a>
                    </li>
                    <li>
                        Address questions about <code>RTCRtpSender.setTrack()</code> error handling, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/148">Issue 148</a>
                    </li>
                    <li>
                        Address 'automatic' use of scalable video coding (in <code>RTCRtpReceiver.receive()</code>) as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/149">Issue 149</a>
                    </li>
                    <li>
                        Renamed RTCIceListener to <code><a>RTCIceGatherer</a></code> as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/150">Issue 150</a>
                    </li>
                    <li>
                        Added text on multiplexing of STUN, TURN, DTLS and RTP/RTCP, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/151">Issue 151</a>
                    </li>
                    <li>
                        Address issue with queueing of candidate events within the <code><a>RTCIceGatherer</a></code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/152">Issue 152</a>
                    </li>
                    <li>
                        Clarify behavior of <code>RTCRtpReceiver.getCapabilities(kind)</code>, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/153">Issue 153</a>
                    </li>
                </ol>
            </section>
            <section id="since-16-July-2014*">
                <h3>Changes since 16 July 2014</h3>
                <ol>
                    <li>
                        Clarification of the ICE restart issue, as noted in :
                        <a href="https://github.com/openpeer/ortc/issues/93">Issue 93</a>
                    </li>
                    <li>
                        Clarified onerror usage in sender and receiver objects, as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/95">Issue 95</a>
                    </li>
                    <li>
                        Clarified SST-MS capability issue noted in:
                        <a href="https://github.com/openpeer/ortc/issues/108">Issue 108</a>
                    </li>
                    <li>
                        Clarification of <code>send()</code> and <code>receive()</code> usage as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/119">Issue 119</a>
                    </li>
                    <li>
                        Changed ICE state diagram as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/122">Issue 122</a>
                    </li>
                    <li>
                        Removed getParameters methods and changed send() method as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/136">Issue 136</a>
                    </li>
                    <li>
                        Changed definition of framerateScale and resolutionScale as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/137">Issue 137</a>
                    </li>
                    <li>
                        Substituted <code>muxId</code> for <code>receiverId</code> as noted in:
                        <a href="https://github.com/openpeer/ortc/issues/138">Issue 138</a> and
                        <a href="https://github.com/openpeer/ortc/issues/140">Issue 140</a>
                    </li>
                    <li>
                        Clarified the setting of <code>track.kind</code> as described in:
                        <a href="https://github.com/openpeer/ortc/issues/141">Issue 141</a>
                    </li>
                    <li>
                        Added SSRC conflict event to the <code><a>RTCRtpSender</a></code>, as described in:
                        <a href="https://github.com/openpeer/ortc/issues/143">Issue 143</a>
                    </li>
                    <li>
                        Addressed the "end of candidates" issues noted in:
                        <a href="https://github.com/openpeer/ortc/issues/142">Issue 142</a> and
                        <a href="https://github.com/openpeer/ortc/issues/144">Issue 144</a>
                    </li>
                </ol>
            </section>
            <section id="since-16-June-2014*">
                <h3>Changes since 16 June 2014</h3>
                <ol>
                    <li>
                        Added section on WebRTC 1.0 compatibility issues, responding to
                        <a href="https://github.com/openpeer/ortc/issues/66">Issue 66</a>
                    </li>
                    <li>
                        Added Identity support, as described in
                        <a href="https://github.com/openpeer/ortc/issues/78">Issue 78</a>
                    </li>
                    <li>
                        Reworked <code>getStats()</code> method, as described in
                        <a href="https://github.com/openpeer/ortc/issues/85">Issue 85</a>
                    </li>
                    <li>
                        Removed ICE restart method described in
                        <a href="https://github.com/openpeer/ortc/issues/93">Issue 93</a>
                    </li>
                    <li>
                        Addressed CNAME and synchronization context issues described in
                        <a href="https://github.com/openpeer/ortc/issues/94">Issue 94</a>
                    </li>
                    <li>
                        Fixed WebIDL issues noted in
                        <a href="https://github.com/openpeer/ortc/issues/97">Issue 97</a>
                    </li>
                    <li>
                        Addressed NITs described in
                        <a href="https://github.com/openpeer/ortc/issues/99">Issue 99</a>
                    </li>
                    <li>
                        DTLS transport issues fixed as described in
                        <a href="https://github.com/openpeer/ortc/issues/100">Issue 100</a>
                    </li>
                    <li>
                        ICE transport issues fixed as described in
                        <a href="https://github.com/openpeer/ortc/issues/101">Issue 101</a>
                    </li>
                    <li>
                        ICE transport controller fixes made as described in
                        <a href="https://github.com/openpeer/ortc/issues/102">Issue 102</a>
                    </li>
                    <li>
                        Sender and Receiver object fixes made as described in
                        <a href="https://github.com/openpeer/ortc/issues/103">Issue 103</a>
                    </li>
                    <li>
                        Fixed <code><a>RTCRtpEncodingParameters</a></code> default issues described in
                        <a href="https://github.com/openpeer/ortc/issues/104">Issue 104</a>
                    </li>
                    <li>
                        Fixed 'Big Picture' issues descibed in
                        <a href="https://github.com/openpeer/ortc/issues/105">Issue 105</a>
                    </li>
                    <li>
                        Fixed <code><a>RTCRtpParameters</a></code> default issues described in
                        <a href="https://github.com/openpeer/ortc/issues/106">Issue 106</a>
                    </li>
                    <li>
                        Added a multi-stream capability, as noted in
                        <a href="https://github.com/openpeer/ortc/issues/108">Issue 108</a>
                    </li>
                    <li>
                        Removed quality scalability capabilities and parameters, as described in
                        <a href="https://github.com/openpeer/ortc/issues/109">Issue 109</a>
                    </li>
                    <li>
                        Added scalability examples as requested in
                        <a href="https://github.com/openpeer/ortc/issues/110">Issue 110</a>
                    </li>
                    <li>
                        Addressed WebRTC 1.0 Data Channel compatibility issue described in
                        <a href="https://github.com/openpeer/ortc/issues/111">Issue 111</a>
                    </li>
                    <li>
                        Removed header extensions from <code><a>RTCRtpCodecParameters</a></code> as described in
                        <a href="https://github.com/openpeer/ortc/issues/113">Issue 113</a>
                    </li>
                    <li>
                        Addressed RTP/RTCP non-mux issues with IdP as described in
                        <a href="https://github.com/openpeer/ortc/issues/114">Issue 114</a>
                    </li>
                    <li>
                        Added getParameter methods to <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects, as described in
                        <a href="https://github.com/openpeer/ortc/issues/116">Issue 116</a>
                    </li>
                    <li>
                        Added layering diagrams as requested in
                        <a href="https://github.com/openpeer/ortc/issues/117">Issue 117</a>
                    </li>
                    <li>
                        Added a typedef for <code>payloadtype</code>, as described in
                        <a href="https://github.com/openpeer/ortc/issues/118">Issue 118</a>
                    </li>
                    <li>
                        Moved <code>onerror</code> from the <code><a>RTCIceTransport</a></code> object to the <code>RTCIceListener</code> object as described in
                        <a href="https://github.com/openpeer/ortc/issues/121">Issue 121</a>
                    </li>
                    <li>
                        Added explanation of Voice Activity Detection (VAD), responding to
                        <a href="https://github.com/openpeer/ortc/issues/129">Issue 129</a>
                    </li>
                    <li>
                        Clarified the meaning of <code>maxTemporalLayers</code> and <code>maxSpatialLayers</code>, as noted in
                        <a href="https://github.com/openpeer/ortc/issues/130">Issue 130</a>
                    </li>
                    <li>
                        Added [[!RFC6051]] to the list of header extensions and removed RFC 5450, as noted in
                        <a href="https://github.com/openpeer/ortc/issues/131">Issue 131</a>
                    </li>
                    <li>
                        Addressed ICE terminology issues, as described in
                        <a href="https://github.com/openpeer/ortc/issues/132">Issue 132</a>
                    </li>
                    <li>
                        Separated references into Normative and Informative, as noted in
                        <a href="https://github.com/openpeer/ortc/issues/133">Issue 133</a>
                    </li>
                </ol>
            </section>
            <section id="since-14-May-2014*">
                <h3>Changes since 14 May 2014</h3>
                <ol>
                    <li> Added support for non-multiplexed RTP/RTCP and ICE freezing, as described in
                        <a href="https://github.com/openpeer/ortc/issues/57">Issue 57</a>
                    </li>
                    <li>
                        Added support for <code>getRemoteCertificates()</code>, as described in
                        <a href="https://github.com/openpeer/ortc/issues/67">Issue 67</a>
                    </li>
                    <li>
                        Removed <code>filterParameters()</code> and <code>createParameters()</code> methods, as described in
                        <a href="https://github.com/openpeer/ortc/issues/80">Issue 80</a>
                    </li>
                    <li>
                        Partially addressed capabilities issues, as described in
                        <a href="https://github.com/openpeer/ortc/issues/84">Issue 84</a>
                    </li>
                    <li>
                        Addressed WebIDL type issues described in
                        <a href="https://github.com/openpeer/ortc/issues/88">Issue 88</a>
                    </li>
                    <li>
                        Addressed Overview section issues described in
                        <a href="https://github.com/openpeer/ortc/issues/91">Issue 91</a>
                    </li>
                    <li>
                        Addressed readonly attribute issues described in
                        <a href="https://github.com/openpeer/ortc/issues/92">Issue 92</a>
                    </li>
                    <li>
                        Added ICE restart method to address the issue described in
                        <a href="https://github.com/openpeer/ortc/issues/93">Issue 93</a>
                    </li>
                    <li>
                        Added onerror eventhandler to sender and receiver objects as described in
                        <a href="https://github.com/openpeer/ortc/issues/95">Issue 95</a>
                    </li>
                </ol>
            </section>
            <section id="since-29-April-2014*">
                <h3>Changes since 29 April 2014</h3>
                <ol>
                    <li> ICE restart explanation added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/59">Issue 59</a>
                    </li>
                    <li>
                        Fixes for error handling, as described in
                        <a href="https://github.com/openpeer/ortc/issues/75">Issue 75</a>
                    </li>
                    <li>
                        Fixes for miscellaneous NITs, as described in
                        <a href="https://github.com/openpeer/ortc/issues/76">Issue 76</a>
                    </li>
                    <li>
                        Enable retrieval of the SSRC to be used by RTCP, as described in
                        <a href="https://github.com/openpeer/ortc/issues/77">Issue 77</a>
                    </li>
                    <li>
                        Support for retrieval of audio and video capabilities, as described in
                        <a href="https://github.com/openpeer/ortc/issues/81">Issue 81</a>
                    </li>
                    <li>
                        getStats interface updated, as described in
                        <a href="https://github.com/openpeer/ortc/issues/82">Issue 82</a>
                    </li>
                    <li>
                        Partially addressed SVC issues described in
                        <a href="https://github.com/openpeer/ortc/issues/83">Issue 83</a>
                    </li>
                    <li> Partially addressed statistics update issues described in
                        <a href="https://github.com/openpeer/ortc/issues/85">Issue 85</a>
                    </li>
                </ol>
            </section>
            <section id="since-12-April-2014*">
                <h3>Changes since 12 April 2014</h3>
                <ol>
                    <li> Fixes for error handling, as described in
                        <a href="https://github.com/openpeer/ortc/issues/26">Issue 26</a>
                    </li>
                    <li>
                        Support for contributing sources removed (re-classified as a 1.2 feature), as described in
                        <a href="https://github.com/openpeer/ortc/issues/27">Issue 27</a>
                    </li>
                    <li>
                        Cleanup of DataChannel construction, as described in
                        <a href="https://github.com/openpeer/ortc/issues/60">Issue 60</a>
                    </li>
                    <li>
                        Separate proposal on simulcast/layering, as described in
                        <a href="https://github.com/openpeer/ortc/issues/61">Issue 61</a>
                    </li>
                    <li>
                        Separate proposal on quality, as described in
                        <a href="https://github.com/openpeer/ortc/issues/62">Issue 62</a>
                    </li>
                    <li>
                        Fix for TCP candidate type, as described in
                        <a href="https://github.com/openpeer/ortc/issues/63">Issue 63</a>
                    </li>
                    <li>
                        Fix to the fingerprint attribute, as described in
                        <a href="https://github.com/openpeer/ortc/issues/64">Issue 64</a>
                    </li>
                    <li>
                        Fix to RTCRtpFeatures, as described in
                        <a href="https://github.com/openpeer/ortc/issues/65">Issue 65</a>
                    </li>
                    <li>
                        Support for retrieval of remote certificates, as described in
                        <a href="https://github.com/openpeer/ortc/issues/67">Issue 67</a>
                    </li>
                    <li>
                        Support for ICE error handling, described in
                        <a href="https://github.com/openpeer/ortc/issues/68">Issue 68</a>
                    </li>
                    <li>
                        Support for Data Channel send rate control, as described in
                        <a href="https://github.com/openpeer/ortc/issues/69">Issue 69</a>
                    </li>
                    <li>
                        Support for capabilities and settings, as described in
                        <a href="https://github.com/openpeer/ortc/issues/70">Issue 70</a>
                    </li>
                    <li>
                        Removal of duplicate RTCIceListener functionality, as described in
                        <a href="https://github.com/openpeer/ortc/issues/71">Issue 71</a>
                    </li>
                    <li>
                        ICE gathering state added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/72">Issue 72</a>
                    </li>
                    <li>
                        Removed ICE role from the ICE transport constructor, as described in
                        <a href="https://github.com/openpeer/ortc/issues/73">Issue 73</a>
                    </li>
                </ol>
            </section>
            <section id="since-13-February-2014*">
                <h3>Changes since 13 February 2014</h3>
                <ol>
                    <li>
                        Support for contributing source information added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/27">Issue 27</a>
                    </li>
                    <li>
                        Support for control of quality, resolution, framerate and layering added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/31">Issue 31</a>
                    </li>
                    <li>
                        <code><a>RTCRtpListener</a></code> object added and figure in Section 1 updated, as described in
                        <a href="https://github.com/openpeer/ortc/issues/32">Issue 32</a>
                    </li>
                    <li>
                        More complete support for RTP and Codec Parameters added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/33">Issue 33</a>
                    </li>
                    <li>
                        Data Channel transport problem fixed, as described in
                        <a href="https://github.com/openpeer/ortc/issues/34">Issue 34</a>
                    </li>
                    <li>
                        Various NITs fixed, as described in
                        <a href="https://github.com/openpeer/ortc/issues/37">Issue 37</a>
                    </li>
                    <li>
                        <code><a>RTCDtlsTransport</a></code> operation and interface definition updates, as described in:
                        <a href="https://github.com/openpeer/ortc/issues/38">Issue 38</a>
                    </li>
                    <li>
                        Default values of some dictionary attributes added, to partially address the issue described in:
                        <a href="https://github.com/openpeer/ortc/issues/39">Issue 39</a>
                    </li>
                    <li>
                        Support for ICE TCP added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/41">Issue 41</a>
                    </li>
                    <li>
                        Fixed issue with sequences as attributes, as described in
                        <a href="https://github.com/openpeer/ortc/issues/43">Issue 43</a>
                    </li>
                    <li>
                        Fix for issues with onlocalcandidate, as described in
                        <a href="https://github.com/openpeer/ortc/issues/44">Issue 44</a>
                    </li>
                    <li>
                        Initial stab at a Stats API, as requested in
                        <a href="https://github.com/openpeer/ortc/issues/46">Issue 46</a>
                    </li>
                    <li>
                        Added support for ICE gather policy, as described in
                        <a href="https://github.com/openpeer/ortc/issues/47">Issue 47</a>
                    </li>
                </ol>
            </section>
            <section id="since-07-November-2013*">
                <h3>Changes since 07 November 2013</h3>
                <ol>
                    <li>
                        RTCTrack split into <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects, as proposed on
                        <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0000.html"> 06 January 2014.</a>
                    </li>
                    <li>
                        RTCConnection split into <code><a>RTCIceTransport</a></code> and <code><a>RTCDtlsTransport</a></code> objects, as proposed on
                        <a href="http://lists.w3.org/Archives/Public/public-orca/2014Jan/0005.html"> 09 January 2014. </a>
                    </li>
                    <li>
                        <code><a>RTCSctpTransport</a></code> object added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/25">Issue 25</a>
                    </li>
                    <li>
                        RTCRtpHeaderExtensionParameters added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/28">Issue 28</a>
                    </li>
                    <li>
                        RTCIceListener added, in order to support parallel forking, as described in
                        <a href="https://github.com/openpeer/ortc/issues/29">Issue 29</a>
                    </li>
                    <li>
                        DTMF support added, as described in
                        <a href="https://github.com/openpeer/ortc/issues/30">Issue 30</a>
                    </li>
                </ol>
            </section>
        </section>
    </body>
</html>
