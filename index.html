<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux/x86 version 5.3.9">
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>Object RTC (ORTC) API for WebRTC</title>
  <script class="remove" src="respec-w3c-common.js" type="text/javascript"></script>
  <script src="respec-config.js" class="remove"></script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow media to be sent
    and received from another browser or device implementing the appropriate set of
    real-time protocols. However, unlike the WebRTC 1.0 API, Object Real-Time
    Communications (ORTC) does not utilize Session Description Protocol (SDP) in the API,
    nor does it mandate support for the Offer/Answer state machine (though an application
    is free to choose SDP and Offer/Answer as an on-the-wire signaling mechanism).
    Instead, ORTC uses "sender", "receiver" and "transport" objects, which have
    "capabilities" describing what they are capable of doing, as well as "parameters"
    which define what they are configured to do. "Tracks" are encoded by senders and sent
    over transports, then decoded by receivers while "data channels" are sent over
    transports directly.</p>
  </section>
  <section id="sotd"></section>
  <section id="overview*">
    <h2>Overview</h2>
    <p>Object Real-Time Communications (ORTC) provides a powerful API for the development
    of WebRTC based applications. ORTC does not utilize Session Description Protocol
    (SDP) in the API, nor does it mandate support for the Offer/Answer state machine
    (though an application is free to choose SDP and Offer/Answer as an on-the-wire
    signaling mechanism). Instead, ORTC uses "sender", "receiver" and "transport"
    objects, which have "capabilities" describing what they are capable of doing, as well
    as "parameters" which define what they are configured to do. "Tracks" are encoded by
    senders and sent over transports, then decoded by receivers while "data channels" are
    sent over transports directly.</p>
    <p>In a Javascript application utilizing the ORTC API, the relationship between the
    application and the objects, as well as between the objects themselves is shown
    below. Horizontal or slanted arrows denote the flow of media or data, whereas
    vertical arrows denote interactions via methods and events.</p>
    <figure>
      <img alt="The non-normative ORTC Big Picture Diagram" src=
      "images/quic.svg" style="width:100%">
      <figcaption>
        Non-normative ORTC Big Picture Diagram
      </figcaption>
    </figure>
    <p>In the figure above, the <code><a>RTCRtpSender</a></code> (<a href=
    "#rtcrtpsender*">Section 5</a>) encodes the track provided as input, which is
    transported over a <code><a>RTCDtlsTransport</a></code> (<a href=
    "#rtcdtlstransport*">Section 4</a>). An <code><a>RTCDataChannel</a></code> (<a href=
    "#rtcdatachannel*">Section 11</a>) utilizes an <code><a>RTCSctpTransport</a></code>
    (<a href="#sctp-transport*">Section 12</a>) which can also be multiplexed over the
    <code><a>RTCDtlsTransport</a></code>. Sending of Dual Tone Multi Frequency (DTMF)
    tones is supported via the <code><a>RTCDtmfSender</a></code> (<a href=
    "#rtcdtmfsender*">Section 10</a>).</p>
    <p>The <code><a>RTCDtlsTransport</a></code> utilizes an
    <code><a>RTCIceTransport</a></code> (<a href="#rtcicetransport*">Section 3</a>) to
    select a communication path to reach the receiving peer's
    <code><a>RTCIceTransport</a></code>, which is in turn associated with an
    <code><a>RTCDtlsTransport</a></code> which de-multiplexes media to the
    <code><a>RTCRtpReceiver</a></code> (<a href="#rtcrtpreceiver*">Section 6</a>) and
    data to the <code><a>RTCSctpTransport</a></code> and
    <code><a>RTCDataChannel</a></code>. The <code><a>RTCRtpReceiver</a></code> then
    decodes media, producing a track which is rendered by an audio or video tag.</p>
    <p>Several other objects also play a role. The <code><a>RTCIceGatherer</a></code>
    (<a href="#rtcicegatherer*">Section 2</a>) gathers local ICE candidates for use by
    one or more <code><a>RTCIceTransport</a></code> objects, enabling forking scenarios.
    The <code><a>RTCIceTransportController</a></code> (<a href=
    "#rtcicetransportcontroller*">Section 7</a>) manages freezing/unfreezing (defined in
    [[!RFC5245]]) and bandwidth estimation. The <code><a>RTCRtpListener</a></code>
    (<a href="#rtcrtplistener*">Section 8</a>) detects whether an RTP stream is received
    that cannot be delivered to any existing <code><a>RTCRtpReceiver</a></code>,
    providing an <code>onunhandledrtp</code> event handler that the application can use
    to correct the situation. The <code><a>RTCQuicTransport</a></code> utilizes an
    <code><a>RTCIceTransport</a></code> to select a communication path to reach the
    receiving peer's <code><a>RTCIceTransport</a></code>, which is in turn associated
    with an <code><a>RTCQuicTransport</a></code>.  An <code><a>RTCQuicTransport</a></code>
    is associated with zero or more <code><a>RTCQuicStream</a></code> objects which
    read data from and write data to <code><a>RTCQuicStream</a></code> objects on the
    remote peer.</p>
    <p>Remaining sections of the specification fill in details relating to RTP
    capabilities and parameters, operational statistics, media authentication via
    Certificates and Identity Providers (IdP) and compatibility with the WebRTC 1.0 API.
    RTP dictionaries are described in <a href="#rtcrtpdictionaries*">Section 9</a>, the
    Statistics API is described in <a href="#statistics-api">Section 13</a>, the Identity
    API is described in <a href="#identity-api">Section 14</a>, the Certificate API is
    described in <a href="#certificate-api">Section 15</a>, privacy and security
    considerations are described in <a href="#privacy-security">Section 16</a>,
    an event summary is provided
    in <a href="#event-summary">Section 17</a>, WebRTC 1.0 compatibility issues are
    discussed in <a href="#webrtc-compat*">Section 18</a>, and complete examples are
    provided in <a href="#examples*">Section 19</a>.</p>
    <section id="conformance">
      <p>This specification defines conformance criteria that apply to a single
      product: the <a>user agent</a> that implements the interfaces that it
      contains.</p>
      <p>Conformance requirements phrased as algorithms or specific steps may be
      implemented in any manner, so long as the end result is equivalent. In
      particular, the algorithms defined in this specification are intended to be
      easy to follow, and not intended to be performant.</p>
      <p>Implementations that use ECMAScript to implement the APIs defined in
      this specification MUST implement them in a manner consistent with the
      ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
      this specification uses that specification and terminology.</p>
      <p>Implementation of the following interfaces is mandatory:
      <code><a>RTCIceGatherer</a></code> (<a href="#rtcicegatherer*">Section 2</a>),
      <code><a>RTCIceTransport</a></code> (<a href="#rtcicetransport*">Section 3</a>),
      <code><a>RTCDtlsTransport</a></code> (<a href="#rtcdtlstransport*">Section 4</a>),
      <code><a>RTCRtpSender</a></code> (<a href="#rtcrtpsender*">Section 5</a>),
      <code><a>RTCRtpReceiver</a></code> (<a href="#rtcrtpreceiver*">Section 6</a>),
      <code><a>RTCDtmfSender</a></code> (<a href="#rtcdtmfsender*">Section 10</a>),
      <code><a>RTCDataChannel</a></code> (<a href="#rtcdatachannel*">Section 11</a>),
      <code><a>RTCSctpTransport</a></code> (<a href="#sctp-transport*">Section 12</a>) and
      <code><a>RTCCertificate</a></code> (<a href="#certificate-api">Section 15</a>).
      Since the <code>send</code> and <code>receive</code> methods are
      mandatory-to-implement, the RTP dictionaries
      (<a href="#rtcrtpdictionaries*">Section 9</a>) that these methods depend on are also
      mandatory-to-implement.  Mandatory-to-implement statistics are described in
      <a href="#mandatory-to-implement-stats">Section 13.3</a>.</p>
      <p>Implementation of the following interfaces is optional:
      <code><a>RTCIceTransportController</a></code>
      (<a href="#rtcicetransportcontroller*">Section 7</a>),
      <code><a>RTCRtpListener</a></code> (<a href="#rtcrtplistener*">Section 8</a>),
      <code><a>RTCQuicTransport</a></code>,  
      <code><a>RTCQuicStream</a></code> and
      <code><a>RTCIdentity</a></code> (<a href="#identity-api">Section 14</a>).</p>
    </section>
    <section>
      <h3>Terminology</h3>
      <p>The <code><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
      interface, representing a callback used for event handlers, and the <a href=
      "http://dev.w3.org/html5/spec/webappapis.html#errorevent">
      <code><dfn>ErrorEvent</dfn></code></a>
      interface are defined in [[!HTML5]].</p>
      <p>The concepts <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a></dfn>,
      <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a simple
      event</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking
      task source</a></dfn> are defined in [[!HTML5]].</p>
      <p>The terms <dfn>event</dfn>, <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
      handlers</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
      handler event types</a></dfn> are defined in [[!HTML5]].</p>
      <p>The terms <dfn>MediaStream</dfn>, <dfn>MediaStreamTrack</dfn>, and
      <dfn>MediaStreamConstraints</dfn> are defined in [[!GETUSERMEDIA]].</p>
      <p>The term <code><a>RTCStatsType</a></code>
      is defined in [[!WEBRTC-STATS]].</p>
      <p>When referring to exceptions, the terms <dfn><a
      href="https://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a></dfn> and
      <dfn data-dfn-for="exception"><a href=
      "https://www.w3.org/TR/WebIDL-1/#dfn-create-exception">create</a></dfn> are
      defined in [[!WEBIDL]].</p>
      <p>The terms <dfn data-lt="fulfill|fulfillment">fulfilled</dfn>, <dfn
      data-lt="reject|rejection|rejecting">rejected</dfn>,
      <dfn data-lt="resolve|resolves">resolved</dfn>, <dfn>pending</dfn> and
      <dfn>settled</dfn> used in the context of Promises are defined in
      [[!ECMASCRIPT-6.0]].</p>
      <p>The terms <dfn>isolated stream</dfn>,
      <dfn>peeridentity</dfn>, <dfn>request an identity assertion</dfn> and
      <dfn>validate the identity</dfn> are defined in [[!WEBRTC-IDENTITY]].</p>
      <p>In this specification the term <dfn>user agent</dfn> refers to any
      implementation; the term <dfn>browser</dfn> specifically refers to browser
      implementations.</p>
      <p>The <dfn>RTCIceCredentialType</dfn> enum is defined in [[!WEBRTC10]]
      Section 4.2.2 and the <dfn>RTCOauthCredential</dfn>
      dictionary is defined in [[!WEBRTC10]] Section 4.2.3.</p> 
      <p>The <dfn>RTCQuicTransport</dfn> interface is defined in [[WEBRTC-QUIC]] Section 4
      and the <dfn>RTCQuicStream</dfn> interface is defined in [[WEBRTC-QUIC]]
      Section 5.</p>
      <p>The <dfn>RTCIdentityProvider</dfn> dictionary and the
      <dfn>generateAssertion</dfn> and <dfn>validateAssertion</dfn> callbacks are
      defined in [[WEBRTC-IDENTITY]] Section 5.1. The <dfn>RTCIdentityAssertionResult</dfn>,
      <dfn>RTCIdentityProviderDetails</dfn> and <dfn>RTCIdentityValidationResult</dfn>
      dictionaries are defined in [[WEBRTC-IDENTITY]] Section 5.2. The
      <dfn>RTCIdentityProviderOptions</dfn> dictionary and the
      <dfn>RTCIdentityAssertion</dfn> interface are defined in
      [[WEBRTC-IDENTITY]] Section 9.</p>
    </section>
    <section>
      <h3>Scope</h3>
      <p>For Scalable Video Coding (SVC), the terms single-session transmission
      (<dfn>SST</dfn>) and multi-session transmission (<dfn>MST</dfn>) are defined in
      [[RFC6190]]. This specification only supports <a>SST</a> but not <a>MST</a>. The
      term Single Real-time transport protocol stream Single Transport (<dfn>SRST</dfn>),
      defined in [[RFC7656]] Section 3.7, refers to a Scalable Video Coding
      (<dfn>SVC</dfn>) implementation that transmits all layers within
      a single transport, using a single Real-time Transport Protocol (RTP) stream
      and synchronization source (SSRC). The term Multiple RTP stream Single Transport
      (<dfn>MRST</dfn>), also defined in [[RFC7656]] Section 3.7, refers to an
      implementation that transmits all layers within a single transport, using
      multiple RTP streams with a distinct SSRC for each layer. This specification
      supports SVC codecs that can only utilize <a>SRST</a> transport (such as VP8,
      VP9 and AV1) as well as implementations of codecs (such as H.264/SVC or HEVC)
      that support <a>SRST</a> transport. Also, sending of simulcast is supported.
      Implementations supporting <a>MRST</a> transport (such as H.264/SVC)
      can also be supported, along with reception of simulcast. However, these
      features should be considered experimental, since implementation
      experience is limited.</p>
      <div class="note">
        At the time of publication, there were two ORTC implementations supporting
        simulcast reception. Since neither implementation supported [[!RFC6051]],
        mechanisms needed to be provided to handle intermingling of received simulcast
        streams due to reordering. The ORTC Lib implementation deals with this by
        utilizing timing heuristics as well as "hidden" receivers for each received
        simulcast stream, with each "hidden" receiver producing a "hidden" track. The
        "hidden" tracks are then mixed internally to produce a single
        <code><a>MediaStreamTrack</a></code> <code><a>RTCRtpReceiver</a>.track</code>.
      </div>
    </section>
  </section>
  <section id="rtcicegatherer*">
    <h2><dfn>RTCIceGatherer</dfn> Interface</h2>
    <p>The <code>RTCIceGatherer</code> gathers local host, server reflexive
    and relay candidates, as well as enabling the retrieval of local Interactive
    Connectivity Establishment (ICE) parameters which can be exchanged in signaling. By
    enabling an endpoint to use a set of local candidates to construct multiple
    <code><a>RTCIceTransport</a></code> objects, the <code><a>RTCIceGatherer</a></code>
    enables support for scenarios such as parallel forking.</p>
    <section id="rtcicegatherer-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCIceGatherer</a></code> instance can be associated to multiple
      <code><a>RTCIceTransport</a></code> objects. The <code><a>RTCIceGatherer</a></code>
      does not prune local candidates until at least one
      <code><a>RTCIceTransport</a></code> object has become associated and all associated
      <code><a>RTCIceTransport</a></code> objects are in the <code>completed</code> or
      <code>failed</code> state.</p>
      <p>As noted in [[!RFC5245]] Section 7.1.2.2, an incoming connectivity check
      contains an <code>ICE-CONTROLLING</code> or <code>ICE-CONTROLLED</code> attribute,
      depending on the role of the ICE agent initiating the check. Since an
      <code><a>RTCIceGatherer</a></code> object does not have a role, it cannot determine
      whether to respond to an incoming connectivity check with a 487 (Role Conflict)
      error; however, it can validate that an incoming connectivity check utilizes the
      correct local username fragment and password, and if not, can respond with an 401
      (Unauthorized) error, as described in [[!RFC5389]] Section 10.1.2.</p>
      <p>For incoming connectivity checks that pass validation, the
      <code><a>RTCIceGatherer</a></code> <em class="rfc2119" title="MUST">MUST</em>
      buffer the incoming connectivity checks so as to be able to provide them to
      associated <code><a>RTCIceTransport</a></code> objects so that they can
      respond.</p>
    </section>
    <section id="rtcicegatherer-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCIceGatherer</a></code> instance is constructed from an
      <code><a>RTCIceGatherOptions</a></code> object.</p>
      <p>An <code><a>RTCIceGatherer</a></code> object in the <code>closed</code> state
      can be garbage-collected when it is no longer referenced.</p>
    </section>
    <section id="rtcicegatherer-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
<pre class="idl">[ Constructor (RTCIceGatherOptions options), Exposed=Window]
interface RTCIceGatherer : RTCStatsProvider {
    readonly        attribute RTCIceComponent     component;
    readonly        attribute RTCIceGathererState state;
    static sequence&lt;RTCIceServer&gt; getDefaultIceServers ();
    undefined                 close ();
    undefined                 gather (optional RTCIceGatherOptions options);
    RTCIceParameters          getLocalParameters ();
    sequence&lt;RTCIceCandidate&gt; getLocalCandidates ();
    RTCIceGatherer            createAssociatedGatherer ();
                    attribute EventHandler        onstatechange;
                    attribute EventHandler        onerror;
                    attribute EventHandler        onlocalcandidate;
};</pre>
        <section>
          <h2>Constructors</h2>
      <p>To validate the <code>options</code> argument in the
      <code><a>RTCIceGatherer</a></code> constructor, implementations MUST run
      the following steps:</p>
      <ol>
         <li>
           <p>Let <var>options</var> be the argument passed in the constructor.</p>
         </li>
         <li>
           <p>Let <var>servers</var> be the value of
           <code><var>options</var>.iceServers</code>.</p>
         </li>
         <li>
           <p>Let <var>validatedServers</var> be an empty list.</p>
         </li>
         <li>
           <p>Run the following steps for each element in <var>servers</var>:</p>
           <ol>
             <li>
               <p>Let <var>server</var> be the current list element.</p>
             </li>
             <li>
               <p>If <code><var>server</var>.urls</code> is a string,
               let <code><var>server</var>.urls</code> be a list
               consisting of just that string.</p>
             </li>
             <li>
               <p>For each <var>url</var> in
               <code><var>server</var>.urls</code> run the following steps:
               <ol>
                 <li>
                   <p>Parse the <var>url</var> using the generic URI syntax
                   defined in [[!RFC3986]] and obtain the
                   <var>scheme name</var>. If the parsing based
                   on the syntax defined in [[!RFC3986]] fails,
                   <a>throw</a> a <code>SyntaxError</code>.  If
                   the <var>scheme name</var> is not implemented
                   by the browser <a>throw</a> a
                   <code>NotSupportedError</code>. If
                   <var>scheme name</var> is <code>turn</code> or
                   <code>turns</code>, and parsing the
                   <var>url</var> using the syntax defined in
                   [[!RFC7064]] fails, <a>throw</a> a
                   <code>SyntaxError</code>. If <var>scheme
                   name</var> is <code>stun</code> or
                   <code>stuns</code>, and parsing the
                   <var>url</var> using the syntax defined in
                   [[!RFC7065]] fails, <a>throw</a> a
                   <code>SyntaxError</code>. </p>
                 </li>
                 <li>
                   <p>If <var>scheme name</var> is <code>turn</code> or
                   <code>turns</code>, and either of
                   <code><var>server</var>.username</code> or
                   <code><var>server</var>.credential</code> are omitted,
                   then <a>throw</a> an <code>InvalidAccessError</code>.</p>
                 </li>
                 <li>
                   <p>If <var>scheme name</var> is <code>turn</code> or
                   <code>turns</code>, and
                   <code><var>server</var>.credentialType</code> is
                   <code>"password"</code>, and
                   <code><var>server</var>.credential</code> is not a
                   <span class="idlMemberType"><a>DOMString</a></span>, then
                   <a>throw</a> an <code>InvalidAccessError</code> and abort these
                   steps.</p>
                 </li>
                 <li>
                   <p>If <var>scheme name</var> is <code>turn</code> or
                   <code>turns</code>, and
                   <code><var>server</var>.credentialType</code> is
                   <code>"oauth"</code>, and
                   <code><var>server</var>.credential</code> is not an
                   <a>RTCOAuthCredential</a>, then <a>throw</a> an
                   <code>InvalidAccessError</code> and abort these steps.</p>
                 </li>
               </ol>
             </li>
             <li>
               <p>Append <var>server</var> to <var>validatedServers</var>.</p>
             </li>
           </ol>
           <p>Let <var>validatedServers</var> be the <dfn id="ice-servers-list">
           ICE servers list</dfn>.</p>
          <dl data-link-for="RTCIceGatherer" data-dfn-for="RTCIceGatherer" class=
          "constructors">
            <dt><code><a>RTCIceGatherer</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">options</td>
                    <td class="prmType"><code><a>RTCIceGatherOptions</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceGatherer" data-dfn-for="RTCIceGatherer" class=
          "attributes">
            <dt><dfn data-idl>component</dfn> of type <span class=
            "idlAttrType"><a>RTCIceComponent</a></span>, readonly</dt>
            <dd>
              <p>The component-id of the <code><a>RTCIceGatherer</a></code> object. In
              <code><a>RTCIceGatherer</a></code> objects returned by
              <code><a>createAssociatedGatherer</a>()</code> the value of the
              <code><a>component</a></code> attribute is <code>rtcp</code>. In all other
              <code><a>RTCIceGatherer</a></code> objects, the value of the
              <code><a>component</a></code> attribute is <code>rtp</code>.</p>
            </dd>
            <dt><dfn data-idl><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceGathererState</a></span>, readonly</dt>
            <dd>
              <p>The current state of the ICE gatherer.</p>
            </dd>
            <dt><dfn data-idl><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <code><a>RTCIceGathererState</a></code> changes.</p>
            </dd>
            <dt><dfn data-idl><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>icecandidateerror</a></code>, <em class="rfc2119" title=
              "MUST">MUST</em> be fired if an error occurs in the gathering of ICE
              candidates (such as if TURN credentials are invalid).</p>
            </dd>
            <dt><dfn data-idl><code>onlocalcandidate</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>icecandidate</a></code>, uses the
              <code><a>RTCIceGathererEvent</a></code> interface.
              It receives events when a new local ICE candidate
              is available. Since ICE candidate gathering begins
              once an <code><a>RTCIceGatherer</a></code> object is
              created, <code>candidate</code> events are queued
              until an <code>onlocalcandidate</code> event handler
              is assigned. When the final candidate is gathered,
              a <code>candidate</code> event occurs with an
              <code>RTCIceCandidateComplete</code> emitted.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIceGatherer" data-dfn-for="RTCIceGatherer" class=
          "methods">
            <dt><dfn data-idl><code>getDefaultIceServers</code></dfn></dt>
            <dd>
              <p>Returns a list of ICE servers that are configured into the
              browser. A browser might be configured to use local or private
              STUN or TURN servers. This method allows an application to learn
              about these servers and optionally use them.</p>
              <p class="fingerprint">This list is likely to be persistent and
              is the same across origins. It thus increases the
              fingerprinting surface of the browser. In privacy-sensitive
              contexts, browsers can consider mitigations such as only
              providing this data to whitelisted origins (or not providing it
              at all.)</p>
              <p class="note">Since the use of this information is left to
              the discretion of application developers, configuring a user
              agent with these defaults does not per se increase a user's
              ability to limit the exposure of their IP addresses.</p>
            </dd>
            <dt><dfn data-idl><code>close</code></dfn></dt>
            <dd>
              <p>Prunes all local candidates, and closes the port. Associated
              <code><a>RTCIceTransport</a></code> objects transition to the
              <code>disconnected</code> state (unless they were in the
              <code>failed</code> state). Calling <code>close()</code> when
              <code>state</code> is <code>closed</code> has no effect.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>gather</code></dfn></dt>
            <dd>
              <p>Gather ICE candidates. If <var>options</var> is omitted, utilize the
              value of <var>options</var> passed in the constructor. If
              <code>state</code> is <code>closed</code>, <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">options</td>
                    <td class="prmType"><code><a>RTCIceGatherOptions</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getLocalParameters()</code></dfn></dt>
            <dd>
              <p>Obtains the ICE
              parameters of the <code><a>RTCIceGatherer</a></code>.
              If <code>state</code> is <code>closed</code>, <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCIceParameters</a></code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getLocalCandidates</code></dfn></dt>
            <dd>
              <p>Retrieve the sequence of valid local candidates associated with the
              <code><a>RTCIceGatherer</a></code>. This retrieves all unpruned local
              candidates currently known (except for peer reflexive candidates), even if
              an <code><a>onlocalcandidate</a></code> event hasn't been processed yet.
              Prior to calling <code><a>gather</a>()</code> an empty list will be
              returned. If  <code>state</code> is <code>closed</code>, <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence</code>&lt;<code><a>RTCIceCandidate</a></code>&gt;
              </div>
            </dd>
            <dt><dfn data-idl><code>createAssociatedGatherer</code></dfn></dt>
            <dd>
              <p>Create an associated <code><a>RTCIceGatherer</a></code> for RTCP, with
              the same <code><a>RTCIceParameters</a></code> and
              <code><a>RTCIceGatherOptions</a></code>. If <code>state</code> is
              <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>. If
              an <code><a>RTCIceGatherer</a></code> calls the method more than once, or
              if <code><a>component</a></code> is <code>rtcp</code>, <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCIceGatherer</a></code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtciceparameters*">
      <h3><dfn data-idl>RTCIceParameters</dfn> Dictionary</h3>
      <p>The <code>RTCIceParameters</code> dictionary includes the ICE username
      fragment and password and other ICE-related parameters.</p>
      <div>
<pre class="idl">dictionary RTCIceParameters {
             required DOMString usernameFragment;
             required DOMString password;
             boolean   iceLite;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceParameters</a> Members</h2>
          <dl data-link-for="RTCIceParameters" data-dfn-for="RTCIceParameters" class=
          "dictionary-members">
            <dt><dfn data-idl><code>usernameFragment</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>ICE username fragment.</p>
            </dd>
            <dt><dfn data-idl><code>password</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>ICE password.</p>
            </dd>
            <dt><dfn data-idl><code>iceLite</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span></dt>
            <dd>
              <p>If only ICE-lite is supported (<code>true</code>) or not
              (<code>false</code> or unset). Since [[!RTCWEB-TRANSPORT]] Section 3.4
              requires browser support for full ICE, <code><a>iceLite</a></code> will
              only be <code>true</code> for a remote peer such as a gateway.
              <code>getLocalParameters().iceLite</code> MUST NOT be set.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcicecandidate*">
      <h3><dfn data-idl>RTCIceCandidate</dfn> Dictionary</h3>
      <p>The <code>RTCIceCandidate</code> dictionary includes information relating
      to an ICE candidate.</p>
      <pre class="example highlight">{
  foundation: "abcd1234",
  priority: 1694498815,
  ip: "192.0.2.33",
  protocol: "udp",
  port: 10000,
  type: "host"
};
                </pre>
      <div>
        <p>The <dfn><code>RTCIceGatherCandidate</code></dfn> provides either an
        <code><a>RTCIceCandidate</a></code> or an
        <code><a>RTCIceCandidateComplete</a></code> indication that candidate gathering
        is complete.</p>
        <pre class="idl">
typedef (RTCIceCandidate or RTCIceCandidateComplete) RTCIceGatherCandidate;</pre>
        <div class="idlTypedefDesc"></div>
      </div>
      <div>
<pre class="idl">dictionary RTCIceCandidate {
             required DOMString              foundation;
             required unsigned long          priority;
             required DOMString              ip;
             required RTCIceProtocol         protocol;
             required unsigned short         port;
             required RTCIceCandidateType    type;
             RTCIceTcpCandidateType tcpType;
             DOMString              relatedAddress;
             unsigned short         relatedPort;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceCandidate</a> Members</h2>
          <dl data-link-for="RTCIceCandidate" data-dfn-for="RTCIceCandidate" class=
          "dictionary-members">
            <dt><dfn data-idl><code>foundation</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>A unique identifier that allows ICE to correlate candidates that appear
              on multiple <code><a>RTCIceTransport</a></code>s.</p>
            </dd>
            <dt><dfn data-idl><code>priority</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span>, required</dt>
            <dd>
              <p>The assigned priority of the candidate. This is automatically populated
              by the browser.</p>
            </dd>
            <dt><dfn data-idl><code>ip</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The IP address of the candidate.</p>
            </dd>
            <dt><dfn data-idl><code>protocol</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceProtocol</a></span>, required</dt>
            <dd>
              <p>The protocol of the candidate (udp/tcp).</p>
            </dd>
            <dt><dfn data-idl><code>port</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, required</dt>
            <dd>
              <p>The port for the candidate.</p>
            </dd>
            <dt><dfn data-idl><code>type</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCandidateType</a></span>, required</dt>
            <dd>
              <p>The type of candidate.</p>
            </dd>
            <dt><dfn data-idl><code>tcpType</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceTcpCandidateType</a></span></dt>
            <dd>
              <p>The type of TCP candidate. For UDP candidates, this
              attribute is unset.</p>
            </dd>
            <dt><dfn data-idl><code>relatedAddress</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>For candidates that are derived from others, such as relay or reflexive
              candidates, the <code>relatedAddress</code> refers to the
              candidate that these are derived from. For host candidates, the
              <code>relatedAddress</code> is unset.</p>
            </dd>
            <dt><dfn data-idl><code>relatedPort</code></dfn> of
            type <span class="idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>For candidates that are derived from others, such as relay or reflexive
              candidates, the <code>relatedPort</code> refers to the host
              candidate that these are derived from. For host candidates, the
              <code>relatedPort</code> is unset.</p>
            </dd>
          </dl>
        </section>
      </div>
      <section>
        <h4><dfn>RTCIceProtocol</dfn> Enum</h4>
        <p>The <code>RTCIceProtocol</code> includes the protocol of the ICE
        candidate.</p>
        <div>
<pre class="idl">enum RTCIceProtocol {
    "udp",
    "tcp"
};</pre>
          <table data-link-for="RTCIceProtocol" data-dfn-for="RTCIceProtocol" class=
          "simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code id="idl-def-RTCIceProtocol.udp">udp</code></dfn></td>
                <td>
                  <p>A UDP candidate, as described in [[!RFC5245]].</p>
                </td>
              </tr>
              <tr>
                <td><dfn><code id="idl-def-RTCIceProtocol.tcp">tcp</code></dfn></td>
                <td>
                  <p>A TCP candidate, as described in [[!RFC6544]].</p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4><dfn>RTCIceTcpCandidateType</dfn> Enum</h4>
        <p>The <code>RTCIceTcpCandidateType</code> includes the type of the
        ICE TCP candidate, as described in [[!RFC6544]]. Browsers MUST gather active TCP
        candidates and only active TCP candidates. Servers and other endpoints MAY gather
        active, passive or so candidates.</p>
        <div>
<pre class="idl">enum RTCIceTcpCandidateType {
    "active",
    "passive",
    "so"
};</pre>
          <table data-link-for="RTCIceTcpCandidateType" data-dfn-for=
          "RTCIceTcpCandidateType" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn data-idl><code id=
                "idl-def-RTCIceTcpCandidateType.active">active</code></dfn></td>
                <td>
                  <p>An active TCP candidate is one for which the transport will attempt
                  to open an outbound connection but will not receive incoming connection
                  requests.</p>
                </td>
              </tr>
              <tr>
                <td><dfn data-idl><code id=
                "idl-def-RTCIceTcpCandidateType.passive">passive</code></dfn></td>
                <td>
                  <p>A passive TCP candidate is one for which the transport will receive
                  incoming connection attempts but not attempt a connection.</p>
                </td>
              </tr>
              <tr>
                <td><dfn data-idl><code id=
                "idl-def-RTCIceTcpCandidateType.so">so</code></dfn></td>
                <td>
                  <p>An so candidate is one for which the transport will attempt to open
                  a connection simultaneously with its peer.</p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section>
        <h4><dfn>RTCIceCandidateType</dfn> Enum</h4>
        <p>The <code>RTCIceCandidateType</code> includes the type of the ICE
        candidate as defined in [[!RFC5245]] section 15.1.</p>
        <div>
<pre class="idl">enum RTCIceCandidateType {
    "host",
    "srflx",
    "prflx",
    "relay"
};</pre>
          <table data-link-for="RTCIceCandidateType" data-dfn-for="RTCIceCandidateType"
          class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn><code id=
                "idl-def-RTCIceCandidateType.host">host</code></dfn></td>
                <td>
                  <p>A host candidate, as defined in Section 4.1.1.1 of [[!RFC5245]].</p>
                </td>
              </tr>
              <tr>
                <td><dfn><code id=
                "idl-def-RTCIceCandidateType.srflx">srflx</code></dfn></td>
                <td>
                  <p>A server reflexive candidate, as defined in Section 4.1.1.2 of
                  [[!RFC5245]].</p>
                </td>
              </tr>
              <tr>
                <td><dfn><code id=
                "idl-def-RTCIceCandidateType.prflx">prflx</code></dfn></td>
                <td>
                  <p>A peer reflexive candidate, as defined in Section 4.1.1.2 of
                  [[!RFC5245]].</p>
                </td>
              </tr>
              <tr>
                <td><dfn><code id=
                "idl-def-RTCIceCandidateType.relay">relay</code></dfn></td>
                <td>
                  <p>A relay candidate, as defined in Section 7.1.3.2.1 of
                  [[!RFC5245]].</p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </section>
    <section id="rtcicecandidatecomplete*">
      <h3><dfn>RTCIceCandidateComplete</dfn> Dictionary</h3>
      <p><code>RTCIceCandidateComplete</code> is a dictionary signifying that
      all <code>RTCIceCandidate</code>s are gathered.</p>
      <div>
<pre class="idl">dictionary RTCIceCandidateComplete {
             boolean complete = true;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceCandidateComplete</a> Members</h2>
          <dl data-link-for="RTCIceCandidateComplete" data-dfn-for=
          "RTCIceCandidateComplete" class="dictionary-members">
            <dt><dfn data-idl><code>complete</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>true</code></dt>
            <dd>
              <p>This attribute is always present and set to <code>true</code>,
              indicating that ICE candidate gathering is complete.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcicegathererstate*">
      <h3><dfn>RTCIceGathererState</dfn> Enum</h3>
      <p><code>RTCIceGathererState</code> represents the current state of the
      ICE gatherer.</p>
      <div>
<pre class="idl">enum RTCIceGathererState {
    "new",
    "gathering",
    "complete",
    "closed"
};</pre>
        <table data-link-for="RTCIceGathererState" data-dfn-for="RTCIceGathererState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn data-idl>
              <code id="idl-def-RTCIceGathererState.new">new</code></dfn></td>
              <td>
                <p>The object has been created but <code>gather()</code> has not been
                called.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceGathererState.gathering">gathering</code></dfn></td>
              <td>
                <p><code>gather()</code> has been called, and the
                <code><a>RTCIceGatherer</a></code> is in the process of gathering
                candidates (which includes adding new candidates and removing invalidated
                candidates).</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceGathererState.complete">complete</code></dfn></td>
              <td>
                <p>The <code><a>RTCIceGatherer</a></code> has completed gathering. Events
                such as adding, updating or removing an interface, or adding, changing or
                removing a TURN server will cause the state to go back to
                <code>gathering</code> before re-entering <code>complete</code> once all
                candidate changes are finalized.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceGathererState.closed">closed</code></dfn></td>
              <td>
                <p>The <code>closed</code> state can only be entered when
                the <code><a>RTCIceGatherer</a></code> has been closed
                intentionally by calling <code>close()</code>. This is a
                terminal state.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section>
      <h4><dfn>RTCIceGathererIceErrorEvent</dfn></h4>
      <p>The <code><a>icecandidateerror</a></code> event of the
      <code><a>RTCIceGatherer</a></code> object uses the
      <code><a>RTCIceGathererIceErrorEvent</a></code> interface.</p>
      <div>
        <pre class="idl">
[ Constructor (DOMString type, RTCIceGathererIceErrorEventInit eventInitDict), Exposed=Window]
interface RTCIceGathererIceErrorEvent : Event {
    readonly        attribute RTCIceCandidate? hostCandidate;
    readonly        attribute DOMString        url;
    readonly        attribute unsigned short   errorCode;
    readonly        attribute USVString        statusText;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCIceGathererIceErrorEvent" data-dfn-for=
          "RTCIceGathererIceErrorEvent" class="constructors">
            <dt><code>RTCIceGathererIceErrorEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType">
                    <code><a>RTCIceGathererIceErrorEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceGathererIceErrorEvent" data-dfn-for=
          "RTCIceGathererIceErrorEvent" class="attributes">
            <dt><dfn data-idl><code>hostCandidate</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceCandidate</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <code><a>RTCIceCandidate</a></code> used to communicate with the
              STUN or TURN server. On a multihomed system, multiple interfaces may be
              used to contact the server, and this attribute allows the application to
              figure out on which one the failure occurred. If the browser is in a
              privacy mode disallowing host candidates, this attribute will be null.</p>
              <p>If use of multiple interfaces has been prohibited for privacy reasons,
              <code><a>hostCandidate</a></code> will be null.</p>
            </dd>
            <dt><dfn data-idl><code>url</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <code><a>url</a></code> attribute is the STUN or TURN URL
              identifying the server on which the failure ocurred.</p>
            </dd>
            <dt><dfn data-idl><code>errorCode</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly</dt>
            <dd>
              <p>The <code><a>errorCode</a></code> attribute is the numeric STUN error
              code returned by the STUN or TURN server [[STUN-PARAMETERS]].</p>
              <p>If no host candidate can reach the server, <code><a>errorCode</a></code>
              will be set to a value of 701, as this does not conflict with the STUN
              error code range, and <code><a>hostCandidate</a></code> will be null. This
              error is only fired once per server URL while in the
              <code><a>RTCIceGathererState</a></code> of <code>gathering</code>.</p>
            </dd>
            <dt><dfn data-idl><code>statusText</code></dfn> of type <span class=
            "idlAttrType"><a>USVString</a></span>, readonly</dt>
            <dd>
              <p>The STUN reason text returned by the STUN or TURN server
              [[STUN-PARAMETERS]].</p>
              <p>If the server could not be reached, <code><a>statusText</a></code> will
              be set to an implementation-specific value providing details about the
              error.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
      <p>The <dfn><code>RTCIceGathererIceErrorEventInit</code></dfn> dictionary
      provides information on ICE gathering errors.</p>
<pre class="idl">
dictionary RTCIceGathererIceErrorEventInit : EventInit {
             RTCIceCandidate hostCandidate;
             DOMString       url;
             required unsigned short  errorCode;
             USVString       errorText;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceGathererIceErrorEventInit</a>
          Members</h2>
          <dl data-link-for="RTCIceGathererIceErrorEventInit" data-dfn-for=
          "RTCIceGathererIceErrorEventInit" class="dictionary-members">
            <dt><dfn data-idl><code>hostCandidate</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCandidate</a></span></dt>
            <dd>
              <p>The <code><a>RTCIceCandidate</a></code> used to communicate with the
              STUN or TURN server.</p>
            </dd>
            <dt><dfn data-idl><code>url</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The <code>url</code> attribute is the STUN or TURN URL identifying the
              server on which the failure ocurred.</p>
            </dd>
            <dt><dfn data-idl><code>errorCode</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, required</dt>
            <dd>
              <p>The <code>errorCode</code> attribute is the numeric STUN error code
              returned by the STUN or TURN server [[STUN-PARAMETERS]].</p>
            </dd>
            <dt><dfn data-idl><code>errorText</code></dfn> of type <span class=
            "idlMemberType"><a>USVString</a></span></dt>
            <dd>
              <p>The <code>errorText</code> attribute is the STUN reason text returned by
              the STUN or TURN server [[STUN-PARAMETERS]].</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h4><dfn>RTCIceGathererEvent</dfn></h4>
      <p>The <code>icecandidate</code> event of the <code><a>RTCIceGatherer</a></code>
      object uses the <code><a>RTCIceGathererEvent</a></code> interface.</p>
      <p>Firing an <code><a>RTCIceGathererEvent</a></code> event named <var>e</var> with
      an <code><a>RTCIceGatherCandidate</a></code> <var>candidate</var> and
      URL <var>url</var> means that an event with the name <var>e</var>, which does
      not bubble (except where otherwise stated) and is not cancelable (except
      where otherwise stated), and which uses the <code><a>RTCIceGathererEvent</a></code>
      interface with the <code>candidate</code> attribute set to the new ICE candidate,
      <em class="rfc2119" title="MUST">MUST</em> be created and dispatched at the given
      target.</p>
      <div>
<pre class="idl">
[ Constructor (DOMString type, RTCIceGathererEventInit eventInitDict), Exposed=Window]
interface RTCIceGathererEvent : Event {
    readonly        attribute RTCIceGatherCandidate candidate;
    readonly        attribute DOMString?            url;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCIceGathererEvent" data-dfn-for="RTCIceGathererEvent"
          class="constructors">
            <dt><code>RTCIceGathererEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>RTCIceGathererEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceGathererEvent" data-dfn-for="RTCIceGathererEvent"
          class="attributes">
            <dt><dfn data-idl><code>candidate</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceGatherCandidate</a></span>, readonly</dt>
            <dd>
              <p>The <code>candidate</code> attribute is the
              <code><a>RTCIceGatherCandidate</a></code> object with the new ICE candidate
              that caused the event. If <code>candidate</code> is of type
              <code><a>RTCIceCandidateComplete</a></code>, there are no additional
              candidates.</p>
            </dd>
            <dt><dfn data-idl><code>url</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly , nullable</dt>
            <dd>The URL of the server from which the candidate was obtained.</dd>
          </dl>
        </section>
      </div>
      <div>
      <p>The <dfn><code>RTCIceGathererEventInit</code></dfn> dictionary provides
      information on the <code><a>RTCIceGatherCandidate</a></code>.</p>
<pre class="idl">dictionary RTCIceGathererEventInit : EventInit {
             required RTCIceGatherCandidate candidate;
             DOMString             url;
};</pre>
        <section>
          <h2>Dictionary RTCIceGathererEventInit Members</h2>
          <dl data-link-for="RTCIceGathererEventInit" data-dfn-for=
          "RTCIceGathererEventInit" class="dictionary-members">
            <dt><dfn data-idl><code>candidate</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceGatherCandidate</a></span>, required</dt>
            <dd>
              <p>The ICE candidate that caused the event.</p>
            </dd>
            <dt><dfn data-idl><code>url</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>The URL of the server from which the candidate was obtained.</dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcicegatheroptions*">
      <h3><dfn>RTCIceGatherOptions</dfn> Dictionary</h3>
      <p><code>RTCIceGatherOptions</code> provides options relating to the
      gathering of ICE candidates.</p>
      <div>
        <pre class="idl">dictionary RTCIceGatherOptions {
             RTCIceGatherPolicy     gatherPolicy = "all";
             sequence&lt;RTCIceServer&gt; iceServers;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceGatherOptions</a> Members</h2>
          <dl data-link-for="RTCIceGatherOptions" data-dfn-for="RTCIceGatherOptions"
          class="dictionary-members">
            <dt><dfn data-idl><code>gatherPolicy</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceGatherPolicy</a></span></dt>
            <dd>
              <p>The ICE gather policy.</p>
            </dd>
            <dt><dfn data-idl><code>iceServers</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCIceServer</a>&gt;</span></dt>
            <dd>
              <p>Additional ICE servers to be configured. Since implementations MAY
              provide default ICE servers, and applications can desire to restrict
              communications to the local LAN, <var>iceServers</var> need not be set.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcicegatherpolicy*">
      <h3><dfn>RTCIceGatherPolicy</dfn> Enum</h3>
      <p><code>RTCIceGatherPolicy</code> denotes the policy relating to the
      gathering of ICE candidates.</p>
      <div>
        <pre class="idl">enum RTCIceGatherPolicy {
    "all",
    "relay"
};</pre>
        <table data-link-for="RTCIceGatherPolicy" data-dfn-for="RTCIceGatherPolicy"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn data-idl><code id="idl-def-RTCIceGatherPolicy.all">all</code></dfn></td>
              <td>
                  <p>
                    The <code><a>RTCIceGatherer</a></code> MAY gather any type of
                    candidate when this value is specified.
                  </p>
                  <div class="note">
                    The implementation may still use its own candidate
                    filtering policy in order to limit the IP addresses
                    exposed to the application.
                  </div>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceGatherPolicy.relay">relay</code></dfn></td>
              <td>
                  <p>
                    The <code><a>RTCIceGatherer</a></code> MUST only gather media relay
                    candidates such as candidates passing through a TURN server.
                  </p>
                  <div class="note">
                    This can be used to prevent the remote endpoint from learning
                    the user's IP addresses, which may be desired in certain
                    use cases. For example, in a "call"-based application, the
                    application may want to prevent an unknown caller from
                    learning the callee's IP addresses until the callee has
                    consented in some way.
                  </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtciceserver*">
      <h3><dfn>RTCIceServer</dfn> Dictionary</h3>
      <p>The <code>RTCIceServer</code> dictionary is used to configure the
      STUN and/or TURN servers. In network topologies with multiple layers of NATs,
      it is desirable to have a STUN server between every layer of NATs in addition
      to the TURN servers to minimize the peer to peer network latency.</p>
      <div>
          <pre class="idl">dictionary RTCIceServer {
    required (DOMString or sequence&lt;DOMString&gt;) urls;
             DOMString                          username;
             (DOMString or RTCOAuthCredential)     credential;
             RTCIceCredentialType               credentialType = "password";
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceServer</a> Members</h2>
          <dl data-link-for="RTCIceServer" data-dfn-for="RTCIceServer" class=
          "dictionary-members">
            <dt><dfn data-idl><code>urls</code></dfn> of type <span class=
            "idlMemberType"><a>(DOMString or sequence&lt;DOMString&gt;)</a></span>,
            required</dt>
            <dd>
              <p>STUN or TURN URI(s) as defined in [[!RFC7064]] and [[!RFC7065]] or other
              URI types.</p>
            </dd>
            <dt><dfn data-idl><code>username</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>If this <code><a>RTCIceServer</a></code> object represents a TURN
              server, then this attribute specifies the username to use with that TURN
              server.</p>
            </dd>
            <dt><dfn data-idl><code>credential</code></dfn> of type <span class=
              "idlMemberType">(<a>DOMString</a> or <a>RTCOAuthCredential</a>)
              </span></dt>
            <dd>
                <p>If this <code><a>RTCIceServer</a></code> object represents a
                TURN server, then this attribute specifies the credential to
                use with that TURN server.</p>
                <p>If <code>credentialType</code> is <code>"password"</code>,
                <code>credential</code> is a <a>DOMString</a>, and represents a
                long-term authentication password, as described in
                [[!RFC5389]], Section 10.2.</p>
                <p>If <code>credentialType</code> is <code>"oauth"</code>,
                <code>credential</code> is a <a>RTCOAuthCredential</a>, which
                contains the OAuth access token and MAC key.</p>
            </dd>
            <dt><dfn data-idl><code>credentialType</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCredentialType</a></span>, defaulting to
            <code>"password"</code></dt>
            <dd>
              <p>If this <code><a>RTCIceServer</a></code> object represents a TURN
              Server, then this attribute specifies how <code><a>credential</a></code>
              should be used when that TURN server requests authorization.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section class="informative" id="rtcicegatherer-initial-example*">
      <h3>Examples</h3>
       <p>An example array of <code><a>RTCIceServer</a></code> objects is:</p>
      <pre class="example highlight"><code>[
{ urls: "stun:stun1.example.net" },
{ urls: ["turns:turn.example.org", "turn:turn.example.net"],
  username: "user",
  credential: "myPassword",
  credentialType: "password" },
     { urls: "turns:turn2.example.net",
       username: "22BIjxU93h/IgwEb",
       credential: {
                       macKey: "WmtzanB3ZW9peFhtdm42NzUzNG0=",
                       accessToken: "AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ5VhNDgeMR3+ZlZ35byg972fW8QjpEl7bx91YLBPFsIhsxloWcXPhA=="
                     },
       credentialType: "oauth" },
     }
]</code></pre>      
      <pre class="example highlight">
      // Example to demonstrate use of RTCIceCandidateComplete
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

// Create ICE gather options
var gatherOptions = {
  gatherPolicy: "relay",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
      credentialType: "password" }
   ]
};
// Create IceGatherer object
var iceGatherer = new RTCIceGatherer(gatherOptions);

// Handle state changes
iceGatherer.onstatechange = function(event) {
  myIceGathererStateChange("iceGatherer", event.state);
};

// Prepare to signal local candidates
iceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate);
};

// Start gathering
iceGatherer.gather();

// Set up response function
mySignaller.onResponse = function(responseSignaller, response) {
  // We may get N responses
  // ... deal with the N responses as shown in Example 5 of Section 3.11.
};

mySignaller.send({
  ice: iceGatherer.getLocalParameters()
});
                </pre>
      <pre class="example highlight">
      // Helper functions used in all the examples (helper.js)
export function trace(text) {
  // This function is used for logging.
  text = text.trimRight();
  if (window.performance) {
    var now = (window.performance.now() / 1000).toFixed(3);
    console.log(now + ": " + text);
  } else {
    console.log(text);
  }
}

export function errorHandler(error) {
  trace("Error encountered: " + error.name);
}

export function mySendLocalCandidate(candidate, component, kind, parameters) {
  // Set default values
  kind = kind || "all";
  component = component || "rtp";
  parameters = parameters || null;

  // Signal the local candidate
  mySignaller.mySendLocalCandidate({
    candidate: candidate,
    component: component,
    kind: kind,
    parameters: parameters
  });
}

export function myIceGathererStateChange(name, state) {
  switch (state) {
    case "new":
      trace("IceGatherer: " + name + " Has been created");
      break;
    case "gathering":
      trace("IceGatherer: " + name + " Is gathering candidates");
      break;
    case "complete":
      trace("IceGatherer: " + name + " Has finished gathering (for now)");
      break;
    case "closed":
      trace("IceGatherer: " + name + " Is closed");
      break;
    default:
      trace("IceGatherer: " + name + " Invalid state");
  }
}

export function myIceTransportStateChange(name, state) {
  switch (state) {
    case "new":
      trace("IceTransport: " + name + " Has been created");
      break;
    case "checking":
      trace("IceTransport: " + name + " Is checking");
      break;
    case "connected":
      trace("IceTransport: " + name + " Is connected");
      break;
    case "disconnected":
      trace("IceTransport: " + name + " Is disconnected");
      break;
    case "completed":
      trace("IceTransport: " + name + " Has finished checking (for now)");
      break;
    case "failed":
      trace("IceTransport: " + name + " Has failed");
      break;
    case "closed":
      trace("IceTransport: " + name + " Is closed");
      break;
    default:
      trace("IceTransport: " + name + " Invalid state");
  }
}

export function myDtlsTransportStateChange(name, state){
  switch(state){
  case "new":
     trace('DtlsTransport: ' + name + ' Has been created');
     break;
  case "connecting":
     trace('DtlsTransport: ' + name + ' Is connecting');
     break;
  case "connected":
     trace('DtlsTransport: ' + name + ' Is connected');
     break;
  case "failed":
     trace('DtlsTransport: ' + name + ' Has failed');
     break;
  case "closed":
     trace('DtlsTransport: ' + name + ' Is closed');
     break;
  default:
     trace('DtlsTransport: ' + name + ' Invalid state');
  }
}
                </pre>
    </section>
  </section>
  <section id="rtcicetransport*">
    <h2><dfn>RTCIceTransport</dfn> Interface</h2>
    <p>The <code>RTCIceTransport</code> allows an application access to
    information about the Interactive Connectivity Establishment (ICE) transport over
    which packets are sent and received. In particular, ICE manages peer-to-peer
    connections which involve state which the application may want to access.</p>
    <section id="rtcicetransport-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCIceTransport</a></code> instance is associated to a transport
      object (such as <code><a>RTCDtlsTransport</a></code>), and provides RTC related
      methods to it.</p>
    </section>
    <section id="rtcicetransport-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCIceTransport</a></code> instance is constructed (optionally) from
      an <code><a>RTCIceGatherer</a></code>. An <code><a>RTCIceTransport</a></code> object
      in the <code>closed</code> state can be garbage-collected when it is no longer referenced.</p>
    </section>
    <section id="rtcicetransport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">[ Constructor (optional RTCIceGatherer gatherer), Exposed=Window]
interface RTCIceTransport : RTCStatsProvider {
    readonly        attribute RTCIceGatherer?      iceGatherer;
    readonly        attribute RTCIceRole           role;
    readonly        attribute RTCIceComponent      component;
    readonly        attribute RTCIceTransportState state;
    sequence&lt;RTCIceCandidate&gt; getRemoteCandidates ();
    RTCIceCandidatePair?      getSelectedCandidatePair ();
    undefined                 start (RTCIceGatherer gatherer, RTCIceParameters remoteParameters, optional RTCIceRole role = "controlled");
    undefined                 stop ();
    RTCIceParameters?         getRemoteParameters ();
    RTCIceTransport           createAssociatedTransport ();
    undefined                 addRemoteCandidate (RTCIceGatherCandidate remoteCandidate);
    undefined                 setRemoteCandidates (sequence&lt;RTCIceCandidate&gt; remoteCandidates);
                    attribute EventHandler         onstatechange;
                    attribute EventHandler         oncandidatepairchange;
};</pre>
        <section>
          <h2>Constructors</h2>
          <p>If <code>gatherer.state</code> is
          <code>closed</code> or <code>gatherer.component</code> is <code>rtcp</code>,
          <a>throw</a> an <code>InvalidStateError</code>.</p>
          <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport" class=
          "constructors">
            <dt><code><a>RTCIceTransport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">gatherer</td>
                    <td class="prmType"><code><a>RTCIceGatherer</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport" class=
          "attributes">
            <dt><dfn data-idl><code>iceGatherer</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceGatherer</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <code>iceGatherer</code> attribute is set to the value of
              <var>gatherer</var> if passed in the constructor or in the latest call to
              <code>start()</code>.</p>
            </dd>
            <dt><dfn data-idl><code>role</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceRole</a></span>, readonly</dt>
            <dd>
              <p>The current role of the ICE transport.</p>
            </dd>
            <dt><dfn data-idl>component</dfn> of type <span class=
            "idlAttrType"><a>RTCIceComponent</a></span>, readonly</dt>
            <dd>
              <p>The component-id of the <code><a>RTCIceTransport</a></code> object. In
              <code><a>RTCIceTransport</a></code> objects returned by
              <code><a>createAssociatedTransport</a>()</code>, the value of
              <code><a>component</a></code> is <code>rtcp</code>. In all other
              <code><a>RTCIceTransport</a></code> objects, the value of
              <code><a>component</a></code> is <code>rtp</code>.</p>
            </dd>
            <dt><dfn data-idl><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceTransportState</a></span>, readonly</dt>
            <dd>
              <p>The current state of the ICE transport.</p>
            </dd>
            <dt><dfn data-idl><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <code><a>RTCIceTransportState</a></code> changes.</p>
            </dd>
            <dt><dfn data-idl><code>oncandidatepairchange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler type
              <code><a>icecandidatepairchange</a></code>, uses the
              <code><a>RTCIceCandidatePairChangedEvent</a></code> interface. It
              <em class="rfc2119" title="MUST">MUST</em> be supported by all objects
              implementing the <code><a>RTCIceTransport</a></code> interface. It is
              called any time the selected <code><a>RTCIceCandidatePair</a></code>
              changes.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIceTransport" data-dfn-for="RTCIceTransport" class=
          "methods">
            <dt><dfn data-idl><code>getRemoteCandidates</code></dfn></dt>
            <dd>
              <p>Retrieve the sequence of candidates associated with the remote
              <code><a>RTCIceTransport</a></code>. Only returns the candidates previously
              added using <code><a>setRemoteCandidates</a>()</code> or
              <code><a>addRemoteCandidate</a>()</code>. If there are no remote
              candidates, an empty list is returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence</code>&lt;<code><a>RTCIceCandidate</a></code>&gt;
              </div>
            </dd>
            <dt><dfn data-idl><code>getSelectedCandidatePair</code></dfn></dt>
            <dd>
              <p>Retrieves the selected candidate pair on which packets are sent. If
              there is no selected pair yet, or consent [[!RFC7675]] is lost on the
              selected pair, NULL is returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCIceCandidatePair</a></code>, nullable
              </div>
            </dd>
            <dt><dfn data-idl><code>start</code></dfn></dt>
            <dd>
              <p>As noted in [[!RFC5245]] Section 7.1.2.3, an incoming connectivity check
              utilizes the local/remote username fragment and the local password, whereas
              an outgoing connectivity check utilizes the local/remote username fragment
              and the remote password. Since <code>start()</code> provides role
              information, as well as the remote username fragment and password, once
              <code>start()</code> is called an <code><a>RTCIceTransport</a></code>
              object can respond to incoming connectivity checks based on its
              configured role. Since <code>start()</code> enables candidate pairs
              to be formed, it also enables initiating connectivity checks.</p>
              <p>When <code>start()</code> is called, the following
              steps MUST be run:<p>
              <ol>
                <li>
                  If <code><var>gatherer</var>.component</code> has a value
                  different from <code>component</code>, <a>throw</a> an
                  <code>InvalidParameters</code>.
                </li>
                <li>
                  If <code>state</code> or <code><var>gatherer</var>.state</code>
                  is <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>.
                </li>
                <li>
                  If <code><var>remoteParameters</var>.usernameFragment</code>
                  or <code><var>remoteParameters</var>.password</code> is unset,
                  <a>throw</a> an <code>InvalidParameters</code>.
                </li>
                <li>
                  If <code>start()</code> is called again and
                  <code><var>role</var></code> is changed, <a>throw</a> an
                  <code>InvalidParameters</code>.
                </li>
                <li>
                  If <code>start()</code> is called again with the same
                  values of <code><var>gatherer</var></code> and
                  <code><var>remoteParameters</var></code>, this has
                  no effect.
                </li>
                <li>
                  If <code>start()</code> is called for the first time
                  and either <code><var>gatherer</var></code> was not
                  passed in the constructor or the value of
                  <code><var>gatherer</var></code> is unchanged, if
                  there are remote candidates, set <code>state</code>
                  to <code>checking</code> and start connectivity checks.
                  If there are no remote candidates, <code>state</code>
                  remains <code>new</code>.
                </li>
                <li>
                  If <code>start()</code> is called for the first time
                  and the value of <code><var>gatherer</var></code>
                  passed as an argument is different from that passed
                  in the constructor, flush local candidates.  If there
                  are remote candidates, set <code>state</code> to
                  <code>checking</code> and start connectivity checks.
                  If there are no remote candidates, <code>state</code>
                  remains <code>new</code>.
                </li>
                <li>
                  If <code>start()</code> is called again with the same
                  value of <code><var>gatherer</var></code> but the value
                  of <code><var>remoteParameters</var></code> has changed,
                  local candidates are kept, remote candidates are flushed,
                  candidate pairs are flushed and <code>state</code>
                  transitions to <code>new</code>.
                </li>
                <li>
                  If <code>start()</code> is called again with a new value
                  of <code><var>gatherer</var></code> but the value of
                  <code><var>remoteParameters</var></code> is unchanged,
                  local candidates are flushed, candidate pairs are flushed,
                  new candidate pairs are formed with existing remote candidates,
                  and <code>state</code> transitions to <code>checking</code>.
              </li>
              <li>
                If <code>start()</code> is called again with new values of
                <code><var>gatherer</var></code> and
                <code><var>remoteParameters</var></code>, local
                candidates are flushed, remote candidates are flushed,
                candidate pairs are flushed and <code>state</code> transitions
                to <code>new</code>.
               </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">gatherer</td>
                    <td class="prmType"><code><a>RTCIceGatherer</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">remoteParameters</td>
                    <td class="prmType"><code><a>RTCIceParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">role</td>
                    <td class="prmType"><code><a>RTCIceRole</a></code> = <code>controlled</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>stop</code></dfn></dt>
            <dd>
              <p>Irreversibly stops the
              <code><a>RTCIceTransport</a></code>. When
              <code>stop</code> is called, the following
              steps MUST be run:<p>
              <ol>
                <li>
                  Let <var>iceTransport</var> be the
                  <code><a>RTCIceTransport</a></code> object on
                  which the <code>stop</code> method is invoked.
                </li>
                <li>
                  If <code><var>iceTransport</var>.state</code> is
                  <code>closed</code>, abort these steps.
                </li>
                <li>
                  Set <code><var>iceTransport</var>.state</code> to
                  <code>closed</code>.
                </li>
                <li>
                  Let <var>controller</var> be the
                  <code><a>RTCIceTransportController</a></code> object
                  that <var>iceTransport</var> has been added to.
                </li>
                <li>
                  Remove <var>iceTransport</var> from
                  <var>controller</var>.
                </li>
                <li>
                  Fire a simple event <code>statechange</code>
                  at <var>iceTransport</var>.
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getRemoteParameters()</code></dfn></dt>
            <dd>
              <p>Obtains the current ICE parameters of the remote
              <code><a>RTCIceTransport</a></code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCIceParameters</a></code>, nullable
              </div>
            </dd>
            <dt><dfn data-idl><code>createAssociatedTransport</code></dfn></dt>
            <dd>
              <p>Create an associated <code><a>RTCIceTransport</a></code> for RTCP. If
              called more than once for the same component, or if <var>state</var> is
              <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>. If
              called when <code><a>component</a></code> is <code>rtcp</code>, <a>throw</a>
              an <code>InvalidStateError</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCIceTransport</a></code>
              </div>
            </dd>
            <dt><dfn data-idl><code>addRemoteCandidate</code></dfn></dt>
            <dd>
              <p>Add a remote candidate associated with the remote
              <code><a>RTCIceTransport</a></code>. If <code>state</code> is
              <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>.
              When the remote <code><a>RTCIceGatherer</a></code> emits its final
              candidate, <code><a>addRemoteCandidate</a>()</code> should be called with
              an <code><a>RTCIceCandidateComplete</a></code> dictionary as an argument,
              so that the local <code><a>RTCIceTransport</a></code> can know there are no
              more remote candidates expected, and can enter the <code>completed</code>
              state.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">remoteCandidate</td>
                    <td class="prmType"><code><a>RTCIceGatherCandidate</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>setRemoteCandidates</code></dfn></dt>
            <dd>
              <p>Set the sequence of candidates associated with the remote
              <code><a>RTCIceTransport</a></code>. If <code>state</code> is
              <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">remoteCandidates</td>
                    <td class="prmType">
                    <code>sequence</code>&lt;<code><a>RTCIceCandidate</a></code>&gt;</td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcicecomponent*">
      <h3><dfn>RTCIceComponent</dfn> Enum</h3>
      <p><code>RTCIceComponent</code> contains the component-id of the
      <code><a>RTCIceTransport</a></code>, which will be <code>rtp</code> unless RTP and
      RTCP are not multiplexed and the <code><a>RTCIceTransport</a></code> object was
      returned by <code>createAssociatedTransport()</code>.</p>
      <div>
        <pre class="idl">enum RTCIceComponent {
    "rtp",
    "rtcp"
};</pre>
        <table data-link-for="RTCIceComponent" data-dfn-for="RTCIceComponent" class=
        "simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCIceComponent.rtp">rtp</code></dfn></td>
              <td>
                <p>The RTP component ID, defined (as '1') in [[!RFC5245]] Section
                4.1.1.1. Protocols multiplexed with RTP (e.g. SCTP data channel) share
                its component ID.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCIceComponent.rtcp">rtcp</code></dfn></td>
              <td>
                <p>The RTCP component ID, defined (as '2') in [[!RFC5245]] Section
                4.1.1.1.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcicerole*">
      <h3><dfn>RTCIceRole</dfn> Enum</h3>
      <p><code>RTCIceRole</code> contains the current role of the ICE
      transport.</p>
      <div>
        <pre class="idl">enum RTCIceRole {
    "controlling",
    "controlled"
};</pre>
        <table data-link-for="RTCIceRole" data-dfn-for="RTCIceRole" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCIceRole.controlling">controlling</code></dfn></td>
              <td>
                <p>controlling state</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCIceRole.controlled">controlled</code></dfn></td>
              <td>
                <p>controlled state</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcicetransportstate*">
      <h3><dfn>RTCIceTransportState</dfn> Enum</h3>
      <p><code>RTCIceTransportState</code> represents the current state of the
      ICE transport.</p>
      <div>
        <pre class="idl">enum RTCIceTransportState {
    "new",
    "checking",
    "connected",
    "completed",
    "disconnected",
    "failed",
    "closed"
};</pre>
        <table data-link-for="RTCIceTransportState" data-dfn-for="RTCIceTransportState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn data-idl><code id="idl-def-RTCIceTransportState.new">new</code></dfn></td>
              <td>
                <p>The <code><a>RTCIceTransport</a></code> object is waiting for remote
                candidates to be supplied. In this state the
                <code><a>RTCIceTransport</a></code> object can respond to incoming
                connectivity checks.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceTransportState.checking">checking</code></dfn></td>
              <td>
                <p>The <code><a>RTCIceTransport</a></code> has received at least one
                remote candidate, and a local and remote
                <code><a>RTCIceCandidateComplete</a></code> dictionary was not added as
                the last candidate. In this state the <code><a>RTCIceTransport</a></code>
                is checking candidate pairs but has not yet found a successful candidate
                pair, or consent checks [[!RFC7675]] have failed on all previously
                successful candidate pairs.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceTransportState.connected">connected</code></dfn></td>
              <td>
                <p>The <code><a>RTCIceTransport</a></code> has received a response to an
                outgoing connectivity check, or has received incoming DTLS/media after a
                successful response to an incoming connectivity check, but is still
                checking other candidate pairs to see if there is a better connection. In
                this state outgoing media is permitted. If consent checks [[!RFC7675]]
                fail on the connection in use, and there are no other successful
                candidate pairs available, then the state transitions to
                <code>checking</code> (if there are candidate pairs remaining to be
                checked) or <code>disconnected</code> (if there are no candidate pairs to
                check, but the peer is still gathering and/or waiting for additional
                remote candidates).</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceTransportState.completed">completed</code></dfn></td>
              <td>
                <p>A local and remote <code><a>RTCIceCandidateComplete</a></code>
                dictionary was added as the last candidate to the
                <code><a>RTCIceTransport</a></code> and all appropriate candidate pairs
                have been tested and at least one functioning candidate pair has been
                found. If consent checks [[!RFC7675]] subsequently fail on all successful
                candidate pairs, the state transitions to <code>failed</code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceTransportState.disconnected">disconnected</code></dfn></td>
              <td>
                <p>Connectivity is currently lost for this <code><a>RTCIceTransport</a></code>.
                The <code><a>RTCIceTransport</a></code> has received at least one
                local and remote candidate, and a local and remote
                <code><a>RTCIceCandidateComplete</a></code> dictionary was not added as
                the last candidate, but all appropriate candidate pairs thus far have
                been tested and failed, or consent checks [[!RFC7675]] once successful,
                have repeatedly failed to receive a response.  At the implementation's
                discretion, this state may be entered prior to consent failure, and
                therefore could resolve itself without action.  Other candidate pairs
                may become available for testing as new candidates are trickled,
                and a temporary consent failure could resolve itself, therefore
                the <code>failed</code>state has not been reached.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceTransportState.failed">failed</code></dfn></td>
              <td>
                <p>A local and remote <code><a>RTCIceCandidateComplete</a></code>
                dictionary was added as the last candidate to the
                <code><a>RTCIceTransport</a></code> and all appropriate candidate pairs
                have either failed connectivity checks or have lost consent.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCIceTransportState.closed">closed</code></dfn></td>
              <td>
                <p>The <code><a>RTCIceTransport</a></code> has shut down and is no longer
                responding to STUN requests.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Some example transitions might be:</p>
      <ul>
        <li>new RTCIceTransport(): <code>new</code></li>
        <li>(<code>new</code>, remote candidates received): <code>checking</code></li>
        <li>(<code>checking</code>, found usable connection): <code>connected</code></li>
        <li>(<code>checking</code>, checks fail but gathering still in progress):
        <code>disconnected</code></li>
        <li>(<code>checking</code>, gave up): <code>failed</code></li>
        <li>(<code>disconnected</code>, new local candidates): <code>checking</code></li>
        <li>(<code>connected</code>, finished all checks): <code>completed</code></li>
        <li>(<code>completed</code>, lost connectivity): <code>disconnected</code></li>
        <li>(any state, ICE restart occurs): <code>new</code></li>
        <li>close(): <code>closed</code></li>
      </ul>
      <figure>
        <img alt="The non-normative RTCIceTransportState transition diagram" src=
        "images/ortc-icetransportstate.svg" style="width:100%">
        <figcaption>
          Non-normative ICE transport state transition diagram
        </figcaption>
      </figure>
    </section>
    <section id="rtcicecandidatepairchangedevent-interface-definition*">
      <h3><dfn>RTCIceCandidatePairChangedEvent</dfn></h3>
      <p>The <code>icecandidatepairchange</code> event of the
      <code><a>RTCIceTransport</a></code> object uses the
      <code><a>RTCIceCandidatePairChangedEvent</a></code> interface.</p>
      <p>Firing an <code><a>RTCIceCandidatePairChangedEvent</a></code> event named
      <var>e</var> with an <code><a>RTCIceCandidatePair</a></code> <var>pair</var> means
      that an event with the name <var>e</var>, which does not bubble (except where
      otherwise stated) and is not cancelable (except where otherwise stated), and which
      uses the <code><a>RTCIceCandidatePairChangedEvent</a></code> interface with
      <var>pair</var> set to the selected <code><a>RTCIceCandidatePair</a></code>,
      <em class="rfc2119" title="MUST">MUST</em> be created and dispatched at the given
      target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCIceCandidatePairChangedEventInit eventInitDict), Exposed=Window]
interface RTCIceCandidatePairChangedEvent : Event {
    readonly        attribute RTCIceCandidatePair pair;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCIceCandidatePairChangedEvent" data-dfn-for=
          "RTCIceCandidatePairChangedEvent" class="constructors">
            <dt><code>RTCIceCandidatePairChangedEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType">
                    <code><a>RTCIceCandidatePairChangedEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIceCandidatePairChangedEvent" data-dfn-for=
          "RTCIceCandidatePairChangedEvent" class="attributes">
            <dt><dfn data-idl><code>pair</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceCandidatePair</a></span>, readonly</dt>
            <dd>
              <p>The <code>pair</code> attribute is the selected
              <code><a>RTCIceCandidatePair</a></code> that caused the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
      <p>The <dfn><code>RTCIceCandidatePairChangedEventInit</code></dfn> dictionary
      provides information on the newly selected <code>RTCIceCandidatePair</code>.</p>
        <pre class="idl">
        dictionary RTCIceCandidatePairChangedEventInit : EventInit {
             required RTCIceCandidatePair pair;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceCandidatePairChangedEventInit</a>
          Members</h2>
          <dl data-link-for="RTCIceCandidatePairChangedEventInit" data-dfn-for=
          "RTCIceCandidatePairChangedEventInit" class="dictionary-members">
            <dt><dfn data-idl><code>pair</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCandidatePair</a></span>, required</dt>
            <dd>
              <p>The <code>pair</code> attribute is the selected
              <code><a>RTCIceCandidatePair</a></code> that caused the event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcicecandidatepair*">
      <h3><dfn>RTCIceCandidatePair</dfn> Dictionary</h3>
      <p>The <code>RTCIceCandidatePair</code> contains the currently selected
      ICE candidate pair.</p>
      <div>
        <pre class="idl">dictionary RTCIceCandidatePair {
             required RTCIceCandidate local;
             required RTCIceCandidate remote;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCIceCandidatePair</a> Members</h2>
          <dl data-link-for="RTCIceCandidatePair" data-dfn-for="RTCIceCandidatePair"
          class="dictionary-members">
            <dt><dfn data-idl><code>local</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCandidate</a></span>, required</dt>
            <dd>
              <p>The local ICE candidate.</p>
            </dd>
            <dt><dfn data-idl><code>remote</code></dfn> of type <span class=
            "idlMemberType"><a>RTCIceCandidate</a></span>, required</dt>
            <dd>
              <p>The remote ICE candidate.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section class="informative" id="rtcicegatherer-example*">
      <h3>Example</h3>
      <pre class="example highlight">
      // Example to demonstrate forking when RTP and RTCP are not multiplexed,
// so that both RTP and RTCP IceGatherer and IceTransport objects are needed.
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

// Create ICE gather options
var gatherOptions = {
  gatherPolicy: "relay",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
      credentialType: "password" }
   ]
};

// Create ICE gatherer objects
var iceRtpGatherer = new RTCIceGatherer(gatherOptions);
var iceRtcpGatherer = iceRtpGatherer.createAssociatedGatherer();

// Prepare to signal local candidates
iceRtpGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "rtp", "audio",
    iceRtpGatherer.getLocalParameters());
};

iceRtcpGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "rtcp", "audio",
    iceRtpGatherer.getLocalParameters());
};

// Start gathering
iceRtpGatherer.gather();
iceRtcpGatherer.gather();

// Initialize the ICE transport arrays
var iceRtpTransports = [];
var iceRtcpTransports = [];

// Set up response function
mySignaller.onResponse = function(responseSignaller, response) {
  // We may get N responses

  // Create the ICE RTP and RTCP transports
  var iceRtpTransport = new RTCIceTransport(iceRtpGatherer);
  var iceRtcpTransport = iceRtpTransport.createAssociatedTransport();

  // Start the RTP and RTCP ICE transports so that outgoing ICE connectivity checks can begin
  // The RTP and RTCP ICE parameters are the same, so only the RTP parameters are used
  iceRtpTransport.start(iceRtpGatherer, response.icertp, RTCIceRole.controlling);
  iceRtcpTransport.start(iceRtcpGatherer, response.icertp, RTCIceRole.controlling);

  iceRtpTransports.push(iceRtpTransport);
  iceRtcpTransports.push(iceRtcpTransport);

  // Prepare to add ICE candidates signalled by the remote peer
  responseSignaller.onRemoteCandidate = function(remote) {
    // Locate the ICE transport that the signaled candidate relates to by matching
   //  the userNameFragment.
    var transports;
    if (remote.component === "rtp") {
      transports = iceRtpTransports;
    } else {
      transports = iceRtcpTransports;
    }

    for (var j = 0; j &lt; iceTransport.length; j++) {
      var transport = transports[j];
      if (transport.getRemoteParameters().userNameFragment === remote.parameters.userNameFragment)
        transport.addRemoteCandidate(remote.candidate);
      }
    }
  };
};

mySignaller.send({
  // The RTP and RTCP parameters are identical, so no need to send both
  icertp: iceRtpGatherer.getLocalParameters()
});
                </pre>
    </section>
  </section>
  <section id="rtcdtlstransport*">
    <h2><dfn>RTCDtlsTransport</dfn> Interface</h2>
    <p>The <code>RTCDtlsTransport</code> object includes information relating
    to Datagram Transport Layer Security (DTLS) transport.</p>
    <section id="rtcdtlstransport-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCDtlsTransport</a></code> instance is associated to an
      <code><a>RTCRtpSender</a></code>, an <code><a>RTCRtpReceiver</a></code>, or an
      <code><a>RTCSctpTransport</a></code> instance.</p>
    </section>
    <section id="rtcdtlstransport-operation*">
      <h3>Operation</h3>
      <p>A <code><a>RTCDtlsTransport</a></code> instance is constructed
      using an <code><a>RTCIceTransport</a></code> and a sequence of
      <code><a>RTCCertificate</a></code> objects. Although any given DTLS
      connection will use only one certificate, multiple certificates can be provided
      that support different algorithms. The final certificate will be selected
      based on the DTLS handshake, which establishes which certificates are allowed.
      An <code><a>RTCDtlsTransport</a></code> object in the <code>closed</code> or
      <code>failed</code> states can be garbage-collected when it is no longer
      referenced.</p>
      <p>Since the Datagram
      Transport Layer Security (DTLS) negotiation occurs between transport endpoints
      determined via ICE, implementations of this specification <em class="rfc2119"
      title="MUST">MUST</em> support multiplexing of STUN, TURN, DTLS and RTP and/or
      RTCP. This multiplexing, originally described in [[!RFC5764]] Section 5.1.2, is
      updated in [[!RFC7983]].</p>
      <p>A newly constructed <code><a>RTCDtlsTransport</a></code> <em class="rfc2119"
      title="MUST">MUST</em> listen and respond to incoming DTLS packets before
      <code>start()</code> is called. However, to complete the negotiation it is
      necessary to verify the remote fingerprint, which is an attribute of the
      <code><var>remoteParameters</var></code> argument passed to <code>start()</code>.
      To verify the remote fingerprint, compute the fingerprint <var>value</var> for
      the selected remote certificate using the signature digest algorithm, and compare
      it against <code><var>remoteParameters</var>.fingerprints</code>. If the selected
      remote certificate <code>RTCDtlsFingerprint.value</code> matches
      <code><var>remoteParameters</var>.fingerprints[j].value</code> and
      <code>RTCDtlsFingerprint.algorithm</code> matches
      <code><var>remoteParameters</var>.fingerprints[j].algorithm</code> for any value of
      <var>j</var>, the remote fingerprint is verified. After the DTLS handshake exchange
      completes (but before the remote fingerprint is verified) incoming media packets
      may be received. A modest buffer <em class="rfc2119" title="MUST">MUST</em> be
      provided to avoid loss of media prior to remote fingerprint validation (which can
      begin after <code>start()</code> is called).</p>
    </section>
    <section id="rtcdtlstransport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Constructor (RTCIceTransport transport, optional sequence&lt;RTCCertificate&gt; certificates), Exposed=Window]
interface RTCDtlsTransport : RTCStatsProvider  {
    readonly        attribute RTCIceTransport          transport;
    readonly        attribute RTCDtlsTransportState    state;
    sequence&lt;RTCCertificate&gt;     getCertificates ();
    RTCDtlsParameters     getLocalParameters ();
    RTCDtlsParameters?    getRemoteParameters ();
    sequence&lt;ArrayBuffer&gt; getRemoteCertificates ();
    undefined             start (RTCDtlsParameters remoteParameters);
    undefined             stop ();
                    attribute EventHandler             onstatechange;
                    attribute EventHandler             onerror;
};</pre>
        <section>
          <h2>Constructors</h2>
          When the <code><a>RTCDtlsTransport</a></code> constructor is invoked,
          the user agent MUST run the following steps:
          <ol>
            <li><p>Let <var>transport</var> be the first argument.</p></li>
            <li><p>If <var>transport</var> is in the <code>closed</code>
            state, <a>throw</a> an <code>InvalidStateError</code> and abort
            these steps.</p></li>
            <li><p>Let <var>certificates</var> be the second argument if provided, <code>null</code>
            otherwise.</p></li>
            <li><p>If the <var>certificates</var> is not <code>null</code> and is non-empty, check that the
            <code>expires</code> attribute of each <code><a>RTCCertificate</a></code> object
            is in the future. If a certificate has expired, <a>throw</a> an <code>InvalidAccessError</code>
            and abort these steps.</p></li>
            <li><p>Let <var>dtlstransport</var> be a newly constructed
            <code><a>RTCDtlsTransport</a></code> object.</p></li>
            <li><p>Let <var>dtlstransport</var> have a <dfn>[[\DtlsTransportState]]</dfn>
            internal slot, initialized to <code>new</code>.</p></li>
            <li><p>Let <var>dltsTransport</var> have <dfn>[[\SendHeaderExtensions]]</dfn>
            and <dfn>[[\ReceiveHeaderExtensions]]</dfn> internal slots initialized to
            <code>null</code>.</p></li>
            <li><p>Let <var>dtlstransport</var> have a <dfn>[[\Certificates]]</dfn>
              internal slot.</p></li>
            <li><p>If <var>certificates</var> is non-null and is non-empty, initialize
            the <a>[[\Certificates]]</a> internal slot to <var>certificates</var>.</p></li>
            <li><p>If <var>certificates</var> is <code>null</code> or is empty,
            generate a certificate using the default key generation algorithm and
            store it in the <a>[[\Certificates]]</a> internal slot.</p></li>
            <li>Return <var>dtlstransport</var>.</li>
         </ol>  
          <dl data-link-for="RTCDtlsTransport" data-dfn-for="RTCDtlsTransport" class=
          "constructors">
            <dt><code><a>RTCDtlsTransport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCIceTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">certificates</td>
                    <td class="prmType">
                    <code>sequence</code>&lt;<code><a>RTCCertificate</a></code>&gt;</td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDtlsTransport" data-dfn-for="RTCDtlsTransport" class=
          "attributes">
            <dt><dfn data-idl><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceTransport</a></span>, readonly</dt>
            <dd>
              <p>The associated <code><a>RTCIceTransport</a></code> instance.</p>
            </dd>
            <dt><dfn data-idl><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransportState</a></span>, readonly</dt>
            <dd>
              <p>The current state of the DTLS transport.</p>
            </dd>
            <dt><dfn data-idl><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <code><a>RTCDtlsTransportState</a></code>
              changes.</p>
            </dd>
            <dt><dfn data-idl><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type <code>error</code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired after a DTLS
              error. An implementation <em class="rfc2119" title=
              "SHOULD">SHOULD</em> provide more details on DTLS errors as follows: 
              <ol>
                <li>A fingerprint validation failure is indicated by setting
                  <code>error.name</code> to "fingerprint-failure".</li>
                <li>Reception of a DTLS alert is indicated by setting
                  <code>error.name</code> to "dtls-alert-received".</li>
                <li>Sending of a DTLS alert is indicated by setting <code>error.name</code>
                   to "dtls-alert-sent".</li>
                <li>The DTLS alert value is provided by setting <code>error.message</code> 
                  (defined in [[!HTML5]] Section 6.1.3.6.2) to "DTLS Alert: <number>".</li>
              </ol>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDtlsTransport" data-dfn-for="RTCDtlsTransport" class=
          "methods">
            <dt><dfn data-idl><code>getCertificates()</code></dfn></dt>
            <dd>
              <p>Returns the certificates provided in the constructor.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;RTCCertificate&gt;</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getLocalParameters()</code></dfn></dt>
            <dd>
              <p>Obtains the DTLS parameters of
              the local <code><a>RTCDtlsTransport</a></code> upon construction.
              If multiple certificates were provided in the constructor, then
              multiple fingerprints will be returned, one for each certificate.
              <code>getLocalParameters().role</code> always returns the default
              role of a newly constructed <code><a>RTCDtlsTransport</a></code>;
              for a browser this will be <code>auto</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCDtlsParameters</a></code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getRemoteParameters()</code></dfn></dt>
            <dd>
              <p>Obtains the remote DTLS parameters passed in the
              <code>start()</code> method. Prior to calling
              <code>start()</code>, null is returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCDtlsParameters</a></code>, nullable
              </div>
            </dd>
            <dt><dfn data-idl><code>getRemoteCertificates()</code></dfn></dt>
            <dd>
              <p>Returns the certificate chain in use
              by the remote side, with each certificate encoded in binary Distinguished
              Encoding Rules (DER) [[!X690]]. <code>getRemoteCertificates()</code>
              returns an empty list prior to selection of the remote certificate, which
              is completed by the time <code>state</code> transitions to <code>connected</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;ArrayBuffer&gt;</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>start</code></dfn></dt>
            <dd>
              <p>Start DTLS transport negotiation with the parameters of the remote DTLS
              transport, including verification of the remote fingerprint, then once the
              DTLS transport session is established, negotiate a <dfn>DTLS-SRTP</dfn>
              [[!RFC5764]] session to establish keys so as protect media using SRTP
              [[!RFC3711]]. Since symmetric RTP [[!RFC4961]] is utilized, the
              <a>DTLS-SRTP</a> session is bi-directional.</p>
              <p>Only a single DTLS transport can be multiplexed over an ICE transport.
              Therefore if a <code><a>RTCDtlsTransport</a></code> object
              <var>dtlsTransportB</var> is constructed with an
              <code><a>RTCIceTransport</a></code> object <var>iceTransport</var>
              previously used to construct another <code><a>RTCDtlsTransport</a></code>
              object <var>dtlsTransportA</var>, then if
              <code>dtlsTransportB.start()</code> is called prior to having called
              <code>dtlsTransportA.stop()</code>, then <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <p>If <code>start</code> is called after a previous <code>start</code>
              call, or if <code>state</code> is <code>closed</code>, <a>throw</a>
              an <code>InvalidStateError</code>.</p>
              <p>If all of the values of
              <code><var>remoteParameters</var>.fingerprints[<var>j</var>].algorithm</code>
              are unsupported, where <var>j</var> goes from 0 to the number of fingerprints,
              <a>throw</a> a <code>NotSupportedError</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">remoteParameters</td>
                    <td class="prmType"><code><a>RTCDtlsParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>stop</code></dfn></dt>
            <dd>
              <p>Stops and closes the <code><a>RTCDtlsTransport</a></code> object.
              Calling <code>stop()</code> when <code>state</code> is <code>closed</code>
              has no effect.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcdtlsparameters*">
      <h3><dfn>RTCDtlsParameters</dfn> Dictionary</h3>
      <p>The <code>RTCDtlsParameters</code> dictionary includes information
      relating to DTLS configuration.</p>
      <div>
        <pre class="idl">dictionary RTCDtlsParameters {
             RTCDtlsRole                  role = "auto";
             required sequence&lt;RTCDtlsFingerprint&gt; fingerprints;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDtlsParameters</a> Members</h2>
          <dl data-link-for="RTCDtlsParameters" data-dfn-for="RTCDtlsParameters" class=
          "dictionary-members">
            <dt><dfn data-idl><code>role</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDtlsRole</a></span>, defaulting to
            <code>"auto"</code></dt>
            <dd>
              <p>The DTLS role, with a default of <code>auto</code>.</p>
            </dd>
            <dt><dfn data-idl><code>fingerprints</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCDtlsFingerprint</a>&gt;</span>, required</dt>
            <dd>
              <p>Sequence of fingerprints, one fingerprint for each certificate.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcdtlsfingerprint*">
      <h3><dfn>RTCDtlsFingerprint</dfn> Dictionary</h3>
      <p>The <code>RTCDtlsFingerprint</code> dictionary includes the hash function
      algorithm and certificate fingerprint as described in [[!RFC4572]].</p>
      <div>
        <pre class="idl">dictionary RTCDtlsFingerprint {
             required DOMString algorithm;
             required DOMString value;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDtlsFingerprint</a> Members</h2>
          <dl data-link-for="RTCDtlsFingerprint" data-dfn-for="RTCDtlsFingerprint" class=
          "dictionary-members">
            <dt><dfn data-idl><code>algorithm</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>One of the the hash function algorithms defined in the 'Hash function
              Textual Names' registry, initially specified in [[!RFC4572]] Section 8. As
              noted in [[!JSEP]] Section 5.2.1, the digest algorithm used for the
              fingerprint matches that used in the certificate signature.</p>
            </dd>
            <dt><dfn data-idl><code>value</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcdtlsrole*">
      <h3><dfn>RTCDtlsRole</dfn> Enum</h3>
      <p><code>RTCDtlsRole</code> indicates the role of the DTLS
      transport.</p>
      <div>
        <pre class="idl">enum RTCDtlsRole {
    "auto",
    "client",
    "server"
};</pre>
        <table data-link-for="RTCDtlsRole" data-dfn-for="RTCDtlsRole" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn data-idl><code id="idl-def-RTCDtlsRole.auto">auto</code></dfn></td>
              <td>
                <p>The DLTS role is determined based on the resolved ICE role:
                the ICE <code>controlled</code> role acts as the DTLS client and
                the ICE <code>controlling</code> role acts as the DTLS server.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id="idl-def-RTCDtlsRole.client">client</code></dfn></td>
              <td>
                <p>The DTLS client role.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id="idl-def-RTCDtlsRole.server">server</code></dfn></td>
              <td>
                <p>The DTLS server role.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcdtlsroleinfo">
       <h3>DTLS role determination</h3>
      <p>To diagnose DTLS role issues, an application may wish to determine
      the desired and actual DTLS role of an <code><a>RTCDtlsTransport</a></code>.
      For a browser implementing ORTC, a <code><a>RTCDtlsTransport</a></code>
      object assumes a DTLS role of <code>auto</code> upon construction.
      This implies that the DTLS role is determined by the ICE role.  Since
      <code>getLocalParameters().role</code> always returns the role assigned
      to an <code><a>RTCDtlsTransport</a></code> object upon construction
      (<code>auto</code> for a browser), the <code>getLocalParameters</code>
      method cannot be used to determine the desired or actual role of an
      <code><a>RTCDtlsTransport</a></code>.</p>
      <p>An application can determine the
      desired role of an <code><a>RTCDtlsTransport</a></code> from the value of
      <code><var>remoteParameters</var>.role</code> passed to
      <code><a>RTCDtlsTransport</a>.start(<var>remoteParameters</var>)</code>.
      If <code><var>remoteParameters</var>.role</code> is <code>server</code>
      then the desired role of the <code><a>RTCDtlsTransport</a></code>
      is <code>client</code>. If <code><var>remoteParameters</var>.role</code>
      is <code>client</code> then the desired role of the
      <code><a>RTCDtlsTransport</a></code> is <code>server</code>.</p>
      <p>The <code>RTCDtlsTransport.transport.onstatechange</code> EventHandler
      can be used to determine whether an <code><a>RTCDtlsTransport</a></code>
      transitions to the desired role as expected. When
      <code><a>RTCDtlsTransport</a>.transport.state</code> transitions to
      <code>connected</code>, if <code><a>RTCDtlsTransport</a>.transport.role</code>
      is <code>controlled</code> then the role of the
      <code><a>RTCDtlsTransport</a></code> is <code>client</code>.
      If <code><a>RTCDtlsTransport</a>.transport.role</code>
      is <code>controlling</code> then the role of the
      <code><a>RTCDtlsTransport</a></code> is <code>server</code>.</p>
    </section>
    <section id="rtcdtlstransportstate*">
      <h3><dfn>RTCDtlsTransportState</dfn> Enum</h3>
      <p><code>RTCDtlsTransportState</code> indicates the state of the DTLS
      transport.</p>
      <div>
        <pre class="idl">enum RTCDtlsTransportState {
    "new",
    "connecting",
    "connected",
    "closed",
    "failed"
};</pre>
        <table data-link-for="RTCDtlsTransportState" data-dfn-for="RTCDtlsTransportState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn data-idl><code id="idl-def-RTCDtlsTransportState.new">new</code></dfn></td>
              <td>
                <p>The <code><a>RTCDtlsTransport</a></code> object has been created and
                has not started negotiating yet.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCDtlsTransportState.connecting">connecting</code></dfn></td>
              <td>
                <p>DTLS is in the process of negotiating a secure connection and
                verifying the remote fingerprint. Once a secure connection is negotiated
                (but prior to verification of the remote fingerprint, enabled by calling
                <code>start()</code>), incoming data can flow through (and media, once
                <a>DTLS-SRTP</a> key derivation is completed).</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCDtlsTransportState.connected">connected</code></dfn></td>
              <td>
                <p>DTLS has completed negotiation of a secure connection and verified the
                remote fingerprint. Outgoing data and media can now flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCDtlsTransportState.closed">closed</code></dfn></td>
              <td>
                <p>The DTLS connection has been closed intentionally via a call to
                <code>stop()</code> or receipt of a close_notify alert. Calling
                <code>transport.stop()</code> will also result in a transition to the
                <code>closed</code> state.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCDtlsTransportState.failed">failed</code></dfn></td>
              <td>
                <p>The DTLS connection has been closed as the result of an error (such as
                receipt of an error alert or a failure to validate the remote
                fingerprint).</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section class="informative" id="rtcicetransport-example1*">
      <h3>Examples</h3>
      <pre class="example highlight">
      // This is an example of how to offer ICE and DTLS parameters and
// ICE candidates and get back ICE and DTLS parameters and ICE candidates,
// and start both ICE and DTLS, when RTP and RTCP are multiplexed.
// Assume that we have a way to signal (mySignaller).
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

function initiate(mySignaller) {
  // Prepare the ICE gatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

  // Start gathering
  iceGatherer.gather();

  // Initialize the ICE and DTLS transport arrays
  var iceTransports = [];
  var dtlsTransports = [];

  // Create the DTLS certificate and parameters
  var certs;
  var dtlsParameters = {};
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
    // Obtain the fingerprint of the created certificate
    dtlsParameters.fingerprints[0] = certificate.fingerprint;
  }, function(){
    trace('Certificate could not be created');
  });
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    // Figure out which IceTransport a remote candidate relates to by matching
    // the userNameFragment/password
    var j = 0;
    for (j = 0; j &lt; iceTransport.length; j++) {
      var transport = iceTransports[j];
      if (transport.getRemoteParameters().userNameFragment === remote.parameters.userNameFragment)
        transport.addRemoteCandidate(remote.candidate);
      }
    }  };
  // ... construct RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.

  mySignaller.mySendInitiate({
    ice: iceGatherer.getLocalParameters(),
    dtls: dtlsParameters,
    // ... marshall RtpSender/RtpReceiver capabilities as in Section 6.6 Examples 8 and 9.
  }, function(remote) {
    // Create the ICE and DTLS transports
    var iceTransport = new RTCIceTransport(iceGatherer);
    iceTransport.start(iceGatherer, remote.ice, RTCIceRole.controlling);
    iceTransports.push(iceTransport);
    // Construct a RTCDtlsTransport object with the same certificate and fingerprint
    // as in the Offer so that the remote peer can verify it.
    var dtlsTransport = new RTCDtlsTransport(iceTransport, certs);
    dtlsTransport.start(remote.dtls);
    dtlsTransports.push(dtlsTransport);

    // ... configure RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.
  });
}
                </pre>
      <pre class="example highlight">
      // This is an example of how to answer with ICE and DTLS
// and DTLS parameters and ICE candidates and start both ICE and DTLS,
// assuming that RTP and RTCP are multiplexed.
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

// Assume that remote info is signalled to us.
function accept(mySignaller, remote) {
  // Prepare the ICE gatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

  // Start gathering
  iceGatherer.gather();

  // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create ICE and DTLS transports
  var ice = new RTCIceTransport(iceGatherer);
  var dtls = new RTCDtlsTransport(ice, certs);

  // Prepare to handle remote candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };
  // ... create RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.

  mySignaller.mySendAccept({
    ice: iceGatherer.getLocalParameters(),
    dtls: dtls.getLocalParameters()
    // ... marshall RtpSender/RtpReceiver capabilities as in Section 6.6 Examples 8 and 9.
  });

  // Start the ICE transport with an implicit gather policy of "all"
  ice.start(iceGatherer, remote.ice, RTCIceRole.controlled);

  // Start the DTLS transport
  dtls.start(remote.dtls);

  // ... configure RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.
}
                </pre>
    </section>
  </section>
  <section id="rtcrtpsender*">
    <h2><dfn>RTCRtpSender</dfn> Interface</h2>
    <p>The <code>RTCRtpSender</code> includes information relating to the RTP
    sender.</p>
    <section id="rtcrtpsender-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCRtpSender</a></code> instance is associated to a sending
      <a>MediaStreamTrack</a> and provides RTC related methods to it.</p>
    </section>
    <section id="rtcrtpsender-operation*">
      <h3>Operation</h3>
      <p>A <code><a>RTCRtpSender</a></code> instance is constructed from an
      <a>MediaStreamTrack</a> object or <code>kind</code> and associated to an
      <code><a>RTCDtlsTransport</a></code>. An <code><a>RTCRtpSender</a></code>
      object can be garbage-collected once <code>stop()</code> is called and
      it is no longer referenced.</p>
    </section>
    <section id="rtcrtpsender-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Constructor ((MediaStreamTrack or DOMString) trackOrKind, optional RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport), Exposed=Window]
interface RTCRtpSender : RTCStatsProvider {
    readonly        attribute MediaStreamTrack?  track;
    readonly        attribute RTCDtlsTransport?  transport;
    readonly        attribute RTCDtlsTransport? rtcpTransport;
    readonly        attribute DOMString kind;
    undefined                 setTransport (RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport);
    Promise&lt;undefined&gt;  setTrack (MediaStreamTrack? track);  // deprecated
    Promise&lt;undefined&gt;  replaceTrack (MediaStreamTrack? track);
    static RTCRtpCapabilities getCapabilities (DOMString kind);
    Promise&lt;undefined&gt;  send (RTCRtpSendParameters parameters);
    undefined                 stop ();
                    attribute EventHandler      onssrcconflict;
};</pre>
        <section>
          <h2>Constructors</h2>
          <p>When the constructor is invoked, the <a>user agent</a> MUST run the
              following steps:</p>
              <ol>
                <li>Let the first argument be <var>trackOrKind</var>.</li>
                <li>If <var>trackOrKind</var> is a DOMString and is not a supported
                <code><a>MediaStreamTrack</a></code> <code>kind</code>,
                <a>throw</a> a <code>TypeError</code> and abort these steps.</li>
                <li>If <var>trackOrKind</var> is a <code>MediaStreamTrack</code>
                and <code><var>trackOrKind</var>.readyState</code> is <code>ended</code>,
                <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
                <li>Let <var>transport</var> be the second argument.</li>
                <li>Let <var>rtcpTransport</var> be the third argument.</li>
                <li>If <var>transport</var> is unset, and <var>rtcpTransport</var>
                is set, <a>throw</a> an <code>InvalidParameters</code> and
                abort these steps.</li>
                <li>If <var>transport</var> is set and <code><var>transport</var>.state</code>
                is <code>closed</code>, <a>throw</a> an
                <code>InvalidStateError</code> and abort these steps.</li>
                <li>If <var>rtcpTransport</var> is set and <code><var>rtcpTransport</var>.state</code>
                is <code>closed</code>, <a>throw</a> an
                <code>InvalidStateError</code> and abort these steps.</li>
                <li>Construct an <code><a>RTCRtpSender</a></code> with <var>transport</var>
                (if provided) and <var>rtcpTransport</var> (if provided) and let
                <var>sender</var> be the result.</li>
                <li>Let <var>sender</var> have an <dfn>[[\SenderStopped]]</dfn> internal slot,
                initialized to <code>false</code>.</li>
                <li>Let <var>sender</var> have a <dfn>[[\SenderKind]]</dfn> internal slot.</li>
                <li>Let <var>sender</var> have a <dfn>[[\SenderTrack]]</dfn> internal slot.</li>
                <li>If <var>trackOrKind</var> is a <code>MediaStreamTrack</code> initialize
                <var>sender</var>'s <a>[[\SenderTrack]]</a> slot to <var>trackOrKind</var> and
                <var>sender</var>'s <a>[[\SenderKind]]</a> slot to <code><var>trackOrKind</var>.kind</code>.</li>
                <li>If <var>trackOrKind</var> is a DOMString initialize <var>sender</var>'s
                <a>[[\SenderTrack]]</a> internal slot to <code>null</code> and
                <var>sender</var>'s <a>[[\SenderKind]]</a> slot to <var>trackOrKind</var>.</li>
              </ol>
          <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
          "constructors">
            <dt><code><a>RTCRtpSender</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">trackOrKind</td>
                    <td class="prmType"><code>(MediaStreamTrack or
                    DOMString)</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code>RTCDtlsTransport</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">rtcpTransport</td>
                    <td class="prmType"><code>RTCDtlsTransport</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class=
          "attributes">
            <dt><dfn data-idl><code>track</code></dfn> of type <span class=
            "idlAttrType"><a>MediaStreamTrack</a></span>, readonly , nullable</dt>
            <dd>
              <p>The associated <code><a>MediaStreamTrack</a></code> instance.
              If <code>track</code> is ended, or if
              <code>track</code>.<var>muted</var> is set to <code>true</code>,
              the <code>RTCRtpSender</code> sends silence (audio) or a black
              frame (video). If <code>track</code> is set to null then
              the <code><a>RTCRtpSender</a></code> does not send RTP.</p>
            </dd>
            <dt><dfn data-idl><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <code><a>RTCDtlsTransport</a></code> instance over which RTCP is
              sent and received (if provided). When BUNDLE is used, many
              <code><a>RTCRtpSender</a></code> objects will share one
              <code>rtcpTransport</code> and will all send and receive RTCP over the same
              <code><a>RTCDtlsTransport</a></code>. When RTCP mux is used,
              <code>rtcpTransport</code> will be null, and both RTP and RTCP traffic will
              flow over the <code><a>RTCDtlsTransport</a></code>
              <var>transport</var>.</p>
            </dd>
            <dt><dfn data-idl><code>rtcpTransport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly , nullable</dt>
            <dd>
              <p>The associated RTCP <code><a>RTCDtlsTransport</a></code> instance if one
              was provided in the constructor. When RTCP mux is used,
              <code>rtcpTransport</code> will be null, and both RTP and RTCP traffic will
              flow over the <code><a>RTCDtlsTransport</a></code>
              <var>transport</var>.</p>
            </dd>
            <dt><dfn data-idl><code>kind</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The value of <code>kind</code> or <code>track.kind</code>
              passed in the constructor.</p>
            </dd>
            <dt><dfn data-idl><code>onssrcconflict</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The <code>onssrcconflict</code> event handler, of event
              handler type <code><a>RTCSsrcConflictEvent</a></code>, is fired if an SSRC
              conflict is detected within the RTP session or an SSRC misconfiguration is
              detected after <code><a>send</a>()</code> or <code><a>receive</a>()</code>
              returns or when <code>setTransport</code> is called. In this
              situation, the <code><a>RTCRtpSender</a></code> automatically sends an RTCP
              BYE on the conflicted SSRC, if RTP packets were sent using that SSRC.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCRtpSender" data-dfn-for="RTCRtpSender" class="methods">
            <dt><dfn data-idl><code>setTransport()</code></dfn></dt>
            <dd>
              <p>Attempts to replace the the RTP <code><a>RTCDtlsTransport</a></code>
              <code>transport</code> (if set) and RTCP <code><a>RTCDtlsTransport</a></code>
              <code>rtcpTransport</code> (if used) with the transport(s) provided.</p>
              <p>When the <code>setTransport</code> method is invoked, the user
              agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>sender</var> be the <code><a>RTCRtpSender</a></code> object
                  on which <code>setTransport()</code> is invoked.</p>
                </li>
                <li>
                  <p>If <var>sender</var>'s <a>[[\SenderStopped]]</a> slot is <code>true</code>,
                  <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>withTransport</var> and <var>withRtcpTransport</var>
                  be the arguments to this method.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var></code> is null and
                  <code><var>withRtcpTransport</var></code> is set, <a>throw</a> an
                  <code>OperationError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var></code> is set and
                  <code><var>withTransport</var>.transport.component</code> is
                  <code>rtcp</code>, <a>throw</a> an <code>InvalidParameters</code>.</p>
                </li>
                <li>
                  <p>If <code><var>withRtcpTransport</var></code> is set and
                  <code><var>withRtcpTransport</var>.transport.component</code> is
                  <code>rtp</code>, <a>throw</a> an <code>InvalidParameters</code>.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var></code> is set and
                  <code><var>withTransport</var>.state</code> is
                  <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>.</p>
                </li>
                <li>
                  <p>If <code><var>withRtcpTransport</var></code> is set and
                  <code><var>withRtcpTransport</var>.state</code> is
                  <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>.</p>
                </li>
                <li>
                  <p>Set <code>transport</code> to <var>withTransport</var> and
                  <code>rtcpTransport</code> to <var>withRtcpTransport</var>.</p>
                </li>
                  <p>If <code>transport</code> is set and <code>transport.state</code>
                  is not <code>failed</code>, seamlessly send over the new transport(s).</p>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">rtcpTransport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><code>setTrack</code></dt>
            <dd>
              <p><dfn data-idl>setTrack</dfn> Attempts to replace the track being sent with another track
              provided (or with a null track). The deprecated <code>setTrack</code>
              method operates identically to the <code><a>replaceTrack</a></code> method.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">track</td>
                    <td class="prmType"><code><a>MediaStreamTrack</a></code></td>
                    <td class="prmNullTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;undefined&gt;</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>replaceTrack</code></dfn></dt>
            <dd>
              <p>Attempts to replace the track being sent with another track
              provided (or with a null track).</p>
              <p>When the <code>replaceTrack</code> method is invoked, the user
              agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>p</var> be a new promise.</p>
                </li>
                <li>
                  <p>Let <var>sender</var> be the <code><a>RTCRtpSender</a></code> object
                  on which <code>replaceTrack()</code> is invoked.</p>
                </li>
                <li>If <var>sender</var>'s <a>[[\SenderStopped]]</a> slot is <code>true</code>,
                  <a>reject</a> <var>p</var> with a newly created <code>InvalidStateError</code>.</li>
                <li>
                  <p>Let <var>withTrack</var> be the argument to this method.</p>
                </li>
                <li>
                  <p>If <var>withTrack</var> is non-null and
                  <code><var>withTrack</var>.kind</code> differs from
                  <code><var>sender</var>.kind</code>, <a>reject</a>
                  <var>p</var> with a newly created <code>TypeError</code>.</p>
                </li>
                <li>
                  <p>Run the following steps:</p>
                  <ol>
                    <li>
                      <p>Set the <code>track</code> attribute to
                      <var>withTrack</var>. If <var>withTrack</var> is null,
                      the sender stops sending.  Otherwise, have the sender
                      seamlessly switch to transmitting
                      <var>withTrack</var> in place of what it is sending.</p>
                    </li>
                    <li>
                      <p><a>Resolve</a> <var>p</var> with <code>undefined</code>.</p>
                    </li>
                  </ol>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">track</td>
                    <td class="prmType"><code><a>MediaStreamTrack</a></code></td>
                    <td class="prmNullTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;undefined&gt;</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getCapabilities()</code></dfn>, static</dt>
            <dd>
              <p>Obtains the sender capabilities,
              based on <code><var>kind</var></code>. Browsers
              MUST support <var>kind</var> values of <code>"audio"</code>
              and <code>"video"</code>. If there are no capabilities
              corresponding to the value of <code><var>kind</var></code>,
              <code>getCapabilities</code> returns <code>null</code>. Capabilities
              that can apply to multiple values of <code><var>kind</var></code>
              (such as retransmission [[!RFC4588]], redundancy [[RFC2198]]
              and Forward Error Correction) have
              <code>RTCRtpCapabilities.RTCRtpCodecCapability[<var>i</var>].kind</code>
              set to the value of the <code><var>kind</var></code> argument.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">kind</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code><a>RTCRtpCapabilities</a></code>
              </div>
            </dd>
            <dt><dfn data-idl><code>send</code></dfn></dt>
            <dd>
              <p>Attempts to set the parameters controlling the sending of media.</p>
              <p>When the <code>send()</code> method is invoked, the <a>user agent</a> MUST run
              the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>sender</var> be the <code><a>RTCRtpSender</a></code> object
                  on which <code><a>send</a>()</code> is invoked.</p>
                </li>
                <li>
                  <p>Let <var>p</var> be a new promise.</p>
                </li>
                <li>
                  <p>If <var>sender</var>'s <a>[[\SenderStopped]]</a> slot is
                   <code>true</code>, <a>reject</a> <var>p</var> with a newly created
                   <code>InvalidStateError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>If <code>transport</code> is unset, <a>reject</a>
                  <var>p</var> with a newly created <code>TypeError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>withParameters</var> be the argument to this method.</p>
                </li>
                <li>
                  <p>If <code>rtcpTransport</code> is unset and
                  <code><var>withParameters</var>.rtcp.mux</code> is set to <code>false</code>,
                  <a>reject</a> <var>p</var> with a newly created <code>TypeError</code> and abort these steps.</p>
                </li>
                <li><a>Complete validation checks</a> on <var>withParameters</var>.</li>
                <li>
                  <p>Run the following steps:</p>
                  <ol>
                    <li>
                      <p>If <code><a>send</a>()</code> is called for the first time,
                      start sending. If <code><a>send</a>()</code> was called previously,
                      have the sender switch to sending using <var>withParameters</var>.</p>
                    </li>
                    <li>
                      <p><a>Resolve</a> <var>p</var> with <code>undefined</code>.</p>
                    </li>
                  </ol>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">parameters</td>
                    <td class="prmType"><code><a>RTCRtpSendParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;undefined&gt;</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>stop</code></dfn></dt>
            <dd>
              <p>The <code>stop</code> method irreversibly stops the
              <code><a>RTCRtpSender</a></code>. When <code>stop</code>
              called, the following steps MUST be run:<p>
              <ol>
                 <li>Let <var>sender</var> be the <code><a>RTCRtpSender</a></code>
                 on which <code>stop</code> is invoked.</li>
                 <li>If <var>sender</var>'s <a>[[\SenderStopped]]</a> slot is
                 <code>true</code>, abort these steps.</li>
                 <li>
                  <p>Let <var>parameters</var> be the argument provided to
                  <code><var>sender</var>.send(<var>parameters</var>)</code> the
                  last time it was invoked.</p>
                </li>
                 <li>
                   <p>Stop sending media with <var>sender</var>.<p>
                </li>
                <li>
                  <p>Send an RTCP BYE for each SSRC in
                  <code><var>parameters</var>.encodings[<var>i</var>].ssrc</code>,
                  <code><var>parameters</var>.encodings[<var>i</var>].fec.ssrc</code> and
                  <code><var>parameters</var>.encodings[<var>i</var>].rtx.ssrc</code>
                  where <var>i</var> goes from 0 to <code>encodings.length-1</code>.<p>
                </li>
                <li>
                  <p>Remove <code><var>parameters</var>.headerExtensions</code> from
                  <code><var>sender</var>.transport</code>'s <a>[[\SenderHeaderExtensions]]</a>
                  internal slot.</p>
                </li>
                <li>Set <var>sender</var>'s <a>[[\SenderStopped]]</a> slot to <code>true</code>.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtpparameter-validation*">
      <h3>Parameters validation</h3>
          <p>To <dfn>Complete validation checks</dfn> on the argument to <code>send</code> or <code>receive</code>, 
          the <a>User Agent</a> MUST run the following steps:</p>
          <ol>
            <li><p>Let <var>withParameters</var> be the argument to <code>send</code> or <code>receive</code>.</p></li>
            <li>
               <p>For <code>send</code>, let <var>kind</var> be the value of <code>track.kind</code> and let
               <var>sender</var> be the <code><a>RTCRtpSender</a></code> on which the <code>send</code> method is invoked.
               For <code>receive</code>, let <var>kind</var> be the first argument passed to the
               <code><a>RTCRtpReceiver</a></code> constructor and let <var>receiver</var> be the
               <code><a>RTCRtpReceiver</a></code> on which the <code>receive</code> method is invoked.</p>
            </li>
            <li>
               <p>For <code>send</code>, let <var>transport</var> be the value of <code><var>sender</var>.transport</code>.
               Let <var>capabilities</var> be the value of <code>RTCRtpSender.getCapabilities(<var>kind</var>)</code>.</p>
            </li>
            <li>
              <p>For <code>receive</code>, let <var>transport</var> be the value of <code><var>receiver</var>.transport</code>.
              Let <var>capabilities</var> be the value of <code>RTCRtpReceiver.getCapabilities(<var>kind</var>)</code>.</p>
            </li>
            <li>
              <p>For each value of <var>i</var> from 0 to the number of codecs, check
              that each value of <code><var>withParameters</var>.codecs[i].payloadType</code> is
              set. If any value is unset, <a>reject</a> <var>p</var> with a newly created
              <code>TypeError</code> and abort all of these steps.</p>
            </li>
            <li>
             <p>For each value of <var>i</var> from 0 to the number of codecs:</p>
             <ol>
                <li>
                  <p>Let <var>codec</var> be <code><var>withParameters</var>.codecs[<var>i</var>]</code>.</p>
                </li>
                <li><p>Let <var>clockRate</var> be <code><var>codec</var>.clockRate</code>.</p></li>
                <li><p>Let <var>name</var> be <code><var>codec</var>.name</code>.</p></li>
                <li>
                  <p>If <var>name</var> or <var>clockrate</var> is unset, <a>throw</a> a
                  <code>TypeError</code> and abort all of these steps.</p>
                </li>
                <li>
                  <p>If <var>name</var> is not equal to "red", "rtx" or a forward
                  error correction codec ("ulpfec" [[RFC5109]] or "flexfec" [[FLEXFEC]]),
                  check whether <var>name</var> is equal to
                  <code><var>capabilities</var>.codecs[<var>j</var>].name</code> and
                  if <code><var>capabilities</var>.codecs[<var>j</var>].clockRate</code> is set,
                  check whether <var>clockRate</var> is equal to
                  <code><var>capabilities</var>.codecs[<var>j</var>].clockRate</code>
                  for any value of <var>j</var> from 0 to the number of codecs.</p>
                </li>
                <li>
                  <p>If a match is found for a value of <var>j</var>, check that:
                  <ol>
                    <li>
                      <p>If <code><var>codec</var>.channels</code> is set, check that it is
                      less than or equal to
                      <code><var>capabilities</var>.codecs[<var>j</var>].channels</code>.
                      If not, <a>reject</a> <var>p</var> with a newly created
                      <code>NotSupportedError</code> and abort all of these steps.</p>
                    </li>
                    <li>
                      <p>Each of the values of <code><var>codec</var>.rtcpFeedback[<var>k</var>].type</code>
                      is included in <code><var>capabilities</var>.codecs[<var>j</var>].rtcpFeedback.type</code>
                      where <var>k</var> goes from 0 to the number of feedback mechanisms.
                      If not, <a>reject</a> <var>p</var> with a newly created
                      <code>NotSupportedError</code> and abort all of these steps.</p>
                    </li>
                    <li>
                      <p>Each of the values of <code><var>codec</var>.parameters[<var>k</var>]</code>
                      is a valid value as indicated by <code><var>capabilities</var>.codecs[<var>j</var>].parameters</code>
                      where <var>k</var> goes from 0 to the number of codecs.
                      If not, <a>reject</a> <var>p</var> with a newly created
                      <code>NotSupportedError</code> and abort all of these steps.</p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>If a match is not found for any value of <var>j</var>, <a>reject</a> <var>p</var> with a newly
                  created <code>TypeError</code> and abort all of these steps.</p>
                </li>
             </ol>
            </li>
            <li>
              <p>For each value of <var>i</var> from 0 to the number of encodings:</p>
              <ol>
                 <li>
                   <p>Let <var>payloadType</var> be
                    <code><var>withParameters</var>.encodings[<var>i</var>].codecPayloadType</code>.</p>
                 </li>
                 <li>
                   <p>If <var>payloadType</var> is set, check whether <var>payloadType</var> is equal to
                   <code><var>withParameters</var>.codecs[<var>j</var>].payloadType</code>
                   for values of <var>j</var> from 0 to the number of codecs. If a match is
                   found for any value of <var>j</var>, check whether
                   <code><var>withParameters</var>.codecs[<var>j</var>].name</code> is equal to
                   "red", "cn", "telephone-event", "rtx" or a forward error correction codec
                   ("ulpfec" [[RFC5109]] or "flexfec" [[FLEXFEC]]).  If so, <a>reject</a>
                   <var>p</var> with a newly created <code>InvalidParameters</code> and abort these steps.</p>
                 </li>
                 <li>
                   <p>If no match is found, <a>reject</a> <var>p</var> with a newly created
                   <code>InvalidParameters</code> and abort all of these steps.</p>
                 </li>
                 <li>
                   <p>Let <var>ssrc</var> be
                   <code><var>withParameters</var>.encodings[<var>i</var>].ssrc</code>.</p>
                 </li>
                 <li>
                   <p>Let <var>dep</var> be
                   <code><var>withParameters</var>.encodings[<var>i</var>].dependencyEncodingIds</code>.</p>
                 </li>
                 <li>
                   <p>If <var>ssrc</var> is set and <var>dep</var> is unset, check that
                   <var>ssrc</var> is unique. If not, <a>reject</a> <var>p</var> with a newly created
                   <code>NotSupportedError</code> and abort all of these steps.</p>
                 </li>
              </ol>
            </li>
            <li>
              <p>For each value of <var>i</var> from 0 to the number of header extensions:</p>
              <ol>
                <li>
                   <p>Let <var>headerExtension</var> be
                    <code><var>withParameters</var>.headerExtensions[<var>i</var>]</code>.</p>
                </li>
                <li><p>Let <var>uri</var> be <code><var>headerExtension</var>.uri</code>.</p></li>
                <li><p>Let <var>id</var> be <code><var>headerExtension</var>.id</code>.</p></li>
                <li>
                  <p>If <var>uri</var> or <var>id</var> is unset, <a>reject</a> <var>p</var>
                  with a newly created <code>TypeError</code> and abort all of these steps.</p>
                </li>
                <li>
                  <p>Check whether <var>uri</var> is equal to
                  <code><var>capabilities</var>.headerExtensions[<var>j</var>].uri</code>
                  for any value of <var>j</var> from 0 to the number of header extensions.</p>
                </li>
                <li>
                  <p>If no match is found, <a>reject</a> <var>p</var> with a newly created
                  <code>InvalidParameters</code> and abort all of these steps.</p>
                </li>
                <li>
                  <p>Check whether <var>id</var> is equal to
                  <code><var>withParameters</var>.headerExtensions[<var>j</var>].id</code>
                  for each value of <var>j</var> from 0 to the number of header extensions.</p>
                </li>
                <li>
                  <p>If matches are found and <var>j</var> != <var>i</var>, <a>reject</a>
                  <var>p</var> with a newly created <code>InvalidParameters</code> and abort
                  all of these steps.</p>
                </li>
                <li>
                  <p>Check whether <var>uri</var> is equal to
                  <code><var>withParameters</var>.headerExtensions[<var>j</var>].uri</code>
                  for any value of <var>j</var> from 0 to the number of header extensions.</p>
                </li>
                <li>
                  <p>If matches are found and <var>j</var> != <var>i</var>, <a>reject</a>
                  <var>p</var> with a newly created <code>InvalidParameters</code> and abort
                  all of these steps.</p>
                </li>
                <li>For <code>receive</code>, check whether MID header extensions
                  with different values of <code>id</code> have been configured on
                  other <code><a>RTCRtpReceiver</a></code>s sharing the
                  <code><a>RTCDtlsTransport</a></code> <var>transport</var>. 
                  If conflicts are found, <a>reject</a> <var>p</var> with a
                  newly created <code>InvalidParameters</code> and abort all of
                  these steps.</p>
                </li>
              </ol>
            </li>
          </ol>
    </section>
    <section id="rtcsssrcconflictevent-interface-definition*">
      <h3><dfn>RTCSsrcConflictEvent</dfn></h3>
      <p>The <code><a>ssrcconflict</a></code> event of the
      <code><a>RTCRtpSender</a></code> object uses the
      <code><a>RTCSsrcConflictEvent</a></code> interface.</p>
      <p>Firing an <code><a>RTCSsrcConflictEvent</a></code> event named <var>e</var> with
      an <code>ssrc</code> means that an event with the name <var>e</var>, which does not
      bubble (except where otherwise stated) and is not cancelable (except where
      otherwise stated), and which uses the <code><a>RTCSsrcConflictEvent</a></code>
      interface with the <code>ssrc</code> attribute set to the conflicting SSRC
      <em class="rfc2119" title="MUST">MUST</em> be created and dispatched at the given
      target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCSsrcConflictEventInit eventInitDict), Exposed=Window]
interface RTCSsrcConflictEvent : Event {
    readonly        attribute unsigned long ssrc;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCSsrcConflictEvent" data-dfn-for="RTCSsrcConflictEvent"
          class="constructors">
            <dt><code>RTCSsrcConflictEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>RTCSsrcConflictEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCSsrcConflictEvent" data-dfn-for="RTCSsrcConflictEvent"
          class="attributes">
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
            <dd>
              <p>The <code>ssrc</code> attribute represents the conflicting SSRC that
              caused the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
      <p>The <dfn><code>RTCSsrcConflictEventInit</code></dfn> dictionary
      includes the <code>ssrc</code> attribute representing the conflicting SSRC
      that caused the event.</p>
        <pre class="idl">dictionary RTCSsrcConflictEventInit : EventInit {
             required unsigned long ssrc;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCSsrcConflictEventInit</a> Members</h2>
          <dl data-link-for="RTCSsrcConflictEventInit" data-dfn-for=
          "RTCSsrcConflictEventInit" class="dictionary-members">
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span>, required</dt>
            <dd>
              <p>The <code>ssrc</code> attribute represents the conflicting SSRC that
              caused the event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>
  <section id="rtcrtpreceiver*">
    <h2><dfn>RTCRtpReceiver</dfn> Interface</h2>
    <p>The <code>RTCRtpReceiver</code> includes information relating to the
    RTP receiver.</p>
    <section id="rtcrtpreceiver-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCRtpReceiver</a></code> instance produces an associated receiving
      <a>MediaStreamTrack</a> and provides RTC related methods to it.</p>
    </section>
    <section id="rtcrtpreceiver-operation*">
      <h3>Operation</h3>
      <p>A <code><a>RTCRtpReceiver</a></code> instance is constructed from a value of
      <code>kind</code> and an <code><a>RTCDtlsTransport</a></code> object.</p>
      <p>An <code><a>RTCRtpReceiver</a></code> object can be garbage-collected once
      <code>stop()</code> is called and it is no longer referenced.</p>
    </section>
    <section id="rtcrtpreceiver-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Constructor (DOMString kind, optional RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport), Exposed=Window]
interface RTCRtpReceiver : RTCStatsProvider {
    readonly        attribute MediaStreamTrack  track;
    readonly        attribute RTCDtlsTransport?  transport;
    readonly        attribute RTCDtlsTransport? rtcpTransport;
    undefined       setTransport (RTCDtlsTransport transport, optional RTCDtlsTransport rtcpTransport);
    static RTCRtpCapabilities     getCapabilities (DOMString kind);
    Promise&lt;undefined&gt;      receive (RTCRtpReceiveParameters parameters);
    sequence&lt;RTCRtpContributingSource&gt; getContributingSources ();
    sequence&lt;RTCRtpSynchronizationSource&gt; getSynchronizationSources ();
    undefined                     stop ();
};</pre>
        <section>
          <h2>Constructors</h2>
              <p>When the constructor is invoked, the <a>user agent</a> MUST run the
              following steps:</p>
              <ol>
                <li>Let the first argument be <var>kind</var>.</li>
                <li>If <var>kind</var> is not a supported
                <code><a>MediaStreamTrack</a></code> <code>kind</code>,
                <a>throw</a> a <code>TypeError</code> and abort these steps.</li>
                <li>Let <var>transport</var> be the second argument.</li>
                <li>Let <var>rtcpTransport</var> be the third argument.</li>
                <li>If <var>transport</var> is unset, and <var>rtcpTransport</var>
                is set, <a>throw</a> an <code>InvalidParameters</code> and
                abort these steps.</li>
                <li>If <var>transport</var> is set and <code><var>transport</var>.state</code>
                is <code>closed</code>, <a>throw</a> an
                <code>InvalidStateError</code> and abort these steps.</li>
                <li>If <var>rtcpTransport</var> is set and <code><var>rtcpTransport</var>.state</code>
                is <code>closed</code>, <a>throw</a> an
                <code>InvalidStateError</code> and abort these steps.</li>
                <li>Construct an <code><a>RTCRtpReceiver</a></code> with <var>transport</var> (if provided)
                and <var>rtcpTransport</var> (if provided) and let <var>receiver</var>
                be the result.</li>
                <li>Let <var>receiver</var> have an <dfn>[[\ReceiverStopped]]</dfn> internal slot,
                initialized to <code>false</code>.</li>
                <li>Let <var>receiver</var> have a <dfn>[[\ReceiverKind]]</dfn> internal slot,
                initialized to <var>kind</var>.</li>
                <li>Let <var>receiver</var> have a <dfn>[[\ReceiverTrack]]</dfn> internal slot,
                initialized to a newly created <code>MediaStreamTrack</code> of <code>kind</code>
                <var>kind</var>.</li>
                <li>Set the <code>muted</code> attribute of <var>receiver</var>'s [[\ReceiverTrack]]
                slot to <code>false</code>.</li>
              </ol>
          <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver" class=
          "constructors">
            <dt><code><a>RTCRtpReceiver</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">kind</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">rtcpTransport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver" class=
          "attributes">
            <dt><dfn data-idl><code>track</code></dfn> of type <span class=
            "idlAttrType"><a>MediaStreamTrack</a></span>, readonly</dt>
            <dd>
              <p>The <code>track</code> attribute is the
              <code><a>MediaStreamTrack</a></code> instance that is
              associated with this <code><a>RTCRtpReceiver</a></code>
              object <var>receiver</var>. When one of the SSRCs for RTP
              source media streams received by <var>receiver</var> is
              removed (either due to reception of a BYE or via timeout),
              the <code>mute</code> event is fired at <code>track</code>.
              If and when packets are received again, the <code>unmute</code>
              event is fired at <code>track</code>.</p>
              <p>Note that <code>track.stop()</code> is final, although
              clones are not affected. Since
              <code><var>receiver</var>.track.stop()</code>
              does not implicitly stop <var>receiver</var>, Receiver
              Reports continue to be sent. On getting, the attribute MUST
              return the value of the <a>[[\ReceiverTrack]]</a> slot.</p>  
              <div class="note">
                Prior to verification of the remote DTLS fingerprint within the
                <code><a>RTCDtlsTransport</a></code> <var>transport</var> (if set), and
                <var>rtcpTransport</var> (if set), <code>track</code> <em title="MUST NOT"
                class="rfc2119">MUST NOT</em> emit media for rendering.
              </div>
            </dd>
            <dt><dfn data-idl><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly, nullable</dt>
            <dd>
              <p>The associated RTP <code><a>RTCDtlsTransport</a></code> instance.</p>
            </dd>
            <dt><dfn><code>rtcpTransport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly , nullable</dt>
            <dd>
              <p>The <code><a>RTCDtlsTransport</a></code> instance over which RTCP is
              sent and received. When BUNDLE is used, multiple
              <code><a>RTCRtpReceiver</a></code> objects will share one
              <code>rtcpTransport</code> and will send and receive RTCP over the same
              <code><a>RTCDtlsTransport</a></code>. When RTCP mux is used,
              <code>rtcpTransport</code> will be null, and both RTP and RTCP traffic will
              flow over the <code><a>RTCDtlsTransport</a></code>
              <var>transport</var>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCRtpReceiver" data-dfn-for="RTCRtpReceiver" class=
          "methods">
            <dt><code>setTransport</code></dt>
            <dd>
              <p><dfn>setTransport()</dfn>
              attempts to replace the RTP <code><a>RTCDtlsTransport</a></code>
              <code>transport</code> (and if used) the RTCP <code><a>RTCDtlsTransport</a></code>
              <code>rtcpTransport</code> with the transport(s) provided.</p>
              <p>When the <code>setTransport()</code> method is invoked, the user
              agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>receiver</var> be the <code><a>RTCRtpReceiver</a></code> object
                  on which <code>setTransport()</code> is invoked.</p>
                </li>
                <li>If <var>receiver</var>'s <a>[[\ReceiverStopped]]</a> slot is <code>true</code>,
                <a>throw</a> an <code>InvalidStateError</code>.</li>
                <li>
                  <p>Let <var>withTransport</var> and <var>withRtcpTransport</var>
                  be the arguments to this method.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var></code> is <code>null</code> and
                  <code><var>withRtcpTransport</var></code> is set, <a>throw</a> an
                  <code>OperationError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var></code> is set and
                  <code><var>withTransport</var>.transport.component</code> is
                  <code>rtcp</code>, <a>throw</a> an <code>InvalidParameters</code>.</p>
                </li>
                <li>
                  <p>If <code><var>withRtcpTransport</var></code> is set and
                  <code><var>withRtcpTransport</var>.transport.component</code> is
                  <code>rtp</code>, <a>throw</a> an <code>InvalidParameters</code>.</p>
                </li>
                <li>
                  <p>If <code><var>withTransport</var></code> is set and
                  <code><var>withTransport</var>.state</code> is
                  <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>.</p>
                </li>
                <li>
                  <p>If <code><var>withRtcpTransport</var></code> is set and
                  <code><var>withRtcpTransport</var>.state</code> is
                  <code>closed</code>, <a>throw</a> an <code>InvalidStateError</code>.</p>
                </li>
                <li>Check whether MID header extensions with different values of
                  <code>id</code> have been configured on other
                  <code><a>RTCRtpReceiver</a></code>s sharing the
                  <code><a>RTCDtlsTransport</a></code> <var>withTransport</var>.
                  If conflicts are found, <a>throw</a> an
                  <code>InvalidParameters</code> and abort all of these steps.</p>
                </li> 
                <li>
                  <p>Set <code>transport</code> to <var>withTransport</var> and
                  <code>rtcpTransport</code> to <var>withRtcpTransport</var>.</p>
                </li>
                  <p>If <code>transport</code> is set and <code>transport.state</code>
                  is not <code>failed</code>, seamlessly receive over the new transport(s).</p>
                </li>                
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">rtcpTransport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><code>getCapabilities</code>, static</dt>
            <dd>
              <p><dfn>getCapabilities()</dfn> obtains the receiver capabilities,
              based on <code><var>kind</var></code>. Browsers
              MUST support <var>kind</var> values of <code>"audio"</code>
              and <code>"video"</code>. If there are no capabilities
              corresponding to the value of <code><var>kind</var></code>,
              <code>getCapabilities</code> returns <code>null</code>. Capabilities
              that can apply to multiple values of <code><var>kind</var></code>
              (such as retransmission [[!RFC4588]], redundancy [[RFC2198]]
              and Forward Error Correction) have
              <code>RTCRtpCapabilities.RTCRtpCodecCapability[<var>i</var>].kind</code>
              set to the value of the <code><var>kind</var></code> argument.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">kind</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code><a>RTCRtpCapabilities</a></code>
              </div>
            </dd>
            <dt><dfn data-idl><code>receive</code></dfn></dt>
            <dd>
              <p>Attempts to set the parameters controlling the receiving of media.</p>
              <p>When the <code>receive()</code> method is invoked, the <a>user agent</a> MUST
              run the following steps:</p>
              <ol>
                <li>
                  <p>Let <var>receiver</var> be the <code><a>RTCRtpReceiver</a></code>
                  object on which <code>receive</code> is invoked.</p>
                </li>
                <li>
                  <p>Let <var>p</var> be a new promise.</p>
                </li>
                <li>
                  <p>If <var>receiver</var>'s <a>[[\ReceiverStopped]]</a> slot is <code>true</code>,
                  <a>reject</a> <var>p</var> with a newly created <code>InvalidStateError</code> and
                  abort these steps.</p>
                </li>
                <li>
                  <p>If <code>transport</code> is not set, <a>reject</a> <var>p</var>
                  with a newly created <code>TypeError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>withParameters</var> be the argument to this method.</p>
                </li>
                <li>
                  <p>If <code>rtcpTransport</code> is not set and
                  <code><var>withParameters</var>.rtcp.mux</code> is set to <code>false</code>,
                  <a>reject</a> <var>p</var> with <code>InvalidParameters</code> and abort
                  these steps.</p>
                </li>
                <li>
                  <p>Let <var>kind</var> be the first argument passed in the
                  <code><a>RTCRtpReceiver</a></code> constructor.</p>
                </li>
                <li><a>Complete validation checks</a> on <var>withParameters</var>.</li>
                <li>
                  <p>As described in Section 6.5.1, fill the <code>ssrc_table</code>,
                   <code>muxId_table</code> and <code>pt_table</code> entries and
                   <a>check for conflicts</a>. If conflicts are found,
                   <a>reject</a> <var>p</var> and abort these steps.</p>
                </li>
                <li>
                  <p>Run the following steps:</p>
                  <ol>
                    <li>
                      <p>If <code><a>receive</a>()</code> is called for the first time,
                      start receiving. If <code><a>receive</a>()</code> was called
                      previously, have the receiver switch to receiving using
                      <var>withParameters</var>.</p>
                    </li>
                    <li>
                      <p><a>Resolve</a> <var>p</var> with <code>undefined</code>.</p>
                    </li>
                  </ol>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">parameters</td>
                    <td class="prmType"><code><a>RTCRtpReceiveParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;undefined&gt;</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getContributingSources</code></dfn></dt>
            <dd>
              <p>Returns an <code><a>RTCRtpContributingSource</a></code> for each
              unique CSRC identifier received by this <code><a>RTCRtpReceiver</a></code>.
              The browser MUST keep information from RTP packets received in the last 10
              seconds. If no contributing sources are available, an empty list is
              returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence</code>&lt;<code><a>RTCRtpContributingSource</a></code>&gt;
              </div>
            </dd>
            <dt><dfn data-idl><code>getSynchronizationSources</code></dfn></dt>
            <dd>
              <p>Returns an <code><a>RTCRtpSynchronizationSource</a></code> for
              each unique SSRC identifier received by this RTCRtpReceiver in
              the last 10 seconds.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence&lt;RTCRtpSynchronizationSource&gt;</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>stop</code></dfn></dt>
            <dd>
              <p>The <code>stop</code> method irreversibly stops the
              <code><a>RTCRtpReceiver</a></code> <var>receiver</var>
              on which it is invoked, but does not cause the "onended"
              event to fire for <code><var>receiver</var>.track</code>.</p>
              <p>While <code><var>receiver</var>.track.stop()</code> is also
              irreversible, it does not affect track clones and also does
              not stop <var>receiver</var> so that Receiver Reports 
              continue to be sent.</p>  
              <p>When <code>stop</code> is called, the following steps MUST be run:<p>
              <ol>
                 <li>Let <var>receiver</var> be the <code><a>RTCRtpReceiver</a></code>
                 on which <code>stop</code> is invoked.</li>
                 <li>If <var>receiver</var>'s <a>[[\ReceiverStopped]]</a> slot is
                 <code>true</code>, abort these steps.</li>
                 <li>
                  <p>Let <var>parameters</var> be the argument provided to
                  <code><var>receiver</var>.receive(<var>parameters</var>)</code> the
                  last time it was invoked.<p>
                </li>
                 <li>
                   <p>Stop receiving media with <var>receiver</var>.<p>
                </li>
                <li>
                  <p>Remove <code><var>parameters</var>.headerExtensions</code> from
                  <code><var>receiver</var>.transport</code>'s <a>[[\ReceiveHeaderExtensions]]</a>
                  internal slot.</p>
                </li>
                <li>Set <var>receiver</var>'s <a>[[\ReceiverStopped]]</a> slot to <code>true</code>.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtpsynchronizationsource*">
      <h3><dfn>RTCRtpSynchronizationSource</dfn> and <dfn>RTCRtpContributingSource</dfn> Dictionaries</h3>
      <p>The <code>RTCRtpContributingSource</code> and
      <code>RTCRtpSynchronizationSource</code> dictionaries contain information
      about a given contributing source (CSRC) or synchronization source (SSRC)
      respectively, including the most recent time a
      packet that the source contributed to was played out. The browser MUST
      keep information from RTP packets received in the previous 10 seconds.
      When the first frame contained in an RTP packet is delivered to the
      <code><a>RTCRtpReceiver</a></code>'s <code><a>MediaStreamTrack</a></code>
      for playout, the user agent MUST queue a task to update the relevant
      information for the <code><a>RTCRtpContributingSource</a></code> and
      <code><a>RTCRtpSynchronizationSource</a></code> dictionaries based on the
      contents of the packet. The information relevant to the
      <code><a>RTCRtpSynchronizationSource</a></code> dictionary corresponding
      to the SSRC identifier is updated each time, and if the RTP packet
      contains CSRC identifiers, then the information relevant to the
      <code><a>RTCRtpContributingSource</a></code> dictionaries corresponding to
      those CSRC identifiers is also updated.</p>
      <div class="note">As stated in the <a href="#conformance">conformance
      section</a>, requirements phrased as algorithms may be implemented in
      any manner so long as the end result is equivalent. So, an
      implementation does not need to literally queue a task for every
      packet, as long as the end result is that within a single event loop task
      execution, all returned <code><a>RTCRtpSynchronizationSource</a></code>
      and <code><a>RTCRtpContributingSource</a></code> dictionaries for a
      particular <code><a>RTCRtpReceiver</a></code> contain information from a
      single point in the RTP stream.</div>
      <div>
        <pre class="idl">dictionary RTCRtpContributingSource {
    required DOMHighResTimeStamp timestamp;
    required unsigned long       source;
             double              audioLevel;
};</pre>
        <section>
          <h2>Dictionary RTCRtpContributingSource Members</h2>
          <dl data-link-for="RTCRtpContributingSource" data-dfn-for=
          "RTCRtpContributingSource" class="dictionary-members">
            <dt><dfn data-idl><code>timestamp</code></dfn> of type <span class=
            "idlMemberType"><a>DOMHighResTimeStamp</a></span>, required</dt>
            <dd>
              <p>The timestamp of type DOMHighResTimeStamp [[!HIGHRES-TIME]],
              indicating the most recent time of playout of an RTP packet
              containing the source. The timestamp is defined in
              [[!HIGHRES-TIME]] and corresponds to a local clock.</p>
            </dd>
            <dt><dfn data-idl><code>source</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span>, required</dt>
            <dd>
              <p>The CSRC or SSRC identifier of the contributing or
              synchronization source.</p>
            </dd>
            <dt><dfn data-idl><code>audioLevel</code></dfn> of type <span class=
            "idlMemberType"><a>double</a></span></dt>
            <dd>
              <p>This is a value between 0..1 (linear), where 1.0 represents 0
              dBov, 0 represents silence, and 0.5 represents approximately 6
              dBSPL change in the sound pressure level from 0 dBov.</p>
              <p>For CSRCs, this MUST be converted from the level value defined
              in [[!RFC6465]] if the RFC 6465 header extension is present,
              otherwise this member MUST be absent.</p>
              <p>For SSRCs, this MUST be converted from the level value defined
              in [[!RFC6464]] if the RFC 6464 header extension is present,
              otherwise the user agent must compute the value from the audio
              data (the member must never be absent).</p>

              <p>Both RFCs define the level as an integral value from 0 to 127
              representing the audio level in negative decibels relative to the
              loudest signal that the system could possibly encode. Thus,
              0 represents the loudest signal the system could possibly encode,
              and 127 represents silence.</p>
              <p>To convert these values to the linear 0..1 range, a value of
              127 is converted to 0, and all other values are converted using
              the equation: <code>10^(-rfc_level/20)</code>.</p>
            </dd>
          </dl>
        </section>
              </div>
      <div>
        <pre class="idl">dictionary RTCRtpSynchronizationSource : RTCRtpContributingSource {
    boolean voiceActivityFlag;
};</pre>
        <section>
          <h2>Dictionary RTCRtpSynchronizationSource Members</h2>
          <dl data-link-for="RTCRtpSynchronizationSource" data-dfn-for=
          "RTCRtpSynchronizationSource" class="dictionary-members">
            <dt><dfn data-idl><code>voiceActivityFlag</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span></dt>
            <dd>
              <p>Whether the last RTP packet played from this source contains
              voice activity (true) or not (false). If the RFC 6464 extension
              header was not present, or if the peer has signaled that it is
              not using the V bit by setting the "vad" extension attribute to
              "off", as described in [[!RFC6464]], Section 4,
              <code>voiceActivityFlag</code> will be absent.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtpmatchingrules*">
      <h3>RTP matching rules</h3>
      <p>In ORTC, RTP packets are delivered to <code><a>RTCRtpReceiver</a></code>
      objects by the <code><a>RTCRtpListener</a></code>. When the
      <code><a>RTCRtpListener</a></code> receives an RTP packet over
      an <code><a>RTCDtlsTransport</a></code>, it attempts to determine which
      <code><a>RTCRtpReceiver</a></code> object to deliver the packet to, based on
      the values of the SSRC and payload type fields in the RTP header, as well as
      the value of the <a>MID</a> RTP header extension, if present. If the
      <code><a>RTCRtpReceiver</a></code> object to deliver the RTP packet to
      cannot be determined, the <code><a>unhandledrtp</a></code> event is fired.</p>
      <p>[[!BUNDLE]] Section 10.2 describes the algorithm used in WebRTC for
      routing of RTP streams received over a shared transport to an SDP m-line
      (representing an <code><a>RTCRtpSender</a></code>/<code><a>RTCRtpReceiver</a></code> pair),
      using three tables: the <code>ssrc_table</code>
      which maps SSRC values to <code><a>RTCRtpReceiver</a></code> objects,
      the <code>muxId_table</code> which maps values of the <a>MID</a> header extension
      to <code><a>RTCRtpReceiver</a></code> objects and the <code>pt_table</code> which
      maps payload type values to <code><a>RTCRtpReceiver</a></code> objects.</p>
      <p>Table entries referencing the <code><a>RTCRtpReceiver</a></code> object
      <code><var>receiver</var></code> are added when <code><var>receiver</var>.receive(<var>parameters</var>)</code>
      is called. When <code><var>receiver</var>.receive(<var>parameters</var>)</code> is
      called again, changes are made to table entries. When <code><var>receiver</var>.stop</code>
      is called, all entries referencing <code><var>receiver</var></code> are removed.</p>
      <p>When multiple <code><a>RTCRtpReceiver</a></code> or <code><a>RTCRtpSender</a></code>
      objects share a <code><a>RTCDtlsTransport</a></code>, this implies that they also
      share a single SSRC [[!RFC3550]] and header extension [[!RFC5285]] numbering space.
      The restrictions arising from this are described in [[!BUNDLE]] Sections 10.1 and 10.1.1.</p>      
      <section class="informative" id="ortcroutingtable*">
      <h4>ORTC routing tables</h4>
      <p>Since ORTC does not utilize <code>RTCRtpTransceiver</code> objects, 
      this section provides a (non-normative) example of how an
      <code><a>RTCRtpListener</a></code> implementation can emulate the
      behavior described in [[!BUNDLE]] Section 10.2.</p>
      <p>When <code>receive</code> is called, to fill the routing tables and
      <dfn>check for conflicts</dfn>, run the following steps:</p>
      <ol>
      <li><p>Let <var>receiver</var> be the <code><a>RTCRtpReceiver</a></code>
      object on which the <code>receive</code> method was called.</p></li>
      <li>Let <var>withParameters</var> be the first argument.</li>
      <li>MuxId table:</li>
       <ol>
         <li><p>If <code><var>withParameters</var>.muxId</code> is set and
         <code>muxId_table[<var>withParameters</var>.muxId]</code> is unset,
         set <code>muxId_table[<var>withParameters</var>.muxId]</code> to
         <var>receiver</var>.</p></li>
         <li><p>If <code><var>withParameters</var>.muxId</code> is set and
         <code>muxId_table[<var>withParameters</var>.muxId]</code> is set
         to a value other than <var>receiver</var>, <a>reject</a>
         <code>receive</code> with <code>InvalidParameters</code> and
         abort these steps.</p></li>
       </ol>  
      <li>SSRC table:</li> 
      <p>For values of <var>i</var> from 0 to <code>encodings.length-1</code>:</p>
      <ol>
        <li><p>If <code><var>withParameters</var>.encodings[<var>i</var>].ssrc</code> is set
        and <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].ssrc]</code>
        is unset, set <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].ssrc]</code>
        to <var>receiver</var>.</p></li>
        <li><p>If <code><var>withParameters</var>.encodings[<var>i</var>].ssrc</code> is set
        and <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].ssrc]</code>
        is set to a value other than <var>receiver</var>, <a>reject</a>
        <code>receive</code> with <code>InvalidParameters</code> and abort these steps.</p></li>    
        <li><p>If <code><var>withParameters</var>.encodings[<var>i</var>].rtx.ssrc</code> is set
        and <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].rtx.ssrc]</code>
        is unset, set <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].rtx.ssrc]</code>
        to <var>receiver</var>.</p></li>
        <li><p>If <code><var>withParameters</var>.encodings[<var>i</var>].rtx.ssrc</code> is set
        and <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].rtx.ssrc]</code>
        is set to a value other than <var>receiver</var>, <a>reject</a>
        <code>receive</code> with <code>InvalidParameters</code> and abort these steps.</p></li>  
        <li><p>If <code><var>withParameters</var>.encodings[<var>i</var>].fec.ssrc</code> is set
        and <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].fec.ssrc]</code>
        is unset, set <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].fec.ssrc]</code>
        to <var>receiver</var>.</p></li>
        <li><p>If <code><var>withParameters</var>.encodings[<var>i</var>].fec.ssrc</code> is set
        and <code>ssrc_table[<var>withParameters</var>.encodings[<var>i</var>].fec.ssrc]</code>
        is set to a value other than <var>receiver</var>, <a>reject</a>
        <code>receive</code> with <code>InvalidParameters</code> and abort these steps.</p></li>  
      </ol>      
      <li>payload type table:</li>
      <ol>
        <p>If <code><var>withParameters</var>.encodings[<var>i</var>].ssrc</code> is unset for all
        values of <var>i</var> from 0 to <code>encodings.length-1</code>, then
        for values of <var>j</var> from 0 to <code>codecs.length-1</code>:</p>
        <ol>
          <li><p>If <code>pt_table[<var>withParameters</var>.codecs[<var>j</var>].payloadType]</code>
          is unset, set <code>pt_table[<var>withParameters</var>.codecs[<var>j</var>].payloadType]</code>
          to <var>receiver</var>.</p></li>
          <li><p>If <code>pt_table[<var>withParameters</var>.codecs[<var>j</var>].payloadType]</code>
          is set to a value other than <var>receiver</var>, <a>reject</a> <code>receive</code> with
          <code>InvalidParameters</code> and abort these steps.</p></li>
        </ol>
      </ol>
      </section>
      <section id="rtppackethandling*">
      <h3>RTP packet handling</h3>
      <p>When an RTP packet arrives, the implementation determines the
      <code><a>RTCRtpReceiver</a></code> <var>rtp_receiver</var> to send it to as
      follows:</p>
      <p>If <code>ssrc_table[<var>packet.ssrc</var>]</code> is set:</p>
        <ol>
          <li>Check whether the value of <var>packet.pt</var> is equal to one of the
          values of <code><var>parameters</var>.codecs[<var>j</var>].payloadType</code>
          for the <code><a>RTCRtpReceiver</a></code> object <var>rtp_receiver</var>,
          where <var>j</var> varies from 0 to <code>codecs.length-1</code>.</li>
          <li>If <var>packet.pt</var> does not match, fire the
          <code><a>unhandledrtp</a></code> event and abort these steps.</li>
          <li>Set <var>rtp_receiver</var> to <code>ssrc_table[<var>packet.ssrc</var>]</code>.</li>
          <li>Route the packet to <var>rtp_receiver</var> and abort these steps.</li>
        </ol>
       <p>Else if <var>packet.muxId</var> is set:</p>
        <ol>
          <li>If <code>muxId_table[<var>packet.muxId</var>]</code> is unset, fire the
          <code><a>unhandledrtp</a></code> event, and abort these steps.</li>
          <li>Check whether the value of <var>packet.pt</var> is equal to one of the
          values of <code><var>parameters</var>.codecs[<var>j</var>].payloadType</code>
          for the <code><a>RTCRtpReceiver</a></code> object <var>rtp_receiver</var>,
          where <var>j</var> varies from 0 to <code>codecs.length-1</code>.</li>
          <li>If <var>packet.pt</var> does not match, fire the
          <code><a>unhandledrtp</a></code> event and abort these steps.</li>
          <li>Set <var>rtp_receiver</var> to <code>muxId_table[<var>packet.muxId</var>]</code>.</li>
          <li>Set <code>ssrc_table[<var>packet.ssrc</var>]</code> to <var>rtp_receiver</var>.</li>
          <li>Route the packet to <var>rtp_receiver</var> and abort these steps.</li>
        </ol>
        <p>Else if <code>pt_table[<var>packet.pt</var>]</code> is set:</p>
         <ol>
           <li>Set <var>rtp_receiver</var> to <code>pt_table[<var>packet.pt</var>]</code>.</li>
           <li>Set <code>ssrc_table[<var>packet.ssrc</var>]</code> to <var>rtp_receiver</var>.</li>
           <li>Route the packet to <var>rtp_receiver</var> and abort these steps.</li>
         </ol>
        <p>Else if no matches are found in the <code>ssrc_table</code>, <code>muxId_table</code>
        or <code>pt_table</code>, fire the <code><a>unhandledrtp</a></code> event.</p>
      </section>
      <section id="rtcpmatchingrules*">
        <h3>RTCP packet handling</h3>
        <p>RTCP packets arriving on a <code><a>RTCDtlsTransport</a></code> are decrypted
        and the algorithm described in [[!BUNDLE]] Section 10.2 is used to route the RTCP
        packets to the appropriate <code><a>RTCRtpSender</a></code> and
        <code><a>RTCRtpReceiver</a></code> objects.  The <code><a>RTCRtpSender</a></code>
        and <code><a>RTCRtpReceiver</a></code> objects then examine the RTCP packets to
        determine the information relevant to their operation and the statistics maintained
        by them.</p>
        <p>RTCP packets should be queued for 30 seconds so that
        <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects on
        the related <code><a>RTCDTlsTransport</a></code> have access to those packets until
        the packet is removed from the queue, should the <code><a>RTCRtpSender</a></code>
        or <code><a>RTCRtpReceiver</a></code> objects need to examine them.</p>
        <p>Since statistics are retrieved from objects within the ORTC API, and information
        within RTCP packets is used to maintain some of the statistics, the handling of
        RTCP packets is important to the operation of the <a href="#statistics-api">Statistics API</a>.</p>
      </section>
    </section>
    <section class="informative" id="rtcrtpreceiver-example*">
      <h3>Examples</h3>
      <pre class="example highlight">
      // Assume we already have a way to signal, a transport
// (RTCDtlsTransport), and audio and video tracks. This is an example
// of how to offer them and get back an answer with audio and
// video tracks, and begin sending and receiving them.
// The example assumes that RTP and RTCP are multiplexed.
function myInitiate(mySignaller, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver("audio", transport);
  var videoReceiver = new RTCRtpReceiver("video", transport);

  // Retrieve the audio and video receiver capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
  var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");

  // Retrieve the audio and video sender capabilities
  var sendAudioCaps = RTCRtpSender.getCapabilities("audio");
  var sendVideoCaps = RTCRtpSender.getCapabilities("video");

  mySignaller.myOfferTracks({
    // The initiator offers its receiver and sender capabilities.
    recvAudioCaps: recvAudioCaps,
    recvVideoCaps: recvVideoCaps,
    sendAudioCaps: sendAudioCaps,
    sendVideoCaps: sendVideoCaps
  }, function(answer) {
    // The responder answers with its receiver capabilities

    // Derive the send and receive parameters (see Section 19.3)
    var audioSendParams = myCapsToSendParams(sendAudioCaps, answer.recvAudioCaps);
    var videoSendParams = myCapsToSendParams(sendVideoCaps, answer.recvVideoCaps);
    var audioRecvParams = myCapsToRecvParams(recvAudioCaps, answer.sendAudioCaps);
    var videoRecvParams = myCapsToRecvParams(recvVideoCaps, answer.sendVideoCaps);
    audioSender.send(audioSendParams).then(function() {
      trace("Set audio sender parameters");
      }, function() {
        trace("Could not set audio sender parameters");
      }
    );
    videoSender.send(videoSendParams).then(function() {
      trace("Set video sender parameters");
      }, function() {
        trace("Could not set video sender parameters");
      }
    );
    audioReceiver.receive(audioRecvParams).then(function() {
      trace("Set audio receiver parameters");
      }, function() {
        trace("Could not set audio receiver parameters");
      }
    );
    videoReceiver.receive(videoRecvParams).then(function() {
      trace("Set video receiver parameters");
      }, function() {
        trace("Could not set video receiver parameters");
      }
    );
    // Now we can render/play
    // audioReceiver.track and videoReceiver.track.
  });
}
                </pre>
      <pre class="example highlight">
      // Assume we already have a way to signal, a transport (RTCDtlsTransport)
// and audio and video tracks. This is an example of how to answer an
// offer with audio and video tracks, and begin sending and receiving them.
// The example assumes that RTP and RTCP are multiplexed.
function myAccept(mySignaller, remote, transport, audioTrack, videoTrack) {
  var audioSender = new RTCRtpSender(audioTrack, transport);
  var videoSender = new RTCRtpSender(videoTrack, transport);
  var audioReceiver = new RTCRtpReceiver("audio", transport);
  var videoReceiver = new RTCRtpReceiver("video", transport);

  // Retrieve the send and receive capabilities
  var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
  var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");
  var sendAudioCaps = RTCRtpSender.getCapabilities("audio");
  var sendVideoCaps = RTCRtpSender.getCapabilities("video");

  mySignaller.myAnswerTracks({
    recvAudioCaps: recvAudioCaps,
    recvVideoCaps: recvVideoCaps,
    sendAudioCaps: sendAudioCaps,
    sendVideoCaps: sendVideoCaps
  });

  // Derive the send and receive parameters using Javascript functions
  var audioSendParams = myCapsToSendParams(sendAudioCaps, remote.recvAudioCaps);
  var videoSendParams = myCapsToSendParams(sendVideoCaps, remote.recvVideoCaps);
  var audioRecvParams = myCapsToRecvParams(recvAudioCaps, remote.sendAudioCaps);
  var videoRecvParams = myCapsToRecvParams(recvVideoCaps, remote.sendVideoCaps);
  audioSender.send(audioSendParams).then(function() {
    trace("Set audio sender parameters");
    }, function() {
      trace("Could not set audio sender parameters");
    }
  );
  videoSender.send(videoSendParams).then(function() {
    trace("Set video sender parameters");
    }, function() {
      trace("Could not set video sender parameters");
    }
  );
  audioReceiver.receive(audioRecvParams).then(function() {
    trace("Set audio receiver parameters");
    }, function() {
      trace("Could not set audio receiver parameters");
    }
  );
  videoReceiver.receive(videoRecvParams).then(function() {
    trace("Set video receiver parameters");
    }, function() {
      trace("Could not set video receiver parameters");
    }
  );
  // Now we can render/play
  // audioReceiver.track and videoReceiver.track.
}
                </pre>
    </section>
  </section>
  <section id="rtcicetransportcontroller*">
    <h2><dfn>RTCIceTransportController</dfn> Interface</h2>
    <p>The <code>RTCIceTransportController</code> object assists in the
    managing of ICE freezing and bandwidth estimation.</p>
    <section id="rtctransportcontroller-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCIceTransportController</a></code> object provides methods to add
      and retrieve <code><a>RTCIceTransport</a></code> objects with a
      <code>component</code> of <code>rtp</code> (associated
      <code><a>RTCIceTransport</a></code> objects with a <code>component</code> of
      <code>rtcp</code> are included implicitly).</p>
    </section>
    <section id="rtctransportcontroller-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCIceTransportController</a></code> instance is automatically
      constructed.</p>
    </section>
    <section id="rtcicetransportcontroller-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">[Constructor(), Exposed=Window]
interface RTCIceTransportController {
    undefined                 addTransport (RTCIceTransport transport, optional unsigned long index);
    sequence&lt;RTCIceTransport&gt; getTransports ();
};</pre>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIceTransportController" data-dfn-for=
          "RTCIceTransportController" class="methods">
            <dt><dfn data-idl><code>addTransport</code></dfn></dt>
            <dd>
              <p>Adds <code>transport</code> to the
              <code><a>RTCIceTransportController</a></code> object for the purposes of
              managing ICE freezing and sharing bandwidth estimation. Since
              <code><a>addTransport</a></code> manages ICE freezing, candidate pairs
              that are not in the frozen state maintain their state when
              <code>addTransport(transport)</code> is called.
              <code><a>RTCIceTransport</a></code> objects will be unfrozen according to
              their <code>index</code>. <code>transport</code> is inserted at
              <code>index</code>, or at the end if <code>index</code> is not specified. If
              <code>index</code> is greater than the current number of
              <code><a>RTCIceTransport</a></code>s with a <code>component</code> of
              <code>rtp</code>, <a>throw</a> an <code>InvalidParameters</code>. If
              <code>transport.state</code> is <code>closed</code>, <a>throw</a> an
              <code>InvalidStateError</code>. If <code>transport</code> has
              already been added to another <code><a>RTCIceTransportController</a></code>
              object, or if <code>transport.component</code> is <code>rtcp</code>, <a>throw</a>
              an <code>InvalidStateError</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCIceTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">index</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getTransports</code></dfn></dt>
            <dd>
              <p>Returns the <code><a>RTCIceTransport</a></code> objects with a
              <code><a>component</a></code> of <code>rtp</code>. If
              <code><a>addTransport</a>()</code> has not been called, an empty list is
              returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em>
                <code>sequence</code>&lt;<code><a>RTCIceTransport</a></code>&gt;
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section class="informative" id="rtcicetransportcontroller-example1*">
      <h3>Example</h3>
      <pre class="example highlight">
      // This is an example of how to utilize distinct ICE transports for Audio and Video
// as well as for RTP and RTCP. If both sides can multiplex audio/video
// and RTP/RTCP then the multiplexing will occur.
//
// Assume we have an audioTrack and a videoTrack to send.
//
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';
// Create the ICE gather options
var gatherOptions = {
  gatherPolicy: "all",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
      credentialType: "password" }
   ]
};

// Create the RTP and RTCP ICE gatherers for audio and video
var audioRtpIceGatherer = new RTCIceGatherer(gatherOptions);
var audioRtcpIceGatherer = audioRtpIceGatherer.createAssociatedGatherer();
var videoRtpIceGatherer = new RTCIceGatherer(gatherOptions);
var videoRtcpIceGatherer = videoRtpIceGatherer.createAssociatedGatherer();

// Set up the ICE gatherer error handlers
audioRtpIceGatherer.onerror = errorHandler;
audioRtcpIceGatherer.onerror = errorHandler;
videoRtpIceGatherer.onerror = errorHandler;
videoRtcpIceGatherer.onerror = errorHandler;

// Create the RTP and RTCP ICE transports for audio and video
var audioRtpIceTransport = new RTCIceTransport(audioRtpIceGatherer);
var audioRtcpIceTransport = audioRtpIceTransport.createAssociatedTransport();
var videoRtpIceTransport = new RTCIceTransport(videoRtpIceGatherer);
var videoRtcpIceTransport = videoRtpIceTransport.createAssociatedTransport();

// Enable local ICE candidates to be signaled to the remote peer.
audioRtpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "rtp", "audio");
};
audioRtcpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "rtcp", "audio");
};
videoRtpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "rtp", "video");
};
videoRtcpIceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate, "rtcp", "video");
};

// Start gathering
audioRtpIceGatherer.gather();
audioRtcpIceGatherer.gather();
videoRtpIceGatherer.gather();
videoRtcpIceGatherer.gather();

// Set up the ICE state change event handlers
audioRtpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("audioRtpIceTransport", event.state);
};
audioRtcpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("audioRtcpIceTransport", event.state);
};
videoRtpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("videoRtpIceTransport", event.state);
};
videoRtcpIceTransport.onstatechange = function(event) {
  myIceTransportStateChange("videoRtcpIceTransport", event.state);
};

// Prepare to add ICE candidates signaled by the remote peer on any of the ICE transports
mySignaller.onRemoteCandidate = function(remote) {
  switch (remote.kind) {
    case "audio":
      if (remote.component === "rtp") {
        audioRtpIceTransport.addRemoteCandidate(remote.candidate);
      } else {
        audioRtcpIceTransport.addRemoteCandidate(remote.candidate);
      }
      break;
    case "video":
      if (remote.component === "rtp") {
        videoRtpIceTransport.addRemoteCandidate(remote.candidate);
      } else {
        videoRtcpIceTransport.addRemoteCandidate(remote.candidate);
      }
      break;
    default:
      trace("Invalid media type received: " + remote.kind);
  }
};
// Create the DTLS certificate
var certs;
var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
  certs[0] = certificate;
}, function(){
  trace('Certificate could not be created');
});

// Create the DTLS transports (using the same certificate)
var audioRtpDtlsTransport = new RTCDtlsTransport(audioRtpIceTransport, certs);
var audioRtcpDtlsTransport = new RTCDtlsTransport(audioRtcpIceTransport, certs);
var videoRtpDtlsTransport = new RTCDtlsTransport(videoRtpIceTransport, certs);
var videoRtcpDtlsTransport = new RTCDtlsTransport(videoRtcpIceTransport, certs);

// Create the sender and receiver objects
var audioSender = new RTCRtpSender(audioTrack, audioRtpDtlsTransport, audioRtcpDtlsTransport);
var videoSender = new RTCRtpSender(videoTrack, videoRtpDtlsTransport, videoRtcpDtlsTransport);
var audioReceiver = new RTCRtpReceiver("audio", audioRtpDtlsTransport, audioRtcpDtlsTransport);
var videoReceiver = new RTCRtpReceiver("video", videoRtpDtlsTransport, videoRtcpDtlsTransport);

// Retrieve the receiver and sender capabilities
var recvAudioCaps = RTCRtpReceiver.getCapabilities("audio");
var recvVideoCaps = RTCRtpReceiver.getCapabilities("video");
var sendAudioCaps = RTCRtpSender.getCapabilities("audio");
var sendVideoCaps = RTCRtpSender.getCapabilities("video");

// Exchange ICE/DTLS parameters and Send/Receive capabilities

mySignaller.myOfferTracks({
  // Indicate that the initiator would prefer to multiplex both A/V and RTP/RTCP
  bundle: true,
  // Indicate that the initiator is willing to multiplex RTP/RTCP without A/V mux
  rtcpMux: true,
  // Offer the ICE parameters
  audioRtpIce: audioRtpIceGatherer.getLocalParameters(),
  audioRtcpIce: audioRtcpIceGatherer.getLocalParameters(),
  videoRtpIce: videoRtpIceGatherer.getLocalParameters(),
  videoRtcpIce: videoRtcpIceGatherer.getLocalParameters(),
  // Offer the DTLS parameters
  audioRtpDtls: audioRtpDtlsTransport.getLocalParameters(),
  audioRtcpDtls: audioRtcpDtlsTransport.getLocalParameters(),
  videoRtpDtls: videoRtpDtlsTransport.getLocalParameters(),
  videoRtcpDtls: videoRtcpDtlsTransport.getLocalParameters(),
  // Offer the receiver and sender audio and video capabilities.
  recvAudioCaps: recvAudioCaps,
  recvVideoCaps: recvVideoCaps,
  sendAudioCaps: sendAudioCaps,
  sendVideoCaps: sendVideoCaps
}, function(answer) {
  // The responder answers with its preferences, parameters and capabilities
  // Since we didn"t create transport arrays, we are assuming that there
  // is no forking (only one response)
  //
  // Derive the send and receive parameters, assuming that RTP/RTCP mux will be enabled.
  var audioSendParams = myCapsToSendParams(sendAudioCaps, answer.recvAudioCaps);
  var videoSendParams = myCapsToSendParams(sendVideoCaps, answer.recvVideoCaps);
  var audioRecvParams = myCapsToRecvParams(recvAudioCaps, answer.sendAudioCaps);
  var videoRecvParams = myCapsToRecvParams(recvVideoCaps, answer.sendVideoCaps);
  //
  // If the responder wishes to enable bundle, we will enable it
  if (answer.bundle) {
    // Since bundle implies RTP/RTCP multiplexing, we only need a single
    // ICE transport and DTLS transport. No need for the ICE transport controller.
    audioRtpIceTransport.start(audioRtpIceGatherer, answer.audioRtpIce, RTCIceRole.controlling);
    audioRtpDtlsTransport.start(remote.audioRtpDtls);
    //
    // Replace the transport on the Sender and Receiver objects
    //
    audioSender.setTransport(audioRtpDtlsTransport);
    videoSender.setTransport(audioRtpDtlsTransport);
    audioReceiver.setTransport(audioRtpDtlsTransport);
    videoReceiver.setTransport(audioRtpDtlsTransport);
    // If BUNDLE was requested, then also assume RTP/RTCP mux
    answer.rtcpMux = true;
  } else {
    var controller = new RTCIceTransportController();
    if (answer.rtcpMux) {
      // The peer doesn"t want BUNDLE, but it does want to multiplex RTP/RTCP
      // Now we need audio and video ICE transports
      // as well as an ICE Transport Controller object
      controller.addTransport(audioRtpIceTransport);
      controller.addTransport(videoRtpIceTransport);
      // Start the audio and video ICE transports
      audioRtpIceTransport.start(audioRtpIceGatherer, answer.audioRtpIce, RTCIceRole.controlling);
      videoRtpIceTransport.start(videoRtpIceGatherer, answer.videoRtpIce, RTCIceRole.controlling);
      // Start the audio and video DTLS transports
      audioRtpDtlsTransport.onerror = errorHandler;
      audioRtpDtlsTransport.start(answer.audioRtpDtls);
      videoRtpDtlsTransport.onerror = errorHandler;
      videoRtpDtlsTransport.start(answer.videoRtpDtls);
      // Replace the transport on the Sender and Receiver objects
      //
      audioSender.setTransport(audioRtpDtlsTransport);
      videoSender.setTransport(videoRtpDtlsTransport);
      audioReceiver.setTransport(audioRtpDtlsTransport);
      videoReceiver.setTransport(videoRtpDtlsTransport);
    } else {
      // We arrive here if the responder does not want BUNDLE
      // or RTP/RTCP multiplexing
      //
      // Now we need all the audio and video RTP and RTCP ICE transports
      // as well as an ICE Transport Controller object
      controller.addTransport(audioRtpIceTransport);
      controller.addTransport(videoRtpIceTransport);
      // Start the ICE transports
      audioRtpIceTransport.start(audioRtpIceGatherer, answer.audioRtpIce, RTCIceRole.controlling);
      audioRtcpIceTransport.start(audioRtcpIceGatherer, answer.audioRtcpIce,
        RTCIceRole.controlling);
      videoRtpIceTransport.start(videoRtpIceGatherer, answer.videoRtpIce, RTCIceRole.controlling);
      videoRtcpIceTransport.start(videoRtcpIceGatherer, answer.videoRtcpIce,
        RTCIceRole.controlling);
      // Start the DTLS transports that are needed
      audioRtpDtlsTransport.start(answer.audioRtpDtls);
      audioRtcpDtlsTransport.start(answer.audioRtcpDtls);
      videoRtpDtlsTransport.start(answer.videoRtpDtls);
      videoRtcpDtlsTransport.start(answer.videoRtcpDtls);
      // Disable RTP/RTCP multiplexing
      audioSendParams.rtcp.mux = false;
      videoSendParams.rtcp.mux = false;
      audioRecvParams.rtcp.mux = false;
      videoRecvParams.rtcp.mux = false;
    }
  }
  // Set the audio and video send and receive parameters.
  audioSender.send(audioSendParams).then(function() {
    trace("Set audio sender parameters");
    }, function() {
      trace("Could not set audio sender parameters");
    }
  );
  videoSender.send(videoSendParams).then(function() {
    trace("Set video sender parameters");
    }, function() {
      trace("Could not set video sender parameters");
    }
  );
  audioReceiver.receive(audioRecvParams).then(function() {
    trace("Set audio receiver parameters");
    }, function() {
      trace("Could not set audio receiver parameters");
    }
  );
  videoReceiver.receive(videoRecvParams).then(function() {
    trace("Set video receiver parameters");
    }, function() {
      trace("Could not set video receiver parameters");
    }
  );
// Now we can render/play audioReceiver.track and videoReceiver.track
                </pre>
    </section>
  </section>
  <section id="rtcrtplistener*">
    <h2><dfn>RTCRtpListener</dfn> Interface</h2>
    <p>The <code>RTCRtpListener</code> listens to RTP packets received from
    the <code><a>RTCDtlsTransport</a></code>, determining whether an incoming RTP stream
    is configured to be processed by an existing <code><a>RTCRtpReceiver</a></code>
    object. If no match is found, the <code><a>unhandledrtp</a></code> event is fired.
    This can be due to packets having an unknown SSRC, payload type or any other error
    that makes it impossible to attribute an RTP packet to a specific
    <code><a>RTCRtpReceiver</a></code> object. The event is not fired once for each
    arriving packet; multiple discarded packets for the same SSRC <em class="rfc2119"
    title="SHOULD">SHOULD</em> result in a single event.</p>
    <p>Note that application handling of the <code><a>unhandledrtp</a></code> event may
    not be sufficient to enable the unhandled RTP stream to be rendered. The amount of
    buffering to be provided for unhandled RTP streams is not mandated by this
    specification and is recommended to be strictly limited to protect against denial of
    service attacks. Therefore an application attempting to create additional
    <code><a>RTCRtpReceiver</a></code> objects to handle the incoming RTP stream may find
    that portions of the incoming RTP stream were lost due to insufficient buffers, and
    therefore could not be rendered.</p>
    <section id="rtcrtplistener-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCRtpListener</a></code> instance is associated to an
      <code><a>RTCDtlsTransport</a></code>.</p>
    </section>
    <section id="rtcrtplistener-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCRtpListener</a></code> instance is constructed from an
      <code><a>RTCDtlsTransport</a></code> object.</p>
    </section>
    <section id="rtcrtplistener-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">[ Constructor (RTCDtlsTransport transport), Exposed=Window]
interface RTCRtpListener {
    readonly        attribute RTCDtlsTransport transport;
                    attribute EventHandler     onunhandledrtp;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCRtpListener" data-dfn-for="RTCRtpListener" class=
          "constructors">
            <dt><code><a>RTCRtpListener</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpListener" data-dfn-for="RTCRtpListener" class=
          "attributes">
            <dt><dfn data-idl><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly</dt>
            <dd>
              <p>The RTP <code><a>RTCDtlsTransport</a></code> instance.</p>
            </dd>
            <dt><dfn data-idl><code>onunhandledrtp</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The event handler which handles the
              <code><a>RTCRtpUnhandledEvent</a></code>, which is fired when the
              <code><a>RTCRtpListener</a></code> detects an RTP stream that is not
              configured to be processed by an existing
              <code><a>RTCRtpReceiver</a></code> object.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtpunhandledevent-interface-definition*">
      <h3><dfn>RTCRtpUnhandledEvent</dfn></h3>
      <p>The <code><a>unhandledrtp</a></code> event of the
      <code><a>RTCRtpListener</a></code> object uses the
      <code><a>RTCRtpUnhandledEvent</a></code> interface.</p>
      <p>Firing an <code><a>RTCRtpUnhandledEvent</a></code> event named <var>e</var>
      means that an event with the name <var>e</var>, which does not bubble (except where
      otherwise stated) and is not cancelable (except where otherwise stated), and which
      uses the <code><a>RTCRtpUnhandledEvent</a></code> interface <em class="rfc2119"
      title="MUST">MUST</em> be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCRtpUnhandledEventInit eventInitDict), Exposed=Window]
interface RTCRtpUnhandledEvent : Event {
    readonly        attribute DOMString     muxId;
    readonly        attribute DOMString     rid;
    readonly        attribute payloadtype   payloadType;
    readonly        attribute unsigned long ssrc;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCRtpUnhandledEvent" data-dfn-for="RTCRtpUnhandledEvent"
          class="constructors">
            <dt><code>RTCRtpUnhandledEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>RTCRtpUnhandledEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCRtpUnhandledEvent" data-dfn-for="RTCRtpUnhandledEvent"
          class="attributes">
            <dt><dfn data-idl><code>muxId</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The value of the <a>MID</a> RTP header extension [[!BUNDLE]] in the RTP
              stream triggering the <code><a>unhandledrtp</a></code> event. If
              <code><a>receive</a>()</code> has not been called, the <a>MID</a> header
              extension cannot be decoded, so that <code>muxId</code> will be unset.</p>
            </dd>
            <dt><dfn data-idl><code>rid</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The value of the <a>RID</a> RTP header extension [[!RID]] in the RTP
              stream triggering the <code><a>unhandledrtp</a></code> event. If
              <code><a>receive</a>()</code> has not been called, the <a>RID</a> header
              extension cannot be decoded, so that <code>rid</code> will be unset.</p>
            </dd>
            <dt><dfn data-idl><code>payloadType</code></dfn> of type <span class=
            "idlAttrType"><a>payloadtype</a></span>, readonly</dt>
            <dd>
              <p>The Payload Type value in the RTP stream triggering the
              <code><a>unhandledrtp</a></code> event.</p>
            </dd>
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned long</a></span>, readonly</dt>
            <dd>
              <p>The SSRC in the RTP stream triggering the
              <code><a>unhandledrtp</a></code> event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
      <p>The <dfn><code>RTCRtpUnhandledEventInit</code></dfn> dictionary provides
      information on the RTP packet causing the <code><a>RTCRtpUnhandledEvent</a></code>.</p>
        <pre class="idl">dictionary RTCRtpUnhandledEventInit : EventInit {
             DOMString     muxId;
             DOMString     rid;
             required payloadtype   payloadType;
             required unsigned long ssrc;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpUnhandledEventInit</a> Members</h2>
          <dl data-link-for="RTCRtpUnhandledEventInit" data-dfn-for=
          "RTCRtpUnhandledEventInit" class="dictionary-members">
            <dt><dfn data-idl><code>muxId</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>If present, the value of the <a>MID</a> RTP header extension [[!BUNDLE]]
              in the RTP stream triggering the <code><a>unhandledrtp</a></code>
              event.</p>
            </dd>
            <dt><dfn data-idl><code>rid</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>If present, the value of the <a>RID</a> RTP header extension [[!RID]] in
              the RTP stream triggering the <code><a>unhandledrtp</a></code> event.</p>
            </dd>
            <dt><dfn data-idl><code>payloadType</code></dfn> of type <span class=
            "idlMemberType"><a>payloadtype</a></span>, required</dt>
            <dd>
              <p>The Payload Type value in the RTP stream triggering the
              <code><a>unhandledrtp</a></code> event.</p>
            </dd>
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span>, required</dt>
            <dd>
              <p>The SSRC in the RTP stream triggering the
              <code><a>unhandledrtp</a></code> event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <section id="typedef1*" data-dfn-for="Dictionary" data-link-for="Dictionary">
        <h2><dfn data-dfn-for="">Dictionary</dfn> Object</h2>
        <div>
          <pre class="idl">typedef object Dictionary;</pre>
          <div class="idlTypedefDesc">
            Throughout this specification, the identifier
            <code><a>Dictionary</a></code> is used to refer to the <span class=
            "idlTypedefType">object</span> type.
          </div>
        </div>
        </section>
        <section id="typedef2*" data-dfn-for="payloadtype" data-link-for="payloadtype">
        <h2><dfn data-dfn-for="">payloadtype</dfn> Type</h2>
        <div>
          <pre class="idl">typedef octet payloadtype;</pre>
          <div class="idlTypedefDesc">
            Throughout this specification, the identifier
            <code><a>payloadtype</a></code> is used to refer to the <span class=
            "idlTypedefType">octet</span> type.
          </div>
        </div>
      </section>
    </section>
  </section>
  <section id="rtcrtpdictionaries*">
    <h2>Dictionaries related to Rtp</h2>
    <section id="rtcrtpcapabilities*">
      <h3><dfn>RTCRtpCapabilities</dfn> Dictionary</h3>
      <p>The <code>RTCRtpCapabilities</code> object expresses the capabilities
      of <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> objects.
      Features which are mandatory to implement in [[!RTP-USAGE]], such as RTP/RTCP
      multiplexing [[!RFC5761]], audio/video multiplexing [[!RTP-MULTI-STREAM]] and
      reduced size RTCP [[!RFC5506]] are assumed to be available and are therefore not
      included in <code><a>RTCRtpCapabilities</a></code>, although these parameters
      may be set via <code>send()</code> or <code>receive()</code>.</p>
      <div>
        <pre class="idl">dictionary RTCRtpCapabilities {
             required sequence&lt;RTCRtpCodecCapability&gt; codecs;
             sequence&lt;RTCRtpHeaderExtension&gt; headerExtensions;
             sequence&lt;DOMString&gt;             fecMechanisms;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCapabilities</a> Members</h2>
          <dl data-link-for="RTCRtpCapabilities" data-dfn-for="RTCRtpCapabilities" class=
          "dictionary-members">
            <dt><dfn data-idl><code>codecs</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpCodecCapability</a>&gt;</span>, required</dt>
            <dd>
              <p>Supported codecs.</p>
            </dd>
            <dt><dfn data-idl><code>headerExtensions</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpHeaderExtension</a>&gt;</span></dt>
            <dd>
              <p>Supported RTP header extensions.</p>
            </dd>
            <dt><dfn data-idl><code>fecMechanisms</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>DOMString</a>&gt;</span></dt>
            <dd>
              <p>Supported Forward Error Correction (FEC) mechanisms
              and combinations. Supported values are "red" [[!RFC2198]],
              "red+ulpfec" [[RFC5109]] and "flexfec" [[FLEXFEC]]. Note that
              supported mechanisms also need to be included within
              <code>RTCRtpCapabilities.codecs[]</code>. [[FEC]] summarizes
              requirements relating to FEC mechanisms.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtcpfeedback*">
      <h3><dfn>RTCRtcpFeedback</dfn> Dictionary</h3>
      <p><code>RTCRtcpFeedback</code> provides information on RTCP feedback messages.</p>
      <div>
        <pre class="idl">dictionary RTCRtcpFeedback {
             required DOMString type;
             DOMString parameter;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtcpFeedback</a> Members</h2>
          <dl data-link-for="RTCRtcpFeedback" data-dfn-for="RTCRtcpFeedback" class=
          "dictionary-members">
            <dt><dfn data-idl><code>type</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>Valid values for <code>type</code> are the "RTCP Feedback" Attribute
              Values enumerated in [[!IANA-SDP-14]] ("ack", "ccm", "nack", etc.), as well
              as "goog-remb" [[REMB]] and "transport-cc" [[TRANSPORT-CC]].</p>
            </dd>
            <dt><dfn data-idl><code>parameter</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>For a <code>type</code> value of "ack" or "nack", valid values for
              <code>parameter</code> are the "ack" and "nack" Attribute Values enumerated
              in [[!IANA-SDP-15]] ("sli", "rpsi", etc.). For the Generic NACK feedback
              message defined in [[!RFC4585]] Section 6.2.1, the <code>type</code>
              attribute is set to "nack" and the <code>parameter</code> attribute is
              unset. For a <code>type</code> value of "ccm", valid values for
              <code>parameter</code> are the "Codec Control Messages" enumerated in
              [[!IANA-SDP-19]] ("fir", "tmmbr" (includes "tmmbn"), etc.).</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtpcodeccapability*">
      <h3><dfn>RTCRtpCodecCapability</dfn> Dictionary</h3>
      <p>The <code>RTCRtpCodecCapability</code> dictionary provides
        information on the capabilities of a codec. Exactly one <code>RTCRtpCodecCapability</code>
        will be present for each supported combination of parameters that requires a distinct
        value of <code>preferredPayloadType</code>. For example:</p>
      <ol>
        <li>Multiple "h264" codecs, each with their own distinct
          <code>packetization-mode</code> values.
        </li>
        <li>"cn" codecs, each with distinct <code>clockRate</code> values.</li>
      </ol>
      <div>
        <pre class="idl">dictionary RTCRtpCodecCapability {
             required DOMString                 name;
             DOMString                 mimeType;
             required DOMString                 kind;
             unsigned long             clockRate;
             required payloadtype               preferredPayloadType;
             unsigned long             maxptime;
             unsigned long             ptime;
             unsigned long             channels;
             sequence&lt;RTCRtcpFeedback&gt; rtcpFeedback;
             Dictionary                parameters;
             Dictionary                options;
             unsigned short            maxTemporalLayers = 0;
             unsigned short            maxSpatialLayers = 0;
             boolean                   svcMultiStreamSupport;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCodecCapability</a> Members</h2>
          <dl data-link-for="RTCRtpCodecCapability" data-dfn-for="RTCRtpCodecCapability"
          class="dictionary-members">
            <dt><dfn data-idl><code>name</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The MIME media subtype. Valid subtypes are listed in
              [[!IANA-RTP-2]].</p>
            </dd>
            <dt><dfn data-idl><code>mimeType</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The codec MIME media type/subtype. Valid media types and subtypes are
              listed in [[IANA-RTP-2]].</p>
            </dd>
            <dt><dfn data-idl><code>kind</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The media supported by the codec: "audio", "video", etc.</p>
            </dd>
            <dt><dfn data-idl><code>clockRate</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>Codec clock rate expressed in Hertz. If unset, the codec is applicable
              to any clock rate.</p>
            </dd>
            <dt><dfn data-idl><code>preferredPayloadType</code></dfn> of type <span class=
            "idlMemberType"><a>payloadtype</a></span>, required</dt>
            <dd>
              <p>The preferred RTP payload type for the codec denoted by
              <code>RTCRtpCodecCapability.name</code>. This attribute was added to make
              it possible for the sender and receiver to pick a matching payload type
              when creating sender and receiver parameters. When returned by
              <code>RTCRtpSender.getCapabilities()</code>,
              <code>RTCRtpCapabilities.codecs.preferredPayloadtype</code> represents the
              preferred RTP payload type for sending. When returned by
              <code>RTCRtpReceiver.getCapabilities()</code>,
              <code>RTCRtpCapabilities.codecs.preferredPayloadtype</code> represents the
              preferred RTP payload type for receiving. To avoid payload type conflicts,
              each value of <code>preferredPayloadType</code> MUST be unique.</p>
            </dd>
            <dt><dfn data-idl><code>maxptime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The maximum packetization time supported by the
              <code><a>RTCRtpReceiver</a></code>.</p>
            </dd>
            <dt><dfn data-idl><code>ptime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The preferred duration of media represented by a packet in milliseconds
              for the <code><a>RTCRtpSender</a></code> or
              <code><a>RTCRtpReceiver</a></code>.</p>
            </dd>
            <dt><dfn data-idl><code>channels</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The number of channels supported (e.g. two for stereo). For video, this
              attribute is unset.</p>
            </dd>
            <dt><dfn data-idl><code>rtcpFeedback</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtcpFeedback</a>&gt;</span></dt>
            <dd>
              <p>Transport layer and codec-specific feedback messages for this codec.</p>
            </dd>
            <dt><dfn data-idl><code>parameters</code></dfn> of type <span class=
            "idlMemberType"><a>Dictionary</a></span></dt>
            <dd>
              <p>Codec-specific parameters that must be signaled to the remote party.</p>
            </dd>
            <dt><dfn data-idl><code>options</code></dfn> of type <span class=
            "idlMemberType"><a>Dictionary</a></span></dt>
            <dd>
              <p>Codec-specific parameters that may be optionally signalled and are
              available as additional supported information or settings about the
              codec.</p>
            </dd>
            <dt><dfn data-idl><code>maxTemporalLayers</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, defaulting to
            <code>0</code></dt>
            <dd>
              <p>Maximum number of temporal layer extensions supported by this codec
              (e.g. a value of 1 indicates support for up to 2 temporal layers). A value
              of 0 indicates no support for temporal scalability.</p>
            </dd>
            <dt><dfn data-idl><code>maxSpatialLayers</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, defaulting to
            <code>0</code></dt>
            <dd>
              <p>Maximum number of spatial layer extensions supported by this codec (e.g.
              a value of 1 indicates support for up to 2 spatial layers). A value of 0
              indicates no support for spatial scalability.</p>
            </dd>
            <dt><dfn data-idl><code>svcMultiStreamSupport</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span></dt>
            <dd>
              <p>Whether the implementation can send/receive SVC layers utilizing
              distinct SSRCs. Unset for audio codecs. For video codecs, only set if the
              codec supports scalable video coding with <a>MRST</a>.</p>
            </dd>
          </dl>
        </section>
      </div>
      <section id="codec-capability-options*">
        <h3>Codec capability options</h3>
        <p>The capability options of commonly implemented codecs are provided below.</p>
        <p>If a defined codec option is unset when returned from
        <code>RTCRtpReceiver/Sender.getCapabilities()</code>, then the engine does not
        allow adjusting the option. If set when returned from
        <code>RTCRtpReceiver/Sender.getCapabilities()</code> then the default value for
        the engine is given.</p>
        <section id="opus-codec-options*">
          <h3>Opus</h3>
          <p>The following capability options are defined for Opus:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-complexity*">
                <td><dfn><code>complexity</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>Indicates the default value for the encoder's computational
                complexity. The supported range is 0-10 with 10 representing the highest
                complexity.</td>
              </tr>
              <tr id="def-signal*">
                <td><dfn><code>signal</code></dfn></td>
                <td><code>DOMString</code></td>
                <td>Sender</td>
                <td>Indicates the default value for the type of signal being encoded.
                Possible values are "auto", "music" and "voice".</td>
              </tr>
              <tr id="def-application*">
                <td><dfn><code>application</code></dfn></td>
                <td><code>DOMString</code></td>
                <td>Sender</td>
                <td>Indicates the default value for the encoder's intended application.
                Possible values are "voip", "audio" and "lowdelay".</td>
              </tr>
              <tr id="def-packetlossperc*">
                <td><dfn><code>packetlossperc</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>Indicates the default value for the encoder's expected packet loss
                percentage. Possible values are 0-100.</td>
              </tr>
              <tr id="def-predictiondisabled*">
                <td><dfn><code>predictiondisabled</code></dfn></td>
                <td><code>boolean</code></td>
                <td>Sender</td>
                <td>Indicates the default value for whether prediction is disabled,
                making frames almost complete independent (if <code>true</code>) or not
                (if <code>false</code>).</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section id="codec-capability-parameters*">
        <h3>Codec capability parameters</h3>
        <p>The capability parameters for commonly implemented codecs are provided
        below.</p>
        <p>If a defined codec capability parameter is unset when returned from
        <code>RTCRtpReceiver/Sender.getCapabilities()</code>, then the engine does not
        allow adjusting the parameter. If set when returned from
        <code>RTCRtpReceiver/Sender.getCapabilities()</code> then the default value for
        the engine is given.</p>
        <section id="opus-codec-capabilities*">
          <h3>Opus</h3>
          <p>The following optional capability parameters are defined for "opus", as
          noted in [[!RFC7587]] Section 6.1:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-maxplaybackrate*">
                <td><dfn><code>maxplaybackrate</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Receiver</td>
                <td>A hint about the maximum output sampling rate that the receiver is
                capable of rendering in Hz.</td>
              </tr>
              <tr id="def-sprop-maxcapturerate*">
                <td><dfn><code>sprop-maxcapturerate</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>A hint about the maximum input sampling rate that the sender is
                likely to produce.</td>
              </tr>
              <tr id="def-maxaveragebitrate*">
                <td><dfn><code>maxaveragebitrate</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Receiver</td>
                <td>Specifies the maximum average receive bitrate of a session in bits
                per second (bits/s).</td>
              </tr>
              <tr id="def-cbr*">
                <td><dfn><code>cbr</code></dfn></td>
                <td><code>boolean</code></td>
                <td>Receiver</td>
                <td>Specifies if the decoder prefers the use of constant bitrate (if
                <code>true</code>) or variable bitrate (if <code>false</code>).</td>
              </tr>
              <tr id="def-useinbandfec*">
                <td><dfn><code>useinbandfec</code></dfn></td>
                <td><code>boolean</code></td>
                <td>Receiver/Sender</td>
                <td>For a receiver, specifies if the decoder has the capability to take
                advantage of Opus in-band fec (if <code>true</code>) or not
                (if <code>false</code>). For a sender, specifies if the encoder
                supports DTX (if <code>true</code>) or not (if <code>false</code>).
                </td>
              </tr>
              <tr id="def-usedtx*">
                <td><dfn><code>usedtx</code></dfn></td>
                <td><code>boolean</code></td>
                <td>Receiver/Sender</td>
                <td>For a receiver, specifies if the decoder prefers the use of DTX (if
                <code>true</code>) or not (if <code>false</code>). For a sender, specifies
                if the encoder supports DTX (if <code>true</code>) or not (if <code>false</code>).
                </td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="vp-codec-dictionary*">
          <h3>VP8</h3>
          <p>The following receiver capability parameters are defined for "vp8", as noted
          in [[RFC7741]] Section 6.1:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-max-fr*">
                <td><dfn><code>max-fr</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Receiver</td>
                <td>This parameter indicates the maximum frame rate in frames per second
                that the decoder is capable of decoding.</td>
              </tr>
              <tr id="def-max-fs*">
                <td><dfn><code>max-fs</code></dfn></td>
                <td><code>unsigned long long</code></td>
                <td>Receiver</td>
                <td>This parameter indicates the maximum frame size in macroblocks that
                the decoder is capable of decoding.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="h264-capabilities*">
          <h3>H.264</h3>
          <p>The following capability parameters are defined for "h264", as noted in
          [[RFC6184]] Section 8.1, and [[!RFC7742]] Section 6.2.</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-profile-level-id*">
                <td><dfn><code>profile-level-id</code></dfn></td>
                <td><code>DOMString</code></td>
                <td>Receiver/Sender</td>
                <td>This parameter is encoded as a string representation of 6
                upper case hexadecimal digits, representing the profile-level-id
                parameter described in [[RFC6184]] Section 8.1.  It represents
                the maximum capability of the decoder (for an
                <code><a>RTCRtpReceiver</a></code>) or the encoder (for an
                <code><a>RTCRtpSender</a></code>). It MUST be supported, as noted
                in [[!RFC7742]] Section 6.2.</td>
              </tr>
              <tr id="def-packetization-mode*">
                <td><dfn><code>packetization-mode</code></dfn></td>
                <td><code>unsigned short</code></td>
                <td>Receiver/Sender</td>
                <td>An unsigned short, ranging from 0 to 2, indicating
                a supported <code>packetization-mode</code> value. As noted in [[!RFC7742]]
                Section 6.2, support for a value of 1 is mandatory.</td>
              </tr>
              <tr id="def-other-h264-params*">
                <td>max-mbps, max-smbps, max-fs, max-cpb, max-dpb, max-br</td>
                <td><code>unsigned long long</code></td>
                <td>Receiver</td>
                <td>As noted in [[!RFC7742]] Section 6.2, these optional parameters allow
                the implementation to specify that the decoder can support certain
                features of H.264 at higher rates and values than those signalled with
                profile-level-id.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="rtx-codec-capability*">
          <h3>RTX</h3>
          <p>The following capability parameters are defined for "rtx", as noted in [[!RFC4588]]
          Section 8.6:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-apt*">
                <td><dfn><code>apt</code></dfn></td>
                <td><code>payloadtype</code></td>
                <td>Receiver/Sender</td>
                <td>As defined in [[!RFC4588]], the associated payload type of the
                original stream being retransmitted. There will be an "rtx" entry in
                <code>RTCRtpCapabilities.codecs[]</code> for each media codec that can be
                retransmitted, each with their own <code>apt</code> parameter.  This
                makes it possible to support "capabilities exchange" signaling as well
                enabling implementations to indicate which media codecs support
                retransmission.</td>
              </tr>
              <tr id="def-rtx-time*">
                <td><dfn><code>rtx-time</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>As defined in [[!RFC4588]], the default time in milliseconds
                (measured from the time a packet was first sent) that the sender keeps an
                RTP packet in its buffers available for retransmission.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="red-codec-capability*">
          <h3>RED</h3>
          <p>As defined in [[!RFC2198]] Section 5, "red" has no codec-specific capability
          parameters.</p>
        </section>
        <section id="ulpfec-codec-capability*">
          <h3>Ulpfec</h3>
          <p>As noted in [[RFC5109]], "ulpfec" has no codec-specific capability
          parameters.</p>
        </section>
        <section id="flexfec-codec-capability*">
          <h3>Flexfec</h3>
          <p>The following capability parameters are defined for "flexfec", as noted in
          [[FLEXFEC]] Section 5.1.1:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="def-repair-window*">
                <td><dfn><code>repair-window</code></dfn></td>
                <td><code>unsigned long long</code></td>
                <td>Sender</td>
                <td>The default time that spans the source packets and the corresponding
                repair packets, in microseconds.</td>
              </tr>
              <tr id="def-L*">
                <td><dfn><code>L</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>The default number of columns of the source block that are protected
                by this FEC block.</td>
              </tr>
              <tr id="def-D*">
                <td><dfn><code>D</code></dfn></td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>The default number of rows of the source block that are protected by
                this FEC block.</td>
              </tr>
              <tr id="def-ToP*">
                <td><dfn><code>ToP</code></dfn></td>
                <td><code>unsigned short</code></td>
                <td>Sender</td>
                <td>The default type of protection for the sender: 0 for 1-D interleaved
                FEC protection, 1 for 1-D non-interleaved FEC protection, and 2 for 2-D
                parity FEC protection. The value of 3 is reserved for future use.</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
    </section>
    <section id="rtcrtpparameters*">
      <h3><dfn>RTCRtpParameters</dfn> Dictionary</h3>
      <p><code>RTCRtpParameters</code> contains the RTP stack settings used by both senders and receivers.</p>
      <div>
        <pre class="idl">dictionary RTCRtpParameters {
             DOMString                                 muxId = "";
    required sequence&lt;RTCRtpCodecParameters&gt;           codecs;
    required sequence&lt;RTCRtpHeaderExtensionParameters&gt; headerExtensions;
    required RTCRtcpParameters                         rtcp;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpParameters</a> Members</h2>
          <dl data-link-for="RTCRtpParameters" data-dfn-for="RTCRtpParameters" class=
          "dictionary-members">
            <dt><dfn data-idl><code>muxId</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, defaulting to <code>""</code></dt>
            <dd>
              <p>The <code>muxId</code> assigned to the RTP stream, if any.
              In an <code><a>RTCRtpReceiver</a></code> or <code><a>RTCRtpSender</a></code>,
              this corresponds to <a>MID</a> RTP header extension defined in [[!BUNDLE]].
              This is a stable identifier that permits the track corresponding to an
              RTP stream to be identified, rather than relying on an SSRC. An SSRC is
              randomly generated and can change arbitrarily due to conflicts with
              other SSRCs, whereas the <code>muxId</code> has a value whose meaning
              can be defined in advance between RTP sender and receiver, assisting in
              RTP demultiplexing. Since <code>muxId</code> is included in
              <code><a>RTCRtpParameters</a></code>, if it is desired to
              send simulcast streams with different <code>muxId</code> values for each
              stream, then multiple <code><a>RTCRtpSender</a></code> objects are
              needed.</p>
            </dd>
            <dt><dfn data-idl><code>codecs</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpCodecParameters</a>&gt;</span>,
            required</dt>
            <dd>
              <p>The codecs to send or receive (could include "red" [[RFC2198]], "rtx"
              [[!RFC4588]] and "cn" [[RFC3389]]). <code>codecs</code> MUST be set for an
              <code><a>RTCRtpParameters</a></code> object to be a valid argument passed
              to <code>send()</code> or <code>receive()</code>.</p>
            </dd>
            <dt><dfn data-idl><code>headerExtensions</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpHeaderExtensionParameters</a>&gt;</span>,
            required</dt>
            <dd>
              <p>Configured header extensions. If unset, no header extensions are
              configured.</p>
            </dd>
            <dt><dfn data-idl><code>rtcp</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtcpParameters</a></span>, required</dt>
            <dd>
              <p>Parameters to configure RTCP. If unset, the default values described in
              Section 9.6.1 are assumed.</p>
            </dd>
          </dl>
        </section>
      </div>
   <section id="rtcrtpsendparameters*">
      <h3><dfn>RTCRtpSendParameters</dfn> Dictionary</h3>
      <p><code>RTCRtpSendParameters</code> contains the RTP stack settings used by senders.</p>
      <div>
        <pre class="idl">dictionary RTCRtpSendParameters : RTCRtpParameters {
             required sequence&lt;RTCRtpEncodingParameters&gt;        encodings;
             RTCDegradationPreference                  degradationPreference = "balanced";
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpSendParameters</a> Members</h2>
          <dl data-link-for="RTCRtpSendParameters" data-dfn-for="RTCRtpSendParameters" class=
          "dictionary-members">
            <dt><dfn data-idl><code>encodings</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpEncodingParameters</a>&gt;</span></dt>
            <dd>
              <p>The "encodings" or "layers" to be used for things like simulcast,
              Scalable Video Coding, RTX, FEC, etc.  A sender MAY send fewer layers
              than what is specified in <code>encodings[]</code>, but MUST NOT
              send more. When unset in a call to <code>send()</code>, the browser
              behaves as though a single <code>encodings[0]</code> entry was provided,
              with <code>encodings[0].ssrc</code> set to a browser-determined value,
              <code>encodings[0].active</code> set to <code>true</code>,
              <code>encodings[0].codecPayloadType</code> set to
              <code>codecs[<var>j</var>].payloadType</code> where <var>j</var> is the
              index of the first codec that is not "cn", "telephone-event", "red", "rtx"
              or a forward error correction codec ("ulpfec" [[RFC5109]] or "flexfec"
              [[FLEXFEC]]), and all the other <code>parameters.encodings[0]</code>
              attributes (e.g. <code>fec</code>, <code>rtx</code>, <code>priority</code>,
              <code>maxBitrate</code>, <code>resolutionScale</code>, etc.) unset. When
              unset in a call to <code>receive()</code>, the behavior is described in
              Section 6.5.</p>
            </dd>
            <dt><dfn data-idl><code>degradationPreference</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDegradationPreference</a></span></dt>
            <dd>
              <p>When bandwidth is constrained and the <code><a>RTCRtpSender</a></code>
              needs to choose between degrading resolution or degrading framerate,
              <code>degradationPreference</code> indicates which is preferred.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
   <section id="rtcrtpreceiveparameters*">
      <h3><dfn>RTCRtpReceiveParameters</dfn> Dictionary</h3>
      <p><code>RTCRtpReceiveParameters</code> contains the RTP stack settings used by receivers.</p>
      <div>
        <pre class="idl">dictionary RTCRtpReceiveParameters : RTCRtpParameters {
             required sequence&lt;RTCRtpDecodingParameters&gt;        encodings;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpReceiveParameters</a> Members</h2>
          <dl data-link-for="RTCRtpReceiveParameters" data-dfn-for="RTCRtpReceiveParameters" class=
          "dictionary-members">
            <dt><dfn data-idl><code>encodings</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtpDecodingParameters</a>&gt;</span>, required</dt>
            <dd>
              <p>The "encodings" or "layers" to be used for things like simulcast,
              Scalable Video Coding, RTX, FEC, etc.  When unset in a call to
              <code>receive()</code>, the behavior is described in
              Section 6.5.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    </section>
    <section id="rtcdtxstatus">
      <h3><dfn>RTCDtxStatus</dfn> Enum</h3>
      <div>
        <pre class="idl">enum RTCDtxStatus {
         "disabled",
         "enabled"
         };</pre>
        <table data-link-for="RTCDtxStatus" data-dfn-for="RTCDtxStatus" class=
        "simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn data-idl><code>disabled</code></dfn></td>
              <td>
                <p>Discontinuous transmission is disabled.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code>enabled</code></dfn></td>
              <td>
                <p>Discontinuous transmission is enabled if negotiated.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcdegradationpreference*">
      <h3><dfn>RTCDegradationPreference</dfn> Enum</h3>
      <p><code>RTCDegradationPreference</code> can be used to indicate the
      desired choice between degrading resolution and degrading framerate when bandwidth
      is constrained.</p>
      <div>
        <pre class="idl">enum RTCDegradationPreference {
    "maintain-framerate",
    "maintain-resolution",
    "balanced"
};</pre>
        <table data-link-for="RTCDegradationPreference" data-dfn-for=
        "RTCDegradationPreference" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCDegradationPreference.maintain-framerate">maintain-framerate</code></dfn></td>
              <td>
                <p>Degrade resolution in order to maintain framerate.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCDegradationPreference.maintain-resolution">maintain-resolution</code></dfn></td>
              <td>
                <p>Degrade framerate in order to maintain resolution.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCDegradationPreference.balanced">balanced</code></dfn></td>
              <td>
                <p>Degrade a balance of framerate and resolution.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcrtcpparameters*">
      <h3><dfn>RTCRtcpParameters</dfn> Dictionary</h3>
      <p><code>RTCRtcpParameters</code> provides information on RTCP
      settings.</p>
      <div>
        <pre class="idl">dictionary RTCRtcpParameters {
             unsigned long ssrc;
             DOMString     cname;
             boolean       reducedSize = false;
             boolean       mux = true;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtcpParameters</a> Members</h2>
          <dl data-link-for="RTCRtcpParameters" data-dfn-for="RTCRtcpParameters" class=
          "dictionary-members">
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The SSRC to be used in the "SSRC of packet sender" field defined in
              [[!RFC3550]] Section 6.4.2 (Receiver Report) and [[!RFC4585]] Section 6.1
              (Feedback Messages), as well as the "SSRC" field defined in [[!RFC3611]]
              Section 2 (Extended Reports). It can only be set for an
              <code><a>RTCRtpReceiver</a></code>. Other than for debugging, or situations
              where <code>receive()</code> is called before <code>send()</code> on the
              same <code><a>RTCDtlsTransport</a></code> it is best to leave it unset, in
              which case <code>ssrc</code> is chosen by the browser, though the chosen
              value is not reflected in <code>RTCRtcpParameters.ssrc</code>. If the
              browser chooses the <code>ssrc</code> it may change it in event of a
              collision, as described in [[!RFC3550]]. Where
              <code>send(<var>parameters</var>)</code> is called before
              <code>receive()</code> on the same <code><a>RTCDtlsTransport</a></code>,
              the browser can choose one of the SSRCs allocated to an
              <code><a>RTCRtpSender</a></code> of the same <code>kind</code>. Where
              <code>receive()</code> is called first, a random SSRC value can be
              chosen.</p>
            </dd>
            <dt><dfn data-idl><code>cname</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The Canonical Name (CNAME) used by RTCP (e.g. in SDES messages).
              Guidelines for CNAME generation are provided in [[!RTP-USAGE]] Section 4.9
              and [[!RFC7022]]. By default, ORTC implementations <em class="rfc2119"
              title="SHOULD">SHOULD</em> set the CNAME to be the same within all
              <code>RTCRtcpParameter</code> objects created within the same Javascript
              sandbox. For backward compatibility with WebRTC 1.0, applications MAY set
              the CNAME only for an <code><a>RTCRtpReceiver</a></code>; if unset, the
              CNAME is chosen by the browser.</p>
            </dd>
            <dt><dfn data-idl><code>reducedSize</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>false</code></dt>
            <dd>
              <p>Whether reduced size RTCP [[!RFC5506]] is configured (if
              <code>true</code>) or compound RTCP as specified in [[!RFC3550]] (if
              <code>false</code>). The default is <code>false</code>.</p>
            </dd>
            <dt><dfn data-idl><code>mux</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>true</code></dt>
            <dd>
              <p>Whether RTP and RTCP are multiplexed, as specified in [[!RFC5761]]. The
              default is <code>true</code>. If set to <code>false</code>, the
              <code><a>RTCIceTransport</a></code> <em class="rfc2119" title=
              "MUST">MUST</em> have an associated <code><a>RTCIceTransport</a></code>
              object with a <code>component</code> of <code>rtcp</code>, in which case
              RTCP will be sent on the associated
              <code><a>RTCIceTransport</a></code>.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtpcodecparameters*">
      <h3><dfn>RTCRtpCodecParameters</dfn> Dictionary</h3>
      <p><code>RTCRtpCodecParameters</code> provides information on codec settings.</p>
      <div>
        <pre class="idl">dictionary RTCRtpCodecParameters {
    required DOMString                 name;
             DOMString                 mimeType;
    required payloadtype               payloadType;
             unsigned long             clockRate;
             unsigned long             maxptime;
             unsigned long             ptime;
             unsigned long             channels;
             sequence&lt;RTCRtcpFeedback&gt; rtcpFeedback;
             Dictionary                parameters;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCodecParameters</a> Members</h2>
          <dl data-link-for="RTCRtpCodecParameters" data-dfn-for="RTCRtpCodecParameters"
          class="dictionary-members">
            <dt><dfn data-idl><code>name</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The codec MIME subtype. Valid subtypes are listed in
              [[!IANA-RTP-2]].</p>
            </dd>
            <dt><dfn data-idl><code>mimeType</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>The codec MIME media type/subtype. Valid media types and subtypes are
              listed in [[IANA-RTP-2]].</p>
            </dd>
            <dt><dfn data-idl><code>payloadType</code></dfn> of type <span class=
            "idlMemberType"><a>payloadtype</a></span>, required</dt>
            <dd>
              <p>The value that goes in the RTP Payload Type Field [[!RFC3550]]. The
              <code>payloadType</code> MUST always be provided, and MUST be unique.</p>
            </dd>
            <dt><dfn data-idl><code>clockRate</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>Codec clock rate expressed in Hertz.</p>
            </dd>
            <dt><dfn data-idl><code>maxptime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The maximum packetization time set on the
              <code><a>RTCRtpSender</a></code>. Not specified if unset. If
              <code>ptime</code> is also set, <code>maxptime</code> is ignored.</p>
            </dd>
            <dt><dfn data-idl><code>ptime</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The duration of media represented by a packet in milliseconds for the
              <code><a>RTCRtpSender</a></code>. If unset, the
              <code><a>RTCRtpSender</a></code> may select any value up to
              <code>maxptime</code>.</p>
            </dd>
            <dt><dfn data-idl><code>channels</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The number of channels supported (e.g. two for stereo). If unset for
              audio, use the codec default. For video, this can be left unset.</p>
            </dd>
            <dt><dfn data-idl><code>rtcpFeedback</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCRtcpFeedback</a>&gt;</span></dt>
            <dd>
              <p>Transport layer and codec-specific feedback messages for this codec.</p>
            </dd>
            <dt><dfn data-idl><code>parameters</code></dfn> of type <span class=
            "idlMemberType"><a>Dictionary</a></span></dt>
            <dd>
              <p>Codec-specific parameters available for signaling.</p>
            </dd>
          </dl>
        </section>
      </div>
      <section id="codec-parameters*">
        <h3>Codec parameters</h3>
        <p>The parameters of common codecs are described below.</p>
        <section id="opus-codec-settings*">
          <h3>Opus</h3>
          <p>The following settings are defined for "opus":</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="sec-maxplaybackrate*">
                <td>
                  <a>maxplaybackrate</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>The maximum output sampling rate of the encoder in Hz.</td>
              </tr>
              <tr id="sec-sprop-maxcapturerate*">
                <td>
                  <a>sprop-maxcapturerate</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Receiver</td>
                <td>The maximum input sampling rate produced by the sender.</td>
              </tr>
              <tr id="sec-cbr*">
                <td>
                  <a>cbr</a>
                </td>
                <td><code>boolean</code></td>
                <td>Sender</td>
                <td>Specifies if the encoder is configured to generate constant bitrate
                (if <code>true</code>) or variable bitrate (if <code>false</code>).</td>
              </tr>
              <tr id="sec-useinbandfec*">
                <td>
                  <a>useinbandfec</a>
                </td>
                <td><code>boolean</code></td>
                <td>Sender</td>
                <td>Specifies if the encoder is configured to generate Opus in-band fec
                (if <code>true</code>) or not (if <code>false</code>).</td>
              </tr>
              <tr id="sec-usedtx*">
                <td>
                  <a>usedtx</a>
                </td>
                <td><code>boolean</code></td>
                <td>Sender</td>
                <td>Specifies if the encoder is configured to use DTX (if
                <code>true</code>) or not (if <code>false</code>).</td>
              </tr>
              <tr id="sec-complexity*">
                <td>
                  <a>complexity</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>Configures the encoder's computational complexity. The supported
                range is 0-10 with 10 representing the highest complexity.</td>
              </tr>
              <tr id="sec-signal*">
                <td>
                  <a>signal</a>
                </td>
                <td><code>DOMString</code></td>
                <td>Sender</td>
                <td>Configures the type of signal being encoded. Possible values are
                "auto", "music" and "voice".</td>
              </tr>
              <tr id="sec-application*">
                <td>
                  <a>application</a>
                </td>
                <td><code>DOMString</code></td>
                <td>Sender</td>
                <td>Configures the encoder's intended application. Possible values are
                "voip", "audio" and "lowdelay".</td>
              </tr>
              <tr id="sec-packetlossperc*">
                <td>
                  <a>packetlossperc</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>Configures the encoder's expected packet loss percentage. Possible
                values are 0-100.</td>
              </tr>
              <tr id="sec-predictiondisabled*">
                <td>
                  <a>predictiondisabled</a>
                </td>
                <td><code>boolean</code></td>
                <td>Sender</td>
                <td>Configures whether prediction is disabled, making frames almost
                complete independent (if <code>true</code>) or not (if
                <code>false</code>).</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="vp8-settings*">
          <h3>VP8</h3>
          <p>The following settings are defined for "vp8":</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="sec-max-fr*">
                <td>
                  <a>max-fr</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>This parameter indicates the maximum frame rate in frames per second
                that the decoder is capable of decoding.</td>
              </tr>
              <tr id="sec-max-fs*">
                <td>
                  <a>max-fs</a>
                </td>
                <td><code>unsigned long long</code></td>
                <td>Sender</td>
                <td>This parameter indicates the maximum frame size in macroblocks that
                the decoder is capable of decoding.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="h264-settings*">
          <h3>H.264</h3>
          <p>The following settings are defined for "h264":</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="sec-profile-level-id*">
                <td>
                  <a>profile-level-id</a>
                </td>
                <td><code>DOMString</code></td>
                <td>Sender</td>
                <td>This parameter, encoded as a string of 6 upper case hexadecimal
                digits, indicates the configuration of the stream to be sent, as
                described in [[RFC6184]] Section 8.2.2. It MUST be supported,
                as noted in [[!RFC7742]] Section 6.2.</td>
              </tr>
              <tr id="sec-packetization-mode*">
                <td>
                  <a>packetization-mode</a>
                </td>
                <td><code>unsigned short</code></td>
                <td>Sender</td>
                <td>An unsigned short ranging from 0 to 2, indicating the
                <var>packetization-mode</var> value to be used by the sender. This setting
                MUST be supported, as noted in [[!RFC7742]] Section 6.2. A value of
                1 is assumed if <code>packetization-mode</code> is not set.</td>
              </tr>
              <tr id="def-other-h264-params*">
                <td>max-mbps, max-smbps, max-fs, max-cpb, max-dpb, max-br</td>
                <td><code>unsigned long long</code></td>
                <td>Sender</td>
                <td>These optional settings allow the sender to restrict its
                output to the maximum values indicated by the receiver.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="rtx-codec-settings*">
          <h3>RTX</h3>
          <p>The following settings are defined for "rtx", as noted in [[!RFC4588]]
          Section 8.6:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="sec-apt*">
                <td>
                  <a>apt</a>
                </td>
                <td><code>payloadtype</code></td>
                <td>Receiver/Sender</td>
                <td>As defined in [[!RFC4588]], the associated payload type of the
                original stream being retransmitted. There will be an "rtx" entry in
                <code>RTCRtpParameters.codecs[]</code> for each media codec that can be
                retransmitted, each with their own <code>apt</code> parameter.</td>
              </tr>
              <tr id="sec-rtx-time*">
                <td>
                  <a>rtx-time</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Receiver</td>
                <td>As defined in [[!RFC4588]], the time in milliseconds (measured from
                the time a packet was first sent) that the sender keeps an RTP packet in
                its buffers available for retransmission.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="red-codec-settings*">
          <h3>RED</h3>
          <p>The following setting is defined for "red", as noted in [[!RFC2198]] Section
          5:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="sec-payloadtypes*">
                <td>payloadTypes</td>
                <td><code>sequence&lt;payloadtype&gt;</code></td>
                <td>Sender/Receiver</td>
                <td>A sequence of payload types to be encapsulated in RED, each of which
                MUST be unique. If <code>payloadTypes</code> is unset, this means that
                any codec other than "red" or "rtx" can be encapsulsated in RED.</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section id="ulpfec-codec-settings*">
          <h3>Ulpfec</h3>
          <p>As noted in [[RFC5109]], "ulpfec" has no codec-specific settings.</p>
        </section>
        <section id="flexfec-codec-settings*">
          <h3>Flexfec</h3>
          <p>The following settings are defined for "flexfec", as noted in [[FLEXFEC]]
          Section 5.1.1:</p>
          <table class="simple">
            <thead>
              <tr>
                <th>Property Name</th>
                <th>Values</th>
                <th>Receiver/Sender</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr id="sec-repair-window*">
                <td>
                  <a>repair-window</a>
                </td>
                <td><code>unsigned long long</code></td>
                <td>Receiver</td>
                <td>The time that spans the source packets and the corresponding repair
                packets, in microseconds.</td>
              </tr>
              <tr id="sec-L*">
                <td>
                  <a>L</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>The number of columns of the source block that are protected by this
                FEC block.</td>
              </tr>
              <tr id="sec-D*">
                <td>
                  <a>D</a>
                </td>
                <td><code>unsigned long</code></td>
                <td>Sender</td>
                <td>The number of rows of the source block that are protected by this FEC
                block.</td>
              </tr>
              <tr id="sec-ToP*">
                <td>
                  <a>ToP</a>
                </td>
                <td><code>unsigned short</code></td>
                <td>Sender</td>
                <td>The type of protection applied by the sender: 0 for 1-D interleaved
                FEC protection, 1 for 1-D non-interleaved FEC protection, and 2 for 2-D
                parity FEC protection. The value of 3 is reserved for future use.</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
    </section>
    <section id="rtcrtpcodingparameters*">
      <h3><dfn>RTCRtpCodingParameters</dfn> Dictionary</h3>
      <p><code>RTCRtpCodingParameters</code> provides information relating to
      both encoding and decoding.</p>
      <div>
        <pre class="idl">dictionary RTCRtpCodingParameters {
             unsigned long       ssrc;
             payloadtype         codecPayloadType;
             RTCRtpFecParameters fec;
             RTCRtpRtxParameters rtx;
             boolean             active = true;
             DOMString           rid;
             DOMString           encodingId;
             sequence&lt;DOMString&gt; dependencyEncodingIds;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpCodingParameters</a> Members</h2>
          <dl data-link-for="RTCRtpCodingParameters" data-dfn-for=
          "RTCRtpCodingParameters" class="dictionary-members">
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The SSRC for this layering/encoding. Multiple
              <code><a>RTCRtpCodingParameters</a></code> dictionaries can share the same
              <code>ssrc</code> value (useful, for example, to indicate that different
              RTX payload types associated to different codecs are carried over the same
              stream). If <code>ssrc</code> is unset in the <var>parameters</var>
              argument to <code><a>receive</a>()</code>, the next unhandled SSRC will match,
              and an <code><a>RTCRtpUnhandledEvent</a></code> will not be fired. If
              <code>ssrc</code> is unset in the <var>parameters</var> argument to
              <code>send()</code>, the browser will choose, and the chosen value
              is not reflected in <code>ssrc</code>. If
              the browser chooses the <code>ssrc</code>, it may change it due to a
              collision without firing an <code><a>RTCSsrcConflictEvent</a></code>. If
              <code>ssrc</code> is set in the <var>parameters</var> argument to
              <code>send()</code> and an SSRC conflict is detected within the RTP
              session, then an <code><a>RTCSsrcConflictEvent</a></code> is fired
              (see Section 5.4).</p>
            </dd>
            <dt><dfn data-idl><code>codecPayloadType</code></dfn> of type <span class=
            "idlMemberType"><a>payloadtype</a></span></dt>
            <dd>
              <p>For per-encoding codec specifications, give the codec payload type here.
              If unset, the browser will choose the first codec in
              <code>parameters.codecs[]</code> of the appropriate kind.</p>
            </dd>
            <dt><dfn data-idl><code>fec</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtpFecParameters</a></span></dt>
            <dd>
              <p>Specifies the FEC mechanism if set.</p>
            </dd>
            <dt><dfn data-idl><code>rtx</code></dfn> of type <span class=
            "idlMemberType"><a>RTCRtpRtxParameters</a></span></dt>
            <dd>
              <p>Specifies the RTX [[!RFC4588]] parameters if set.</p>
            </dd>
            <dt><dfn data-idl><code>active</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>true</code></dt>
            <dd>
              <p>For an <code><a>RTCRtpSender</a></code>, indicates whether this
              encoding is actively being sent. Setting it to <code>false</code>
              causes this encoding to no longer be sent. Setting it to <code>true</code>
              causes this encoding to be sent. For an <code><a>RTCRtpReceiver</a></code>,
              indicates that this encoding is being decoded. Setting it to
              <code>false</code> causes this encoding to no longer be decoded.
              Setting it to <code>true</code> causes this encoding to be decoded.
              Setting <code>active</code> to <code>false</code> is different than
              omitting the encoding, since it can keep resources available to
              re-activate more quickly than re-adding the encoding. As noted
              in [[RFC3264]] Section 5.1, RTCP is still sent, regardless
              of the value of the <code>active</code> attribute.</p>
            </dd>
            <dt><dfn data-idl><code>rid</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>If set, this RTP encoding will be sent or received with
              <a>RID</a> header extension as defined by [[!RID]].</p>
            </dd>
            <dt><dfn data-idl><code>encodingId</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>An identifier for the encoding object. This identifier should be unique
              within the scope of the localized sequence of
              <code><a>RTCRtpCodingParameters</a></code> for any given
              <code><a>RTCRtpParameters</a></code> object. Values MUST be composed only
              of alphanumeric characters (a-z, A-Z, 0-9) up to a maximum
              of 16 characters. For a codec (such as VP8 or VP9) using
              <a>SRST</a> transport which requires a compliant decoder to be able to
              to decode anything that an encoder can send, it is not required that the
              <code>encodingId</code> and <code>dependencyEncodingIds</code> be set
              in order to enable a receiver to decode scalable video coding.</p>
            </dd>
            <dt><dfn data-idl><code>dependencyEncodingIds</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>DOMString</a>&gt;</span></dt>
            <dd>
              <p>The <code><a>encodingId</a></code>s on which this layer depends. Within
              this specification <code><a>encodingId</a></code>s are permitted only
              within the same <code><a>RTCRtpCodingParameters</a></code> sequence. In
              the future if <a>MST</a> were to be supported, then if searching within an
              <code>encodings[]</code> sequence did not produce a match, then a global
              search would be carried out. In order to send scalable video coding
              (<a>SVC</a>), both the <code>encodingId</code> and
              <code>dependencyEncodingIds</code> are required.</p>
            </dd>
          </dl>
        </section>
      </div>
    <section id="rtcrtpencodingparameters*">
      <h3><dfn>RTCRtpEncodingParameters</dfn> Dictionary</h3>
      <p><code>RTCRtpEncodingParameters</code> provides information relating to
      an encoding. Note that all encoding parameters (such as <var>maxBitrate</var>,
      <var>maxFramerate</var> and <var>resolutionScale</var>) are applied prior to
      codec-specific constraints.</p>
      <div>
        <pre class="idl">dictionary RTCRtpEncodingParameters : RTCRtpCodingParameters {
             RTCDtxStatus        dtx;
             RTCPriorityType     priority = "low";
             unsigned long       maxBitrate;
             double              resolutionScale;
             double              framerateScale;
             double              maxFramerate;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpEncodingParameters</a> Members</h2>
          <dl data-link-for="RTCRtpEncodingParameters" data-dfn-for=
          "RTCRtpEncodingParameters" class="dictionary-members">
            <dt><dfn data-idl><code>dtx</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDtxStatus</a></span></dt>
            <dd>
              <p>This member is typically only used if the sender's
              <code>kind</code> is <code>audio</code>. Indicates whether
              discontinuous transmission will be used. Setting it to
              <code>disabled</code> causes discontinuous transmission to
              be turned off. Setting it to <code>enabled</code> causes
              discontinuous transmission to be turned on only when enabling
              enabling codec-specific DTX functionality or the CN codec.</p>
            </dd>
            <dt><dfn data-idl><code>priority</code></dfn> of type <span class=
            "idlMemberType"><a>RTCPriorityType</a></span>, defaulting to
            <code>low</code></dt>
            <dd>
              <p>Indicates the priority of this encoding. It is specified in
              [[RTCWEB-TRANSPORT]], Section 4. For scalable video coding, this parameter
              is only relevant for the base layer.</p>
            </dd>
            <dt><dfn data-idl><code>maxBitrate</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>Ramp up resolution/quality/framerate until this bitrate,
              if set; if unset, there is no maximum bitrate.
              <code>maxBitrate</code> is computed the same way as the
              Transport Independent Application Specific Maximum (TIAS)
              bandwidth defined in [[RFC3890]] Section 6.2.2, which is the maximum
              bandwidth needed without counting IP or other transport layers like TCP or
              UDP. Summed when using dependent layers. This attribute is ignored in
              scalable video coding.</p>
            </dd>
            <dt><dfn data-idl><code>resolutionScale</code></dfn> of type <span class=
            "idlMemberType"><a>double</a></span></dt>
            <dd>
              <p>If <code><var>sender</var>.track.kind</code> is "video",
              the encoder will scale down the resolution of
              <code><var>sender</var>.track</code> in each dimension before
              sending. For example, if the value is 2.0, the video will be
              scaled down by a factor of at least 2 in each dimension,
              resulting in sending a video no greater than one quarter size.
              If the value is 1.0 or unset, the <code><var>sender</var></code>
              will attempt to encode with the resolution of <code>track</code>. For
              scalable video coding, <code>resolutionScale</code> refers to the aggregate
              scale down of this layer when combined with all dependent layers.</p>
              <p>If <code>resolutionScale</code> is less than 1.0, <a>reject</a> the
              promise with <code>RangeError</code> when <code>send()</code>
              or <code><a>receive</a>()</code> is called.  If
              <code><var>sender</var>.track.kind</code> is "audio", the value is
              ignored.</p>
            </dd>
            <dt><dfn data-idl><code>framerateScale</code></dfn> of type <span class=
            "idlMemberType"><a>double</a></span></dt>
            <dd>
              <p>Inverse of the input framerate fraction to be encoded. Example: 1.0 =
              full framerate, 2.0 = one half of the full framerate. For scalable video
              coding, <code>framerateScale</code> refers to the inverse of the aggregate
              fraction of input framerate achieved by this layer when combined with all
              dependent layers.</p>
            </dd>
            <dt><dfn data-idl><code>maxFramerate</code></dfn> of type <span class=
            "idlMemberType"><a>double</a></span></dt>
            <dd>
              <p>The maximum framerate to use for this encoding, in frames per
              second. This attribute is not used for scalable video coding. If
              <code><a>framerateScale</a></code> is set, then
              <code>maxFramerate</code> is ignored.</p>
            </dd>
          </dl>
      </section> 
      </div>
    </section>
    <section id="rtcrtpdecodingparameters*">
      <h3><dfn>RTCRtpDecodingParameters</dfn> Dictionary</h3>
      <p><code>RTCRtpDecodingParameters</code> provides information used in
      decoding.</p>
      <div>
        <pre class="idl">dictionary RTCRtpDecodingParameters: RTCRtpCodingParameters {
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpDecodingParameters</a> Members</h2>
          <dl data-link-for="RTCRtpDecodingParameters" data-dfn-for=
          "RTCRtpDecodingParameters" class="dictionary-members">
          </dl>
        </section>
      </div>
      <h3>Summary Table</h3>
      <p>Usage of the attributes is defined in the table below:</p>
      <table class="simple">
        <thead>
          <tr>
            <th>Attribute</th>
            <th>Type</th>
            <th>Receiver/Sender</th>
          </tr>
        </thead>
        <tbody>
          <tr id="def-ssrc*">
            <td><dfn data-idl><code>ssrc</code></dfn></td>
            <td><code>unsigned long</code></td>
            <td>Receiver/Sender</td>
          </tr>
          <tr id="def-codecPayloadType*">
            <td><dfn data-idl><code>codecPayloadType</code></dfn></td>
            <td><code>payloadtype</code></td>
            <td>Receiver/Sender</td>
          </tr>
          <tr id="def-fec*">
            <td><dfn data-idl><code>fec</code></dfn></td>
            <td><code><a>RTCRtpFecParameters</a></code></td>
            <td>Receiver/Sender</td>
          </tr>
          <tr id="def-rtx*">
            <td><dfn data-idl><code>rtx</code></dfn></td>
            <td><code><a>RTCRtpRtxParameters</a></code></td>
            <td>Receiver/Sender</td>
          </tr>
          <tr id="def-dtx*">
            <td><dfn data-idl><code>dtx</code></dfn></td>
            <td><code><a>RTCDtxStatus</a></code></td>
            <td>Sender</td>
          </tr>
          <tr id="def-priority*">
            <td><dfn data-idl><code>priority</code></dfn></td>
            <td><code><a>RTCPriorityType</a></code></td>
            <td>Sender</td>
          </tr>
          <tr id="def-maxbitrate*">
            <td><dfn data-idl><code>maxBitrate</code></dfn></td>
            <td><code>unsigned long</code></td>
            <td>Sender</td>
          </tr>
          <tr id="def-resolutionscale*">
            <td><dfn data-idl><code>resolutionScale</code></dfn></td>
            <td><code>double</code></td>
            <td>Sender</td>
          </tr>
          <tr id="def-frameratescale*">
            <td><dfn data-idl><code>framerateScale</code></dfn></td>
            <td><code>double</code></td>
            <td>Sender</td>
          </tr>
          <tr id="def-maxframerate*">
            <td><dfn data-idl><code>maxFramerate</code></dfn></td>
            <td><code>double</code></td>
            <td>Sender</td>
          </tr>
          <tr id="def-active*">
            <td><dfn data-idl><code>active</code></dfn></td>
            <td><code>boolean</code></td>
            <td>Receiver/Sender</td>
          </tr>
          <tr id="def-rid*">
            <td><dfn data-idl><code>rid</code></dfn></td>
            <td><code>DOMString</code></td>
            <td>Receiver/Sender</td>
          </tr>
          <tr id="def-encodingid*">
            <td><dfn data-idl><code>encodingId</code></dfn></td>
            <td><code>DOMString</code></td>
            <td>Receiver/Sender</td>
          </tr>
          <tr id="def-dependencyencodingids*">
            <td><dfn data-idl><code>dependencyEncodingIds</code></dfn></td>
            <td><code>sequence&lt;DOMString&gt;</code></td>
            <td>Receiver/Sender</td>
          </tr>
        </tbody>
      </table>
      </section>
      </section>
      <section id="rtcrtpencodingparameters-example*">
        <h3>Examples</h3>
        <section class="informative" id="rtcrtpencodingparameters-basicexample*">
          <h4>Basic Example</h4>
          <pre class="example highlight">
          // Send a thumbnail along with regular size, prioritizing the thumbnail (ssrc: 2)
var encodings = [{ ssrc: 1, priority: 1.0 }];
var encodings = [{ ssrc: 2, priority: 10.0 }];

// Sign Language (prefer  framerate)
var encodings = [{ degradationPreference: "maintain-framerate" }];

// Screencast (prefer resolution)
var encodings = [{ degradationPreference: "maintain-resolution" }];

// Remote Desktop (High framerate, must not downscale)
var encodings = [{ degradationPreference: "maintain-framerate" }];

// Audio more important than video
var audioEncodings = [{ priority: 10.0 }];
var videoEncodings = [{ priority: 0.1 }];

// Video more important than audio
var audioEncodings = [{ priority: 0.1 }];
var videoEncodings = [{ priority: 10.0 }];

// Crank up the quality
var encodings = [{ maxBitrate: 10000000 }];

// Keep the bandwidth low
var encodings = [{ maxBitrate: 100000 }];
                    </pre>
        </section>
        <section class="informative" id="rtcrtpencodingtemporal-example*">
          <h4>Temporal Scalability</h4>
          <pre class="example highlight">
// Example of 3-layer temporal scalability encoding with base framerate
// one quarter of the input, and ehancement layers providing one half
// and all of the input framerate
var encodings = [
  {encodingId: 'T0', framerateScale: 4.0},
  {encodingId: 'T1', framerateScale: 2.0, dependencyEncodingIds: ['T0']},
  {encodingId: 'T2', dependencyEncodingIds: ['T0', 'T1']} 
];

// Example of 3-layer temporal scalability with all but the base layer disabled
var encodings = [
  {encodingId: 'T0', framerateScale: 4.0, active: true}, 
  {encodingId: 'T1', framerateScale: 2.0, dependencyEncodingIds: ['T0'], active: false},
  {encodingId: 'T2', dependencyEncodingIds: ['T0', 'T1'], active: false}
];
</pre>
          <p>Below is a representation of a 3-layer temporal scalability encoding. In the
          diagram, I0 is the base layer I-frame, and P0 represents base-layer P-frames.
          P1 represents the first temporal enhancement layer, and P2 represents the
          second temporal enhancement layer.</p>
          <figure>
            <img alt="3-layer temporal scalability encoding" src=
            "images/3-layer-temporal.svg" style="width:75%">
            <figcaption>
              3-layer temporal scalability encoding
            </figcaption>
          </figure>
        </section>
        <section class="informative" id="rtcrtpencodingspatialsim-example*">
          <h4>Spatial Simulcast</h4>
          <pre class="example highlight">
// Example of 3-layer spatial simulcast with all but the lowest resolution layer disabled
var encodings = [
  {rid: 'f', active: false},
  {rid: 'h', active: false, resolutionScale: 2.0},
  {rid: 'q', active: true, resolutionScale: 4.0}
];

// Example of 3-layer framerate simulcast with the middle layer disabled
var encodings = [
  {rid: 'f', active: true, maxFramerate: 60},
  {rid: 'h', active: false, maxFramerate: 30},
  {rid: 'q', active: true, maxFramerate: 15}
];

// Example of 2-layer spatial simulcast combined with 2-layer temporal scalability
// Low resolution base layer has half the input framerate, half the input resolution
// High resolution base layer has half the input framerate, full resolution
// Temporal enhancement layers have full input framerate
var encodings = [
  {rid: 'H', encodingId: 'H0', resolutionScale: 2.0, framerateScale: 2.0},
  {rid: 'F', encodingId: 'F0', framerateScale: 2.0}, 
  {rid: 'H', encodingId: 'H1', resolutionScale: 2.0, dependencyEncodingIds: ['H0']},
  {rid: 'F', encodingId: 'F1', dependencyEncodingIds: ['F0']}
];
                    </pre>
          <p>Below is a representation of 2-layer temporal scalability combined with
          2-layer spatial simulcast. Solid arrows represent temporal prediction. In the
          diagram, I0 is the base-layer I-frame, and P0 represents base-layer P-frames.
          EI0 is an enhanced resolution base-layer I-frame, and EP0 represents P-frames
          within the enhanced resolution base layer. P1 represents the first temporal
          enhancement layer, and EP1 represents a temporal enhancement to the enhanced
          resolution simulcast base-layer.</p>
          <figure>
            <img alt="2-layer spatial simulcast and temporal scalability encoding" src=
            "images/2-layer-spatialsim-temporal.svg" style="width:75%">
            <figcaption>
              2-layer spatial simulcast and temporal scalability encoding
            </figcaption>
          </figure>
        </section>
        <section class="informative" id="rtcrtpencodingspatialscal-example*">
          <h4>Spatial Scalability</h4>
          <pre class="example highlight">
// Example of 3-layer spatial scalability encoding with the base layer having
// one quarter input resolution and enhancement layers yielding one half and
// full resolution
var encodings = [
  {encodingId: 'q', resolutionScale: 4.0},
  {encodingId: 'h', resolutionScale: 2.0, dependencyEncodingIds: ['q']},
  {encodingId: 'f', dependencyEncodingIds: [['q', 'h']}

// Example of 3-layer spatial scalability with all but the base layer disabled
var encodings = [
  {encodingId: 'q', resolutionScale: 4.0, active: true},
  {encodingId: 'h', resolutionScale: 2.0, active: false},
  {encodingId: 'f', active: false}
]

// Example of 2-layer spatial scalability combined with 2-layer temporal scalability
// Base layer has one half input framerate and half resolution
// Temporal enhancement layer has full input framerate, half resolution
// Spatial enhancement to the base layer has half input framerate, full resolution
// Temporal enhancement to the spatial enhancement layer has full framerate and resolution
var encodings = [
  {encodingId: 'H0', resolutionScale: 2.0, framerateScale: 2.0}, 
  {encodingId: 'H1', resolutionScale: 2.0, dependencyEncodingIds: ['H0']},
  {encodingId: 'F0', framerateScale: 2.0, dependencyEncodingIds: ['H0']},
  {encodingId: 'F1', dependencyEnodingIds: ['F0', 'H1']}
];
                    </pre>
          <p>Below is a representation of 2-layer temporal scalability combined with
          2-layer spatial scalability. Solid arrows represent temporal prediction and
          dashed arrows represent inter-layer prediction. In the diagram, I0 is the
          base-layer I-frame, and EI0 is an intra spatial enhancement. P0 represents
          base-layer P-frames, and P1 represents the first temporal enhancement layer.
          EP0 represents a resolution enhancement to the base-layer P frames, and EP1
          represents a resolution enhancement to the second temporal layer P-frames.</p>
          <figure>
            <img alt="2-layer spatial and temporal scalability encoding" src=
            "images/2-layer-spatial-temporal.svg" style="width:75%">
            <figcaption>
              2-layer spatial and temporal scalability encoding
            </figcaption>
          </figure>
        </section>
      </section>
    <section id="rtcprioritytype*">
      <h3><dfn>RTCPriorityType</dfn> Enum</h3>
      <p><code>RTCPriorityType</code> can be used to indicate the relative
      priority of various flows. This allows applications to indicate to the browser
      whether a particular media flow is high, medium, low or of very low importance to
      the application. WebRTC uses the priority and Quality of Service (QoS) framework
      described in [[RTCWEB-TRANSPORT]] and [[!TSVWG-RTCWEB-QOS]] to provide priority and
      DSCP marketing for packets that will help provide QoS in some networking
      environments. Applications that use this API should be aware that often better
      overall user experience is obtained by lowering the priority of things that are not
      as important rather than raising the the priority of the things that are.</p>
      <div class="issue atrisk">
       <p>The priority API is marked as a feature at risk, since there is no
         clear commitment from ORTC implementers.</p>
      </div>
      <div>
        <pre class="idl">enum RTCPriorityType {
    "very-low",
    "low",
    "medium",
    "high"
};</pre>
        <table data-link-for="RTCPriorityType" data-dfn-for="RTCPriorityType" class=
        "simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCPriorityType.very-low">very-low</code></dfn></td>
              <td>
                <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCPriorityType.low">low</code></dfn></td>
              <td>
                <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCPriorityType.medium">medium</code></dfn></td>
              <td>
                <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCPriorityType.high">high</code></dfn></td>
              <td>
                <p>See [[RTCWEB-TRANSPORT]], Section 4.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtxfec*">
      <h3>RTX/FEC</h3>
    <section id="rtcrtpfecparameters*">
      <h3><dfn>RTCRtpFecParameters</dfn> Dictionary</h3>
      <p>The <code>RTCRtpFecParameters</code> dictionary contains information
      relating to Forward Error Correction (FEC) settings.</p>
      <div>
        <pre class="idl">dictionary RTCRtpFecParameters {
             unsigned long ssrc;
             required DOMString     mechanism;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpFecParameters</a> Members</h2>
          <dl data-link-for="RTCRtpFecParameters" data-dfn-for="RTCRtpFecParameters"
          class="dictionary-members">
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The SSRC to use for FEC. If unset in an <code><a>RTCRtpSender</a></code>
              object, the browser will choose.</p>
            </dd>
            <dt><dfn data-idl><code>mechanism</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The Forward Error Correction (FEC) mechanism to use: "red", "red+ulpfec"
              or "flexfec".</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtprtxparameters*">
      <h3><dfn>RTCRtpRtxParameters</dfn> Dictionary</h3>
      <p>The <code>RTCRtpRtxParameters</code> dictionary contains information
      relating to retransmission (RTX) settings.</p>
      <div>
        <pre class="idl">dictionary RTCRtpRtxParameters {
             unsigned long ssrc;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpRtxParameters</a> Members</h2>
          <dl data-link-for="RTCRtpRtxParameters" data-dfn-for="RTCRtpRtxParameters"
          class="dictionary-members">
            <dt><dfn data-idl><code>ssrc</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The SSRC to use for retransmission, as specified in [[!RFC4588]]. If
              unset when passed to <code>RTCRtpSender.send()</code>, the browser will
              choose.</p>
            </dd>
          </dl>
        </section>
      </div>
      </section>
      <section class="informative" id="rtcrtpfecparameters-example*">
        <h3>Example</h3>
        <p>Below is an example of how to configure an <code><a>RTCRtpReceiver</a></code>
        to receive video encoded in VP8 or VP9, along with retransmission and forward
        error correction. In the example, forward error correction is encapsulated in
        RED, and it is possible to retransmit RED packets. The configuration enables VP8
        or VP9 to be received either with or without RED encapsulation. The configuration
        of an <code><a>RTCRtpSender</a></code> would be more prescriptive, at a given
        time indicating a single encoding: that VP8 or VP9 video should be sent
        encapsulated within RED or without RED encapsulation.</p>
        <pre class="example highlight">// Example of RTX and RED + ulpfec
//
// SDP from createOffer() in WebRTC 1.0
//
//   m=video 62125 UDP/TLS/RTP/SAVPF 100 101 116 117 96
//   a=sendonly
//   a=rtpmap:100 VP8/90000
//   a=rtpmap:101 VP9/90000
//   a=rtpmap:116 red/90000
//   a=rtpmap:117 ulpfec/90000
//   a=rtpmap:96 rtx/90000
//   a=fmtp:96 apt=100
//   a=rtpmap:97 rtx/90000
//   a=fmtp:97 apt=101
//   a=rtpmap:98 rtx/90000
//   a=fmtp:98 apt=116
//   a=ssrc-group:FID 2224031971 3254585230
//   a=ssrc:2224031971 cname:oC/i06PA+Lda+t1P
//   a=ssrc:3254585230 cname:oC/i06PA+Lda+t1P
//
//   Define RTCRtpCodecParameters
//
var codecs = [
//   Define VP9 codec parameters
  {
    name: "vp9",
    payloadType: 101,
    clockRate: 90000
  },
//   Define VP8 codec parameters
  {
    name: "vp8",
    payloadType: 100,
    clockRate: 90000
  },
//   Define retransmission of VP9
  {
    name: "rtx",
    payloadType: 97,
    clockrate: 90000,
    parameters: {
      apt: 101
    }
  },
//   Define retransmission of VP8
  {
    name: "rtx",
    payloadType: 96,
    clockrate: 90000,
    parameters: {
      apt: 100
    }
  },
//   Define RED codec parameters
  {
    name: "red",
    payloadType: 116,
    clockRate: 90000,
    parameters: {
      payloadTypes: []
    }
  },
//   Define ulpfec codec parameters
  {
    name: "ulpfec",
    payloadType: 117,
    clockRate: 90000
  },
//   Define RTX codec parameters
  {
    name: "rtx",
    payloadType: 98,
    clockrate: 90000,
    parameters: {
      apt: 116
    }
  }
];
//
//   Define rtx parameters
var rtxParams = {
  ssrc: 3254585230
};
//   Define FEC parameters for "red+ulpfec"
var redulpfec = {
  ssrc: 3254585230,
  mechanism: "red+ulpfec"
};
//   Define RTCRtpEncodingParameters
//
var encodings = [
//   Define VP8 encoding parameters (without RED)
  {
    ssrc: 2224031971,
    codecPayloadType: 100,
    rtx: rtxParams
  },
//   Define VP8 encoding parameters with RED
  {
    ssrc:  2224031971,
    codecPayloadType: 100,
    fec: redulpfec,
    rtx: rtxParams
  },
//   Define VP9 encoding parameters (without RED)
  {
    ssrc:  2224031971,
    codecPayloadType: 101,
    rtx: rtxParams
  },
//   Define VP9 encoding parameters with RED
  {
    ssrc:  2224031971,
    codecPayloadType: 101,
    fec: redulplfec,
    rtx: rtxParams
  }
];
                    </pre>
      </section>
    </section>
  <section id="headerextensions*">
    <h3>RTP header extensions</h3>
    <section id="rtcrtpheaderextension*">
      <h3><dfn>RTCRtpHeaderExtension</dfn> Dictionary</h3>
      <p>The <code>RTCRtpHeaderExtension</code> dictionary provides
      information relating to supported header extensions.</p>
      <div>
        <pre class="idl">dictionary RTCRtpHeaderExtension {
             required DOMString      kind;
             required DOMString      uri;
             required unsigned short preferredId;
             boolean        preferredEncrypt = false;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpHeaderExtension</a> Members</h2>
          <dl data-link-for="RTCRtpHeaderExtension" data-dfn-for="RTCRtpHeaderExtension"
          class="dictionary-members">
            <dt><dfn data-idl><code>kind</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The media supported by the header extension: "audio" for an audio codec,
              "video" for a video codec, etc.</p>
            </dd>
            <dt><dfn data-idl><code>uri</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p>
            </dd>
            <dt><dfn data-idl><code>preferredId</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, required</dt>
            <dd>
              <p>The preferred ID value that goes in the packet.</p>
            </dd>
            <dt><dfn data-idl><code>preferredEncrypt</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>false</code></dt>
            <dd>
              <p>If <code>true</code>, it is preferred that the value in the header be
              encrypted as per [[!RFC6904]]. Default is to prefer unencrypted.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcrtpheaderextensionparameters*">
      <h3><dfn>RTCRtpHeaderExtensionParameters</dfn> Dictionary</h3>
      <p>The <code>RTCRtpHeaderExtensionParameters</code>
      dictionary enables a header extension to be configured for use
      within an <code><a>RTCRtpSender</a></code> or
      <code><a>RTCRtpReceiver</a></code>. In order to provide the
      equivalent of the "direction" parameter defined in
      [[!RFC5285]] Section 5, an application can do the following:</p>
      <ol>
        <li>sendonly: Include the header extension only when calling
        <code>send</code>.</li>
        <li>recvonly: Include the header extension only when calling
        <code>receive</code>.</li>
        <li>sendrecv: Include the header extension when calling
        <code>send</code> and <code>receive</code>.</li>
        <li>inactive: Don't include the header extension when calling either
        <code>send</code> or <code>receive</code>.</li>
      </ol>
      <div>
        <pre class="idl">dictionary RTCRtpHeaderExtensionParameters {
    required DOMString      uri;
    required unsigned short id;
             boolean        encrypt = false;
             Dictionary     parameters;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCRtpHeaderExtensionParameters</a>
          Members</h2>
          <dl data-link-for="RTCRtpHeaderExtensionParameters" data-dfn-for=
          "RTCRtpHeaderExtensionParameters" class="dictionary-members">
            <dt><dfn data-idl><code>uri</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, required</dt>
            <dd>
              <p>The URI of the RTP header extension, as defined in [[!RFC5285]].</p>
            </dd>
            <dt><dfn data-idl><code>id</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>, required</dt>
            <dd>
              <p>The value that goes in the packet.</p>
            </dd>
            <dt><dfn data-idl><code>encrypt</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>false</code></dt>
            <dd>
              <p>If <code>true</code>, the value in the header is encrypted as per
              [[!RFC6904]]. Default is unencrypted.</p>
            </dd>
            <dt><dfn data-idl><code>parameters</code></dfn> of type <span class=
            "idlMemberType"><a>Dictionary</a></span></dt>
            <dd>
              <p>
                Configuration parameters for the header extension.
                An example is the "vad" extension attribute in the
                client-to-mixer header extension, described in
                [[!RFC6464]] Section 4.
              </p>
              <div class="note">
                At the time of publication there were no implementations
                of the <code>parameters</code> dictionary.  Most header
                extensions do not require configuration parameters, and
                the ORTC Lib implementation assumes that the "V" bit from
                [[!RFC6464]] is always enabled so that a <code>vad</code>
                parameter is unnecessary.
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="registrations*">
      <h3>Registrations</h3>
      <p>Registered RTP header extensions are listed in [[!IANA-RTP-10]]. Header
      extensions mentioned in [[!RTP-USAGE]] and [[!RID]] include:</p>
      <table class="simple">
        <thead>
          <tr>
            <th>Header Extension</th>
            <th>Reference</th>
            <th>Attributes</th>
            <th>Notes</th>
          </tr>
        </thead>
        <tbody>
          <tr id="def-transmission-time-offset*">
            <td><dfn>Transmission Time Offset</dfn></td>
            <td>[[RFC5450]]</td>
            <td>None</td>
            <td>This extension indicates the transmission time offset.</td>
          </tr>
          <tr id="def-rapid-sync*">
            <td><dfn>Rapid Synchronization</dfn></td>
            <td>[[RFC6051]]</td>
            <td>None</td>
            <td>This extension enables carriage of an NTP-format timestamp, as defined in
            [[!RFC6051]] Section 3.3.</td>
          </tr>
          <tr id="def-client-to-mixer*">
            <td><dfn>Client-to-Mixer Audio Level</dfn></td>
            <td>[[!RFC6464]]</td>
            <td>boolean vad</td>
            <td>This extension indicates the audio level of the audio sample carried in
            an RTP packet. For an <code><a>RTCRtpSender</a></code>, the <code>vad</code>
            attribute indicates whether the V bit is in use (<code>true</code>) or not
            (<code>false</code>). For an <code><a>RTCRtpReceiver</a></code>, the
            <code>vad</code> attribute indicates whether the V bit is provided to the
            application (<code>true</code>) in
            <code>RTCRtpContributingSource.voiceActivityFlag</code> or is unset
            (<code>false</code>).</td>
          </tr>
          <tr id="def-mixer-to-client*">
            <td><dfn>Mixer-to-Client Audio Level</dfn></td>
            <td>[[RFC6465]]</td>
            <td>None</td>
            <td>This extension indicates the audio level of individual conference
            participants.</td>
          </tr>
          <tr id="def-abs-send-time*">
            <td><dfn>Absolute Send Time</dfn></td>
            <td>[[ABS-SEND-TIME]]</td>
            <td>None</td>
            <td>This extension indicates the absolute send time.</td>
          </tr>
          <tr id="def-cvo*">
            <td><dfn>CVO</dfn></td>
            <td>[[!TS26.114]] Section 7.4.5</td>
            <td>None</td>
            <td>The Coordination of Video Orientation (CVO) extension indicates whether
            the receiver needs to change the orientation in which it renders the
            stream.</td>
          </tr>
          <tr id="def-mid*">
            <td><dfn>MID</dfn></td>
            <td>[[!BUNDLE]]</td>
            <td>None</td>
            <td>This extension defines a track identifier which can be used to identify
            the track corresponding to an RTP stream.</td>
          </tr>
          <tr id="def-rid*">
            <td>RID</td>
            <td>[[!RID]]</td>
            <td>None</td>
            <td>This extension defines an identifier used to carry the <code>rid</code>.</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>
  </section>
  <section id="rtcdtmfsender*">
    <h2><dfn>RTCDtmfSender</dfn> Interface</h2>
    <section id="rtcdtmfsender-overview*">
      <h3>Overview</h3>
      <p>An <code>RTCDtmfSender</code> instance allows sending DTMF tones
      to/from the remote peer, as per [[!RFC4733]].</p>
    </section>
    <section id="rtcdtmfsender-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCDtmfSender</a></code> object is constructed from an
      <code><a>RTCRtpSender</a></code> <var>sender</var>.</p>
    </section>
    <section id="rtcdtmfsender-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">[ Constructor (RTCRtpSender sender), Exposed=Window]
interface RTCDtmfSender {
    readonly        attribute boolean      canInsertDTMF;
    readonly        attribute RTCRtpSender sender;
    readonly        attribute DOMString    toneBuffer;
    undefined insertDTMF (DOMString tones, optional unsigned long duration = 100, optional unsigned long interToneGap = 70);
                    attribute EventHandler ontonechange;
};</pre>
        <section>
          <h2>Constructors</h2>
          <p>If <code>sender.track.kind</code> is not "audio", <a>throw</a> an
          <code>InvalidParameters</code>.</p>
          <dl data-link-for="RTCDtmfSender" data-dfn-for="RTCDtmfSender" class=
          "constructors">
            <dt><code><a>RTCDtmfSender</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">sender</td>
                    <td class="prmType"><code><a>RTCRtpSender</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDtmfSender" data-dfn-for="RTCDtmfSender" class=
          "attributes">
            <dt><dfn data-idl><code>canInsertDTMF</code></dfn> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly</dt>
            <dd>
              <p>Whether the <a>RTCDtmfSender</a> is capable of sending DTMF.</p>
            </dd>
            <dt><dfn data-idl><code>sender</code></dfn> of type <span class=
            "idlAttrType"><a>RTCRtpSender</a></span>, readonly</dt>
            <dd>
              <p>The <code><a>RTCRtpSender</a></code> instance</p>
            </dd>
            <dt><dfn data-idl><code>toneBuffer</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The <code>toneBuffer</code> attribute returns a list of the tones
              remaining to be played out. For the syntax, content, and interpretation
              of this list, see <code><a>insertDTMF</a></code>.</p>
            </dd>
            <dt><dfn data-idl><code>ontonechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The <code>ontonechange</code> event handler uses the
              <a>RTCDTMFToneChangeEvent</a> interface to return the character for each
              tone as it is played out. The event type of the <code>ontonechange</code>
              event handler is <code><a>tonechange</a></code>.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDtmfSender" data-dfn-for="RTCDtmfSender" class="methods">
            <dt><dfn><code>insertDTMF</code></dfn></dt>
            <dd>
              <p>The <code>insertDTMF()</code> method is used to send DTMF tones.
              The tones parameter is treated as a series of characters. The
              characters 0 through 9, A through D, #, and * generate the
              associated DTMF tones. The characters a to d MUST be normalized
              to uppercase on entry and are equivalent to A to D.
              As noted in [[!RFC7874]] Section 3, support for the characters
              0 through 9, A through D, #, and * are required.
              The character ',' MUST be supported, and indicates a delay
              of 2 seconds before processing the next character in the tones
              parameter. All other characters (and only those other characters)
              MUST be considered <dfn id="dtmf-unrecognized">unrecognized</dfn>.</p>
              <p>The duration parameter indicates the duration in ms to use for
              each character passed in the tones parameters. The duration
              cannot be more than 6000 ms or less than 40 ms. The default
              duration is 100 ms for each tone.</p>
              <p>The interToneGap parameter indicates the gap between tones in
              ms. The <a>user agent</a> clamps it to at least 30 ms and at most
              6000 ms. The default value is 70 ms.</p>
              <p>Implementations <em title="MAY" class="rfc2119">MAY</em>
              increase the duration and interToneGap times
              to cause the times that DTMF start and stop to align with the
              boundaries of RTP packets but it <em title="MUST" class=
              "rfc2119">MUST</em> not increase either of them
              by more than the duration of a single RTP audio packet.</p>
              <p>When the <code><a><code>insertDTMF()</code></a></code> method
              is invoked, the <a>user agent</a> <em title="MUST" class="rfc2119">MUST</em> run
              the following steps:</p>
              <ol>
                <li>let <var>sender</var> be the <code><a>RTCRtpSender</a></code>
                used to send DTMF.
                </li>
                <li>If <var>sender</var>'s <a>[[\SenderStopped]]</a> slot is <code>true</code>,
                <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
                <li>If <code><var>sender</var>.send</code> has not been called, 
                <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
                <li>
                Let <var>parameters</var> be the argument provided to
                <code><var>sender</var>.send</code> the last time it
                was called.
                </li>
                <li>If <code><var>parameters</var>.codecs[<var>j</var>]</code> is
                not equal to "telephone-event" for any value of <var>j</var>,
                <a>throw</a> an <code>InvalidStateError</code> and abort
                these steps.
                </li>            
                <li>Let <var>tones</var> be the method's first argument.</li>
                <li>If <var>tones</var> contains any <a>unrecognized</a>
                characters, <a>throw</a> an <code>InvalidCharacterError</code>
                and abort these steps.
                </li>
                <li>Set the object's <code><a>toneBuffer</a></code> attribute to
                <var>tones</var>.</li>
                <li>If the value of the <code><a>duration</a></code> parameter
                is less than 40, set it to 40. If, on the other hand, the
                value is greater than 6000, set it to 6000.</li>
                <li>If the value of the <code><a>interToneGap</a></code> parameter
                is less than 30, set it to 30. If, on the other hand, the
                value is greater than 6000, set it to 6000.</li>
                <li>If <code><a>toneBuffer</a></code> is an empty string,
                abort these steps.</li>
                <li>If a <em>Playout task</em> is scheduled to be run, abort
                these steps; otherwise queue a task that runs the following
                steps (<em>Playout task</em>):
                  <ol>
                    <li>If <var>sender</var>'s <a>[[\SenderStopped]]</a> slot is
                    <code>true</code>, abort these steps.</li>
                    <li>If <code><a>toneBuffer</a></code> is an empty string,
                    fire an event named <code><a>tonechange</a></code> with an
                    empty string at the <code><a>RTCDtmfSender</a></code>
                    object and abort these steps.</li>
                    <li>Remove the first character from
                    <code><a>toneBuffer</a></code> and let that character
                    be <var>tone</var>.</li>
                    <li>If <var>tone</var> is "," delay sending tones for
                    2000 ms on the associated RTP media stream, and queue
                    a task to be executed in 2000 ms from now that
                    runs the steps labelled <em>Playout task</em>.</li>
                    <li>If <var>tone</var> is not "," start playout of
                    <var>tone</var> for <code><a>duration</a></code> ms
                    on the associated RTP media stream, using the
                    appropriate codec, then queue a task to be executed in
                    <code><a>duration</a></code> +
                    <code><a>interToneGap</a></code> ms from now that
                    runs the steps labelled <em>Playout task</em>.</li>
                    <li>Fire an event named <code><a>tonechange</a></code> with
                    a string consisting of <var>tone</var> at the
                    <code><a>RTCDtmfSender</a></code> object.</li>
                  </ol>
                </li>
              </ol>
              <p>Since <code>insertDTMF</code> replaces the tone
              buffer, in order to add to the DTMF tones being played,
              it is necessary to call <code>insertDTMF</code> with a
              string containing both the remaining tones (stored in
              <code>toneBuffer</code>) and the new tones appended
              together.</p>        
              <p>Calling <code><a>insertDTMF</a></code> with an empty tones
              parameter can be used to cancel all tones queued to play after
              the currently playing tone.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">tones</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">duration</td>
                    <td class="prmType"><code>unsigned long = 100</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">interToneGap</td>
                    <td class="prmType"><code>unsigned long = 70</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3><dfn>RTCDTMFToneChangeEvent</dfn></h3>
      <p>The <code><a>tonechange</a></code> event uses the <code>RTCDTMFToneChangeEvent</code>
      interface.</p>
      <p>Firing a <code><a>tonechange</a></code> event named <var>e</var> with a
      DOMString <var>tone</var> means that an event with the name <var>e</var>,
      which does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the <a>RTCDTMFToneChangeEvent</a>
      interface with the <code>tone</code> attribute set to <var>tone</var>,
      MUST be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCDTMFToneChangeEventInit eventInitDict), Exposed=Window]
interface RTCDTMFToneChangeEvent : Event {
    readonly        attribute DOMString tone;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
          "RTCDTMFToneChangeEvent" class="constructors">
            <dt><code>RTCDTMFToneChangeEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType">
                    <code><a>RTCDTMFToneChangeEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDTMFToneChangeEvent" data-dfn-for=
          "RTCDTMFToneChangeEvent" class="attributes">
            <dt><dfn data-idl><code>tone</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly</dt>
            <dd>
              <p>The <code>tone</code> attribute contains the character for the tone
              (including ",") that has just begun playout (see <code><a>insertDTMF</a></code> ).
              If the value is the empty string, it indicates that the <code><a>toneBuffer</a></code>
              is an empty string and that the previous tones have completed playback.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
      <p>The <dfn><code>RTCDTMFToneChangeEventInit</code></dfn> dictionary provides
      information on the DTMF <dfn><code>tone</code></dfn> causing a tonechange event.</p>
        <pre class="idl">dictionary RTCDTMFToneChangeEventInit : EventInit {
             required DOMString tone;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDTMFToneChangeEventInit</a> Members</h2>
          <dl data-link-for="RTCDTMFToneChangeEventInit" data-dfn-for=
          "RTCDTMFToneChangeEventInit" class="dictionary-members">
            <dt><dfn data-idl><code>tone</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span>, defaulting to <code>""</code></dt>
            <dd>
              <p>The <code>tone</code> attribute contains the character for the tone
              (including ",") that has just begun playout (see <code><a>insertDTMF</a></code> ).
              If the value is the empty string, it indicates that the <code><a>toneBuffer</a></code>
              is an empty string and that the previous tones have completed playback.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcdtmfsender2*">
    <h2>RTCDTMFSender Interface</h2>
    <section id="rtcdtmfsender2-overview*">
      <h3>Overview</h3>
      <p>An <code>RTCDTMFSender</code> instance allows sending DTMF tones
      to/from the remote peer in a manner identical to that of the <code><a>RTCDtmfSender</a></code> interface.</p>
    </section>
    <section id="rtcdtmfsender-operation2*">
      <h3>Operation</h3>
      <p>An <code>RTCDTMFSender</code> object is constructed from an
      <code><a>RTCRtpSender</a></code> <var>sender</var>, as with
      <code><a>RTCDtmfSender</a></code>. If
      <code>sender.track.kind</code> is not "audio", <a>throw</a> an
      <code>InvalidParameters</code>.</p>
    </section>
    <section id="rtcdtmfsender-interface-definition2*">
      <h3>Interface Definition</h3>
      <p>The <code>RTCDTMFSender</code> interface is identical to the
      <code><a>RTCDtmfSender</a></code> interface aside from spelling.</p>
    </section>
    </section>
    <section class="informative">
      <h3>Examples</h3>
      <p>Examples assume that <var>sendObject</var> is an
      <code><a>RTCRtpSender</a></code> object.</p>
      <p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>
      <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
    var duration = 500;
    sender.insertDTMF("1234", duration);
} else 
    trace("DTMF function not available");
</pre>
      <p>Send the DTMF signal "123" and abort after sending "2".</p>
      <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
  sender.ontonechange = function (e) {
      if (e.tone == "2")
          // empty the buffer to not play any tone after "2"
          sender.insertDTMF("");
  };
  sender.insertDTMF("123");
} else
    trace("DTMF function not available");
</pre>

      <p>Send the DTMF signal "1234", and light up the active key using
      <code>lightKey(key)</code> while the tone is playing (assuming that
      <code>lightKey("")</code> will darken all the keys):</p>
      <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
  var duration = 500;
  sender.ontonechange = function (e) {
      if (!e.tone)
          return;
      // light up the key when playout starts
      lightKey(e.tone);
      // turn off the light after tone duration
      setTimeout(lightKey, duration, "");
  };
  sender.insertDTMF(sender.toneBuffer + "1234");
} else
    trace("DTMF function not available");
</pre>      
      
      <p>It is always safe to append to the tone buffer. This example appends
      before any tone playout has started as well as during playout.</p>
      <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
  sender.insertDTMF("123");
  // append more tones to the tone buffer before playout has begun
  sender.insertDTMF(sender.toneBuffer + "456");

  sender.ontonechange = function (e) {
      if (e.tone == "1")
          // append more tones when playout has begun
          sender.insertDTMF(sender.toneBuffer + "789");
  };
} else
    trace("DTMF function not available");    
</pre>
      
      <p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>
      <pre class="example highlight">
var sender = new RTCDtmfSender(sendObject);
if (sender.canInsertDTMF) {
  sender.ontonechange = function (e) {
      if (e.tone == "1")
          sender.insertDTMF(sender.toneBuffer + "2", 2000);
  };
  sender.insertDTMF(sender.toneBuffer + "1", 1000);
} else
    trace("DTMF function not available");
</pre>
      
    </section>
  </section>
  <section id="rtcdatachannel*">
    <h2><dfn>RTCDataChannel</dfn> Interface</h2>
    <section id="rtcdatachannel-overview*">
      <h3>Overview</h3>
      <p>An <code>RTCDataChannel</code> object allows sending data
      messages to/from the remote peer.</p>
    </section>
    <section id="rtcdatachannel-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCDataChannel</a></code> object is constructed from a
      <code><a>RTCDataTransport</a></code> object (providing the transport for the
      data channel) and an <code><a>RTCDataChannelParameters</a></code> object.
      An <code><a>RTCDataChannel</a></code> object can be garbage-collected once
      <var>readyState</var> is <code>closed</code> and it is no longer referenced.</p>
    </section>
    <section id="rtcdatachannel-interface-definition*">
      <h3>Interface Definition</h3>
      <p>The <code><a>RTCDataChannel</a></code> interface represents a bi-directional
      data channel between two peers. Each <code><a>RTCDataChannel</a></code> has
      an associated <dfn>underlying data transport</dfn> that is used to
      transport actual data to the other peer. The transport properties of the
      underlying data transport, such as in order delivery settings and
      reliability mode, are configured by the peer as the channel is created.
      The properties of a channel cannot change after the channel has been created.</p>
      <p>An <code><a>RTCDataChannel</a></code> can be configured to operate in
      different reliability modes.  A reliable channel ensures that the data is
      delivered at the other peer through retransmissions.  An unreliable channel
      is configured to either limit the number of retransmissions
      (<code>maxRetransmits</code>) or set a time during which transmissions
      (including retransmissions) are allowed (<code>maxPacketLifeTime</code>).
      These properties can not be used simultaneously and an attempt to do so
      will result in an error.  Not setting any of these properties results in
      a reliable channel.</p>
      <p>There are two ways to establish a connection with
      <code><a>RTCDataChannel</a></code>. The first way is to construct an
      <code><a>RTCDataChannel</a></code> at one of the peers with the
      <code><a>RTCDataChannelParameters</a>.negotiated</code> attribute unset
      or set to its default value <code>false</code>. This will announce the
      new channel in-band and trigger an <code>ondatachannel</code> event
      with the corresponding <code><a>RTCDataChannel</a></code> object at
      the other peer.</p>
      <p>The second way is to let the application negotiate the
      <code><a>RTCDataChannel</a></code>. To do this, create an
      <code><a>RTCDataChannel</a></code> object with the
      <code><a>RTCDataChannelParameters</a></code> <code>negotiated</code> dictionary member
      set to <code>true</code>, and signal out-of-band (e.g. via a web server)
      to the other side that it should create a corresponding
      <code><a>RTCDataChannel</a></code> with the
      <code><a>RTCDataChannelParameters</a></code> <code>negotiated</code> member
      set to <code>true</code> and the same <var>id</var>. This will connect
      the two separately created <code><a>RTCDataChannel</a></code> objects.
      The second way makes it possible to create channels with asymmetric
      properties and to create channels in a declarative way by specifying
      matching <var>id</var>s.</p>
      <div>
        <pre class="idl">
        [ Constructor (RTCDataTransport transport, RTCDataChannelParameters parameters), Exposed=Window]
interface RTCDataChannel : EventTarget {
    readonly        attribute RTCDataTransport    transport;
    readonly        attribute RTCDataChannelState readyState;
    readonly        attribute unsigned long       bufferedAmount;
                    attribute unsigned long       bufferedAmountLowThreshold;
                    attribute DOMString           binaryType;
    RTCDataChannelParameters getParameters ();
    undefined                close ();
                    attribute EventHandler        onopen;
                    attribute EventHandler        onbufferedamountlow;
                    attribute EventHandler        onerror;
                    attribute EventHandler        onclose;
                    attribute EventHandler        onmessage;
    undefined                send (USVString data);
    undefined                send (Blob data);
    undefined                send (ArrayBuffer data);
    undefined                send (ArrayBufferView data);
};</pre>
    <section>
      <h2>Constructors</h2>
      <p>When the constructor is invoked, the following steps MUST be run:</p>
      <ol>
        <li>Let <var>transport</var> be the first argument.</li>
        <li><p>If <var>transport</var>'s <code>state</code> attribute
        is <code>closed</code>, <a>throw</a> an
        <code>InvalidStateError</code>.</p></li>
        <li>Let <var>parameters</var> be the second argument.</li>
        <li><p>Let <var>channel</var> be a newly created
        <code><a>RTCDataChannel</a></code> object.</p></li>
        <li><p>Let <var>channel</var> have a <dfn>[[\DataChannelLabel]]</dfn>
        internal slot initialized to <var>parameters</var>'
        <code>label</code> member.</p></li>
        <li>If <a>[[\DataChannelLabel]]</a> is longer than 65535 bytes,
        <a>throw</a> a <code>TypeError</code>.</li>
        <li><p>Let <var>channel</var> have a <dfn>[[\MaxPacketLifeTime]]</dfn>
        internal slot initialized to <var>parameters</var>'
        <code>maxPacketLifeTime</code> member, if present, otherwise
        <code>null</code>.</p></li>
        <li><p>Let <var>channel</var> have a <dfn>[[\ReadyState]]</dfn>
        internal slot initialized to <code>connecting</code>.</p></li>
        <li><p>Let <var>channel</var> have a <dfn>[[\MaxRetransmits]]</dfn>
        internal slot initialized to <var>parameters</var>' <code>maxRetransmits</code>
        member, if present, otherwise <code>null</code>.</p></li>
        <li><p>Let <var>channel</var> have an <dfn>[[\Ordered]]</dfn> internal
        slot initialized to <var>parameters</var>' <code>ordered</code> member.</p></li>
        <li><p>Let <var>channel</var> have a <dfn>[[\DataChannelProtocol]]</dfn>
        internal slot initialized to <var>parameters</var>' <code>protocol</code>
        member.</p></li>
        <li><p>If <a>[[\DataChannelProtocol]]</a> is longer than 65535 bytes long,
        <a>throw</a> a <code>TypeError</code>.</p></li>
        <li><p>Let <var>channel</var> have a <dfn>[[\Negotiated]]</dfn> internal slot
        initialized to <var>parameters</var>' <code>negotiated</code> member.</p></li>
        <li><p>Let <var>channel</var> have an <dfn>[[\DataChannelId]]</dfn>
        internal slot initialized to <var>parameters</var>'
        <code>id</code> member, if it is present, otherwise <code>null</code>.</p>
        <div class="note">
           Application developers providing an <code>id</code> member
           and negotiating in-band should have
           IDs selected based on the DTLS role, as specified in
           [[!DATA-PROT]].
        </div></li>
        <li><p>If <a>[[\Negotiated]]</a> is <code>true</code> and
        <a>[[\DataChannelId]]</a> is <code>null</code>, <a>throw</a>
        a <code>TypeError</code>.</p></li>
        <li><p>If <var>channel</var>'s <a>[[\DataChannelId]]</a> slot is equal to 65535,
        which is greater than the maximum allowed ID of 65534 but still qualifies
        as an <span class="idlMemberType"><a>unsigned short</a></span>,
        <a>throw</a> a <code>TypeError</code>.</p></li>
        <li><p>Let <var>channel</var> have an
        <dfn>[[\DataChannelPriority]]</dfn> internal slot initialized
        to <var>parameters</var>' <code>priority</code> member.</p></li>
        <li><p>If both <var>channel</var>'s <a>[[\MaxPacketLifeTime]]</a> and
        <a>[[\MaxRetransmits]]</a> internal slots are set (not null),
        <a>throw</a> a <code>TypeError</code>.</p></li>
        <li><p>If a setting, either <a>[[\MaxPacketLifeTime]]</a> or
        <a>[[\MaxRetransmits]]</a> has been set to indicate unreliable
        mode, and that value exceeds the maximum value supported by the
        user agent, the value MUST be set to the user agents maximum
        value.</p></li>
        <li><p>If <var>channel</var>'s <a>[[\DataChannelId]]</a> slot is <code>null</code>
        and the DTLS role of the SCTP transport has already been
        negotiated, then initialize <var>channel</var>'s <a>[[\DataChannelId]]</a>
        internal slot to a value generated by the user agent, according to
        [[!DATA-PROT]], and skip to the next step. If no
        available ID could be generated, or if the value of <var>channel</var>'s
        <a>[[\DataChannelId]]</a> slot is being used by an existing
        <code><a>RTCDataChannel</a></code>, <a>throw</a> an
        <code>OperationError</code> exception.</p>
        <div class="note">
           If the <var>channel</var>'s <a>[[\DataChannelId]]</a>
           internal slot is <code>null</code> after this step, it will be
           populated once the DTLS role is determined.
        </div></li>
        <li>
          <p>Create <var>channel</var>'s associated <a>underlying data
          transport</a> and configure it according to the relevant
          properties of <var>channel</var>.</p>
        </li>
       </ol>
          <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel" class=
          "constructors">
            <dt><code><a>RTCDataChannel</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCDataTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">parameters</td>
                    <td class="prmType"><code><a>RTCDataChannelParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel" class=
          "attributes">
            <dt><dfn data-idl><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDataTransport</a></span>, readonly</dt>
            <dd>
              <p>The readonly attribute referring to the related transport object.</p>
            </dd>
            <dt><dfn data-idl><code>readyState</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDataChannelState</a></span>, readonly</dt>
            <dd>
              <p>The <code>readyState</code>
              attribute represents the state of the <code><a>RTCDataChannel</a></code> object.
              On getting, it MUST return the value of the <code><a>RTCDataChannel</a></code>
              object's <a>[[\ReadyState]]</a> internal slot.</p>
            </dd>
            <dt><dfn data-idl><code>bufferedAmount</code></dfn> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <code>bufferedAmount</code>
              attribute <em class="rfc2119" title="MUST">MUST</em> return the number of
              bytes of application data (UTF-8 text and binary data) that have been
              queued using send() but that, as of the last time the event loop started
              executing a task, had not yet been transmitted to the network. This
              includes any text sent during the execution of the current task, regardless
              of whether the <a>user agent</a> is able to transmit text asynchronously with
              script execution. This does not include framing overhead incurred by the
              protocol, or buffering done by the operating system or network hardware. If
              the channel is closed, this attribute's value will only increase with each
              call to the send() method (the attribute does not reset to zero once the
              channel closes).</p>
            </dd>
            <dt><dfn data-idl><code>bufferedAmountLowThreshold</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The <code>bufferedAmountLowThreshold</code>
              attribute sets the threshold at which the <code><a href=
              "#dom-datachannel-bufferedamount">bufferedAmount</a></code> is considered
              to be low. When the <code><a href=
              "#dom-datachannel-bufferedamount">bufferedAmount</a></code> decreases from
              above this threshold to equal or below it, the <code title=
              "event-RTCDataChannel-bufferedamountlow"><a href=
              "#event-datachannel-bufferedamountlow">bufferedamountlow</a></code> event
              fires. The <code><a href=
              "#dom-datachannel-bufferedamountlowthreshold">bufferedAmountLowThreshold</a></code>
              is initially zero on each new <code><a>RTCDataChannel</a></code>, but the
              application may change its value at any time.</p>
            </dd>
            <dt><code>binaryType</code> of type <span class=
            "idlAttrType"><a>DOMString</a></span></dt>
            <dd>
              <p>The <dfn id="dom-datachannel-binarytype"><code>binaryType</code></dfn>
              attribute <em class="rfc2119" title="MUST">MUST</em>, on getting, return
              the value to which it was last set. On setting, the <a>user agent</a> <em class=
              "rfc2119" title="MUST">MUST</em> set the IDL attribute to the new value.
              When an <a>RTCDataChannel</a> object is constructed, the
              <code>binaryType</code> attribute <em class="rfc2119" title=
              "MUST">MUST</em> be initialized to the string 'blob'. This attribute
              controls how binary data is exposed to scripts. See the [[WEBSOCKETS-API]]
              for more information.</p>
            </dd>
            <dt><dfn data-idl><code>onopen</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler type <code>open</code>, <em class=
              "rfc2119" title="MUST">MUST</em> be supported by all objects implementing
              the <code><a>RTCDataChannel</a></code> interface.</p>
            </dd>
            <dt><dfn data-idl><code>onbufferedamountlow</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The event type of this event handler is <code><a href=
              "#event-datachannel-bufferedamountlow">bufferedamountlow</a></code>.</p>
            </dd>
            <dt><dfn data-idl><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler type <code>error</code>, <em class=
              "rfc2119" title="MUST">MUST</em> be supported by all objects implementing
              the <code><a>RTCDataChannel</a></code> interface. One reason an <code>error</code>
              event can be fired is if the value of <var>parameters</var> passed in the constructor
              is subsequently determined to be invalid. This can happen if the <code><a>RTCDataChannel</a></code>
              <a>[[\Negotiated]]</a> internal slot is set to <code>false</code> and then a call
              to <code>RTCDtlsTransport.start()</code> causes the DTLS role to be set to a
              value inconsistent with the value of the <code><a>RTCDataChannel</a></code>
              <a>[[\DataChannelId]]</a> internal slot, as noted in [[!DATA-PROT]] Section 4.</p>
            </dd>
            <dt><dfn data-idl><code>onclose</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler type <code>close</code>, <em class=
              "rfc2119" title="MUST">MUST</em> be supported by all objects implementing
              the RTCDataChannel interface.</p>
            </dd>
            <dt><dfn data-idl><code>onmessage</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type <code>message</code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired to allow a developer's
              JavaScript to receive data from a remote peer.</p>
              <table border="1">
                <tbody>
                  <tr>
                    <td><em>Event Argument</em></td>
                    <td><em>Description</em></td>
                  </tr>
                  <tr>
                    <td>Object data</td>
                    <td>The received remote data.</td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCDataChannel" data-dfn-for="RTCDataChannel" class=
          "methods">
            <dt><dfn data-idl><code>getParameters</code></dfn></dt>
            <dd>
              <p>Returns the <code><a>RTCDataChannelParameters</a></code> applying to this
              data channel. When the <code>getParameters</code> method is called, the user
              agent <em class="rfc2119" title="MUST">MUST</em> run the following
              steps:</p>
              <ol>
                 <li>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code> object
                 for which parameters are to be returned.</li>
                 <li>Let <var>parameters</var> be a new
                 <code><a>RTCDataChannelParameters</a></code> dictionary.</li>
                 <li>Set <var>parameters</var>'s <code>label</code> member to the value of
                 <var>channel</var>'s <a>[[\DataChannelLabel]]</a> internal slot, which <em class="rfc2119"
                 title="MUST">MUST</em> have the value to which it was set when
                 <var>channel</var> was constructed.</li>
                 <li>Set <var>parameters</var>'s <code>ordered</code> member to the value of
                 <var>channel</var>'s <a>[[\Ordered]]</a> internal slot, which <em class="rfc2119"
                 title="MUST">MUST</em> have the value to which it was set when
                 <var>channel</var> was constructed.</li>
                 <li>Set <var>parameters</var>'s <code>maxPacketLifetime</code> member to the value of
                 <var>channel</var>'s <a>[[\MaxPacketLifetime]]</a> internal slot, which <em class="rfc2119"
                 title="MUST">MUST</em> have the value to which it was set when
                 <var>channel</var> was constructed.</li>
                 <li>Set <var>parameters</var>'s <code>maxRetransmits</code> member to the value of
                 <var>channel</var>'s <a>[[\MaxRetransmits]]</a> internal slot, which <em class="rfc2119"
                 title="MUST">MUST</em> have the value to which it was set when
                 <var>channel</var> was constructed.</li>
                 <li>Set <var>parameters</var>'s <code>protocol</code> member to the value of
                 <var>channel</var>'s <a>[[\DataChannelProtocol]]</a> internal slot, which <em class="rfc2119"
                 title="MUST">MUST</em> have the value to which it was set when
                 <var>channel</var> was constructed.</li>
                 <li>Set <var>parameters</var>'s <code>negotiated</code> member to the value of
                 <var>channel</var>'s <a>[[\Negotiated]]</a> internal slot, which <em class="rfc2119"
                 title="MUST">MUST</em> have the value to which it was set when
                 <var>channel</var> was constructed.</li>
                 <li>Set <var>parameters</var>'s <code>id</code> member to the value of
                 <var>channel</var>'s <a>[[\DataChannelId]]</a> internal slot.</li>
                 <li>Set <var>parameters</var>'s <code>label</code> member to the value of
                 <var>channel</var>'s <a>[[\DataChannelLabel]]</a> internal slot, which <em class="rfc2119"
                 title="MUST">MUST</em> have the value to which it was set when
                 <var>channel</var> was constructed.</li>
                 <li>Set <var>parameters</var>'s <code>priority</code> member to the value of
                 <var>channel</var>'s <a>[[\DataChannelPriority]]</a> internal slot,
                 which <em class="rfc2199" title="MUST">MUST</em> have the value to
                 which it was set when <var>channel</var> was constructed.</li>
                 <li>Return <var>parameters</var>.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCDataChannelParameters</a></code>
              </div>
            </dd>
            <dt><dfn data-idl><code>close</code></dfn></dt>
            <dd>
              <p>Closes the <a>RTCDataChannel</a>. It may be called regardless of whether
              the <code><a>RTCDataChannel</a></code> object was created by this peer or
              the remote peer. When the <code>close</code> method is called, the user
              agent <em class="rfc2119" title="MUST">MUST</em> run the following
              steps:</p>
              <p>1. Let <var>channel</var> be the <code><a>RTCDataChannel</a></code> object which is about to be
              closed.</p>
              <p>2. If <var>channel</var>'s <a>[[\ReadyState]]</a> slot is <code>closing</code>
              or <code>closed</code>, then abort these steps.</p>
              <p>3. Set <var>channel</var>'s <a>[[\ReadyState]]</a> slot to <code>closing</code>.</p>
              <p>4. If the closing procedure has not started yet, start it.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code>send()</code> algorithm with
              argument type <code>string</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>USVString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-1" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code>send()</code> algorithm with
              argument type <code>Blob</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Blob</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-2" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code>send()</code> algorithm with
              argument type <code>ArrayBuffer</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>ArrayBuffer</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-lt="send!overload-3" data-lt-nodefault=
            "true"><code>send</code></dfn></dt>
            <dd>
              <p>Run the steps described by the <code>send()</code> algorithm with
              argument type <code>ArrayBufferView</code> object.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>ArrayBufferView</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <p>The <code>send()</code> method is overloaded to handle different data argument
      types. When any version of the method is called, the <a>user agent</a> MUST run the
      following steps:</p>
      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a>RTCDataChannel</a></code>
          on which data is to be sent.</p>
        </li>
        <li>
          <p>If <var>channel</var>'s <a>[[\ReadyState]]</a> internal slot is not
          <code>open</code>, <a>throw</a> an <code>InvalidStateError</code>.</p>
        </li>
        <li>
          <p>Execute the sub step that corresponds to the type of the methods
          argument:</p>
          <ul>
            <li>
              <p><code>string</code> object:</p>
              <p>Let <var>data</var> be the object and increase the
              <code><a data-link-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the number of bytes needed to express
              <var>data</var> as UTF-8.</p>
            </li>
            <li>
              <p><code>Blob</code> object:</p>
              <p>Let <var>data</var> be the raw data represented by the
              <code>Blob</code> object and increase the <code><a data-link-for=
              "RTCDataChannel">bufferedAmount</a></code> attribute by the size
              of data, in bytes.</p>
            </li>
            <li>
              <p><code>ArrayBuffer</code> object:</p>
              <p>Let <var>data</var> be the data stored in the buffer described
              by the <code>ArrayBuffer</code> object and increase the
              <code><a data-link-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBuffer</code> in
              bytes.</p>
            </li>
            <li>
              <p><code>ArrayBufferView</code> object:</p>
              <p>Let <var>data</var> be the data stored in the section of the
              buffer described by the <code>ArrayBuffer</code> object that the
              <code>ArrayBufferView</code> object references and increase the
              <code><a data-link-for="RTCDataChannel">bufferedAmount</a></code>
              attribute by the length of the <code>ArrayBufferView</code> in
              bytes.</p>
            </li>
          </ul>
        </li>
        <li>
          <p>If the size of <var>data</var> exceeds the value of
          the <a>[[\MaxMessageSize]]</a> slot of
          <var>channel</var>'s associated <code><a>RTCSctpTransport</a></code>,
          <a>throw</a> a <code>TypeError</code>.</p>
        </li>
        <li>
          <p>Queue <var>data</var> for transmission on <var>channel</var>'s
          <a>underlying data transport</a>. If queuing <var>data</var> is not
          possible because not enough buffer space is available, <a>throw</a>
          an <code>OperationError</code>.</p>
          <div class="note">The actual transmission of data occurs in
          parallel. If sending data leads to an SCTP-level error, the
          application will be notified asynchronously through <code><a
          data-link-for="RTCDataChannel">onerror</a></code>.</div>
        </li>
      </ol>
    </section>
    <section id="rtcdatatransport-interface-definition*">
      <h3><dfn>RTCDataTransport</dfn> Interface</h3>
      <div>
        <pre class="idl">interface RTCDataTransport : RTCStatsProvider {
};</pre>
      </div>
    </section>
    <section id="rtcdatachannelstate*">
      <h3><dfn>RTCDataChannelState</dfn> Enum</h3>
      <p>The <code>RTCDataChannelState</code> provides information
      on the state of the data channel.</p>
      <div>
        <pre class="idl">enum RTCDataChannelState {
    "connecting",
    "open",
    "closing",
    "closed"
};</pre>
        <table data-link-for="RTCDataChannelState" data-dfn-for="RTCDataChannelState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCDataChannelState.connecting">connecting</code></dfn></td>
              <td>
                <p>The <a>user agent</a> is attempting to establish the underlying data
                transport. This is the initial state of an
                <code><a>RTCDataChannel</a></code> object dispatched
                as part of an <code>RTCDataChannelEvent</code>.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id="idl-def-RTCDataChannelState.open">open</code></dfn></td>
              <td>
                <p>The underlying data transport is established and communication is
                possible.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCDataChannelState.closing">closing</code></dfn></td>
              <td>
                <p>The procedure to close down the underlying data transport has
                started.</p>
              </td>
            </tr>
            <tr>
              <td><dfn data-idl><code id=
              "idl-def-RTCDataChannelState.closed">closed</code></dfn></td>
              <td>
                <p>The underlying data transport has been closed or could not be
                established.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcdatachannelparameters*">
      <h3><dfn>RTCDataChannelParameters</dfn> Dictionary</h3>
      <p>The <code>RTCDataChannelParameters</code> dictionary describes
      the configuration of the <code><a>RTCDataChannel</a></code>.
      An <code><a>RTCDataChannel</a></code> can be configured to operate in different
      reliability modes. A reliable channel ensures that the data is delivered at the
      other peer through retransmissions. An unreliable channel is configured to either
      limit the number of retransmissions (<code>maxRetransmits</code>) or set a time during which
      transmissions (including retransmissions) are allowed (<code>maxPacketLifeTime</code>). These
      properties can not be used simultaneously and an attempt to do so will result in an
      error. Not setting any of these properties results in a reliable channel.</p>
      <div>
        <pre class="idl">dictionary RTCDataChannelParameters {
             USVString      label = "";
             boolean        ordered = true;
             unsigned long  maxPacketLifetime;
             unsigned long  maxRetransmits;
             USVString      protocol = "";
             boolean        negotiated = false;
             [EnforceRange]
             unsigned short id;
             RTCPriorityType priority = "low";
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCDataChannelParameters</a> Members</h2>
          <dl data-link-for="RTCDataChannelParameters" data-dfn-for=
          "RTCDataChannelParameters" class="dictionary-members">
            <dt><dfn data-idl><code>label</code></dfn> of type <span class=
            "idlMemberType"><a>USVString</a></span>, defaulting to <code>""</code></dt>
            <dd>
              <p>The <code>label</code> attribute represents a label that can
              be used to distinguish this <code><a>RTCDataChannel</a></code> object from
              other <a>RTCDataChannel</a> objects. For an SCTP data
              channel, the label is carried in the DATA_CHANNEL_OPEN message defined in
              [[!DATA-PROT]] Section 5.1.</p>
            </dd>
            <dt><dfn data-idl><code>ordered</code></dfn> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>true</code></dt>
            <dd>
              <p>The <code>ordered</code>
              attribute is set to <code>true</code> if the
              <code><a>RTCDataChannel</a></code> is ordered, and <code>false</code> if
              out of order delivery is allowed. Default is <code>true</code>.</p>
            </dd>
            <dt><code>maxPacketLifetime</code> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-maxpacketlifetime"><code>maxPacketLifetime</code></dfn>
              attribute represents the length of the time window (in milliseconds) during
              which retransmissions may occur in unreliable mode.</p>
            </dd>
            <dt><code>maxRetransmits</code> of type <span class=
            "idlMemberType"><a>unsigned long</a></span></dt>
            <dd>
              <p>The <dfn id=
              "dom-datachannel-maxretransmits"><code>maxRetransmits</code></dfn>
              attribute represents the maximum number of retransmissions that are attempted
              in unreliable mode. The attribute <em class="rfc2119" title=
              "MUST">MUST</em> be initialized to <code>null</code> by default.</p>
            </dd>
            <dt><dfn data-idl><code>protocol</code></dfn> of type <span class=
            "idlMemberType"><a>USVString</a></span>, defaulting to <code>""</code></dt>
            <dd>
              <p>The name of the sub-protocol used with this
              <code><a>RTCDataChannel</a></code> if any, or the empty string otherwise (in
              which case the protocol is unspecified). Sub-protocols are
              registered in the 'Websocket Subprotocol Name Registry' created in
              [[RFC6455]] Section 11.5.</p>
            </dd>
            <dt><code>negotiated</code> of type <span class=
            "idlMemberType"><a>boolean</a></span>, defaulting to <code>false</code></dt>
            <dd>
              <p>The <dfn id="dom-datachannel-negotiated"><code>negotiated</code></dfn>
              attribute is set to <code>true</code> if this <code><a>RTCDataChannel</a></code> was
              negotiated by the application, or <code>false</code> otherwise. The attribute <em class=
              "rfc2119" title="MUST">MUST</em> be initialized to <code>false</code> by
              default. If set to <code>true</code>, the application developer <em class="rfc2119"
              title="MUST">MUST</em> signal to the remote peer to construct an
              <code><a>RTCDataChannel</a></code> object with the same id for the data
              channel to be open. As noted in [[!DATA-PROT]], DATA_CHANNEL_OPEN is not
              sent to the remote peer nor is DATA_CHANNEL_ACK expected in return. If set
              to <code>false</code>, the remote party will receive an ondatachannel event with a
              system constructed <code><a>RTCDataChannel</a></code> object.</p>
            </dd>
            <dt><dfn data-idl><code>id</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span></dt>
            <dd>
              <p>The <code>id</code> attribute represents the identifier for this
              <code><a>RTCDataChannel</a></code>. The id was either assigned by the user
              agent at channel creation time or was selected by the script. For SCTP, the
              id represents a stream identifier, as discussed in [[!DATA]] Section 6.5.</p>
            </dd>
            <dt><dfn data-idl><code>priority</code></dfn> of type <span class=
            "idlMemberType"><a>RTCPriorityType</a></span>, defaulting to <code>low</code></dt>
            <dd>
              <p>The priority of this <code><a>RTCDataChannel</a></code>.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>
  <section id="sctp-transport*">
    <h2><dfn>RTCSctpTransport</dfn> Interface</h2>
    <p>The <code>RTCSctpTransport</code> includes information relating to
    Stream Control Transmission Protocol (SCTP) transport.</p>
    <section id="sctp-transport-overview*">
      <h3>Overview</h3>
      <p>An <a>RTCSctpTransport</a> inherits from an <a>RTCDataTransport</a> object,
      which is associated to an <a>RTCDataChannel</a> object.</p>
    </section>
    <section id="sctptransport-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCSctpTransport</a></code> is constructed from an
      <code><a>RTCDtlsTransport</a></code> object, and optionally a port number (with a
      default of 5000, or the next unused port).
      An <code><a>RTCSctpTransport</a></code> object can be garbage-collected once
      <code>stop()</code> is called and it is no longer referenced.</p>
    </section>
    <section id="sctptransport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Constructor (RTCDtlsTransport transport, optional unsigned short port), Exposed=Window]
interface RTCSctpTransport : RTCDataTransport {
    readonly        attribute RTCDtlsTransport      transport;
    readonly        attribute RTCSctpTransportState state;
    readonly        attribute unsigned short        port;
    static RTCSctpCapabilities getCapabilities ();
    undefined                  start (RTCSctpCapabilities remoteCaps, optional unsigned short remotePort);
    undefined                  stop ();
                    attribute EventHandler          ondatachannel;
                    attribute EventHandler          onstatechange;
};</pre>
        <section>
          <h2>Constructors</h2>
          <p>To construct an <code><a>RTCSctpTransport</a></code>, run the following steps:</p>
          <ol>
            <li>Let <var>transport</var> be the first argument.</li>
            <li>If <code><var>transport</var>.state</code> is <code>closed</code>
            <a>throw</a> an <code>InvalidStateError</code>.</li>
            <li>Let <var>port</var> be the second argument.</li>
            <li><p>If <var>port</var> is set and is already in use,
            <a>throw</a> an <code>InvalidStateError</code>.</p></li>
            <li><p>Let <var>sctpTransport</var> be a new
            <code><a>RTCSctpTransport</a></code> object.</p></li>
            <li><p>Let <var>sctpTransport</var> have an
            <dfn>[[\SctpTransportState]]</dfn> internal slot initialized to
            <code>new</code>.</p></li>
            <li><p>Let <var>canSendSize</var> be the number of bytes that this
            client can send (i.e. the size of the local send buffer) or 0 if
            the implementation can handle messages of any size.</p></li>
            <li><p>Let <var>sctpTransport</var> have a <dfn>[[\MaxMessageSize]]</dfn>
            internal slot initialized to <var>canSendSize</var>.</p></li>
            <li><p>Return <var>sctpTransport</var>.</p></li>
          </ol>
          <dl data-link-for="RTCSctpTransport" data-dfn-for="RTCSctpTransport" class=
          "constructors">
            <dt><code><a>RTCSctpTransport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">port</td>
                    <td class="prmType"><code>unsigned short</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCSctpTransport" data-dfn-for="RTCSctpTransport" class=
          "attributes">
            <dt><dfn data-idl><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly</dt>
            <dd>
              <p>The <code><a>RTCDtlsTransport</a></code> instance the
              <code><a>RTCSctpTransport</a></code> object is sending over.</p>
            </dd>
            <dt><dfn data-idl><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCSctpTransportState</a></span>, readonly</dt>
            <dd>
              <p>The current state of the SCTP transport. On getting, it MUST return
              the value of the <a>[[\SctpTransportState]]</a> internal slot.</p>
            </dd>
            <dt><dfn data-idl><code>port</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned short</a></span>, readonly</dt>
            <dd>
              <p>The local SCTP port number used by the data channel.</p>
            </dd>
            <dt><code>ondatachannel</code> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>The <dfn><code>ondatachannel</code></dfn> event handler, of type
              <code>datachannel</code>, <em class="rfc2119" title="MUST">MUST</em> be
              supported by all objects implementing the <code><a>RTCSctpTransport</a></code>
              interface. If the remote peer sets the <a>[[\Negotiated]]</a> internal slot
              of its <code><a>RTCDataChannel</a></code>  to <code>false</code>,
              then the event will fire indicating a new
              <code><a>RTCDataChannel</a></code> object has been constructed to connect
              with the <code><a>RTCDataChannel</a></code> constructed by the remote
              peer.</p>
            </dd>
            <dt><dfn data-idl><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <a>[[\SctpTransportState]]</a> internal slot changes.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCSctpTransport" data-dfn-for="RTCSctpTransport" class=
          "methods">
            <dt><dfn data-idl><code>getCapabilities()</code></dfn>, static</dt>
            <dd>
              <p>Retrieves the <code><a>RTCSctpCapabilities</a></code>
              of the <code><a>RTCSctpTransport</a></code>. When the <code>getCapabilities</code>
              method is called the user agent <em class="rfc2119" title="MUST">MUST</em> run the following
              steps:</p>
              <ol>
                 <li><p>Let <var>capabilities</var> be a new
                 <code><a>RTCSctpCapabilities</a></code> dictionary.</p></li>
                 <li><p>Set <var>capabilities</var>'s <code>maxMessageSize</code> member to the
                 number of bytes that this client can send (i.e. the size of the local send buffer)
                 or 0 if the implementation can handle messages of any size.</p></li>
                 <li><p>Return <var>capabilities</var>.</p></li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCSctpCapabilities</a></code>
              </div>
            </dd>
            <dt><dfn data-idl><code>start</code></dfn></dt>
            <dd>
              <p>Starts the <code><a>RTCSctpTransport</a></code> instance
              and causes an SCTP INIT request to be issued over the
              <code><a>RTCDtlsTransport</a></code> from the local
              <code><a>RTCSctpTransport</a></code> to the remote
              <code><a>RTCSctpTransport</a></code> (causing the
              <a>[[\SctpTransportState]]</a> internal slot to transition
              to to <code>connecting</code>), where the remote
              <code><a>RTCSctpTransport</a></code> responds with an
              SCTP INIT-ACK. Since both local and remote parties must
              mutually create an <code><a>RTCSctpTransport</a></code>,
              SCTP SO (Simultaneous Open) is used to establish a connection
              over SCTP. If the <a>[[\SctpTransportState]]</a> internal slot
              is not <code>new</code> <a>throw</a> an <code>InvalidStateError</code>.
              If <code>remotePort</code> is not provided, a
              default value of <code>port</code> is assumed. If the
              remote port is in use, <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <p>When the <code>start</code> method is called, the user agent
              MUST update the <a>[[\MaxMessageSize]]</a> internal slot of the <code>
              <a>RTCSctpTransport</a></code> by running the following steps:</p>
              <ol>
                <li><p>Let <var>sctpTtransport</var> be the <code><a>RTCSctpTransport</a></code>
                object to be updated.</p></li>
                <li>Let <var>remoteCaps</var> be the first argument.</li>
                <li><p>Let <var>remoteMaxMessageSize</var> be the value of
                <var>remoteCaps</var>'s <code>maxMessageSize</code> member
                or 65536 if it is unset or null.</p></li>
                <li><p>Let <var>canSendSize</var> be the number of bytes that this
                client can send (i.e. the size of the local send buffer) or 0 if
                the implementation can handle messages of any size.</p></li>
                <li><p>If both <var>remoteMaxMessageSize</var> and
                <var>canSendSize</var> are 0, set the <a>[[\MaxMessageSize]]</a>
                internal slot to the positive Infinity value.</p></li>
                <li><p>Else, if either <var>remoteMaxMessageSize</var> or
                <var>canSendSize</var> is 0, set the <a>[[\MaxMessageSize]]</a>
                internal slot to the larger of the two.</p></li>
                <li><p>Else, set <a>[[\MaxMessageSize]]</a> internal slot
                to the smaller of <var>remoteMaxMessageSize</var> or
                <var>canSendSize</var>.</p></li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">remoteCaps</td>
                    <td class="prmType"><code><a>RTCSctpCapabilities</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">remotePort</td>
                    <td class="prmType"><code>unsigned short</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>stop</code></dfn></dt>
            <dd>
              <p>Stops the <a>RTCSctpTransport</a> instance.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
      <section id="rtcsctptransportstate*">
        <h3><dfn>RTCSctpTransportState</dfn> Enum</h3>
        <p><code>RTCSctpTransportState</code> indicates the state of the SCTP
        transport.</p>
        <div>
          <pre class="idl">enum RTCSctpTransportState {
    "new",
    "connecting",
    "connected",
    "closed"
};</pre>
          <table data-link-for="RTCSctpTransportState" data-dfn-for=
          "RTCSctpTransportState" class="simple">
            <tbody>
              <tr>
                <th colspan="2">Enumeration description</th>
              </tr>
              <tr>
                <td><dfn data-idl><code id=
                "idl-def-RTCSctpTransportState.new">new</code></dfn></td>
                <td>
                  <p>The <code><a>RTCSctpTransport</a></code> object has
                  been constructed but the <code>start</code> method has
                  not been called so the <code><a>RTCSctpTransport</a></code>
                  has not started negotiating yet.</p>
                </td>
              </tr>
              <tr>
                <td><dfn data-idl><code id=
                "idl-def-RTCSctpTransportState.connecting">connecting</code></dfn></td>
                <td>
                  <p>The <code>start</code> method has been called and the
                  <code><a>RTCSctpTransport</a></code> is in the process of
                  negotiating an association.</p>
                </td>
              </tr>
              <tr>
                <td><dfn data-idl><code id=
                "idl-def-RTCSctpTransportState.connected">connected</code></dfn></td>
                <td>
                  <p>The <code><a>RTCSctpTransport</a></code> has completed
                  negotiation of an association.</p>
                </td>
              </tr>
              <tr>
                <td><dfn data-idl><code id=
                "idl-def-RTCSctpTransportState.closed">closed</code></dfn></td>
                <td>
                  <p>A task is queued to update the [[\SctpTransportState]]
                  slot to <code>closed</code> when a SHUTDOWN or ABORT chunk
                  is received or when the SCTP association has been closed
                  intentionally, such as by a call to <code>stop</code>.</p>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="rtcsctpcapabilities*">
        <h3><dfn>RTCSctpCapabilities</dfn> Dictionary</h3>
        <p>The <code>RTCSctpCapabilities</code> dictionary provides information
        about the capabilities of the <code><a>RTCSctpTransport</a></code>.
        <div>
          <pre class="idl">dictionary RTCSctpCapabilities {
             required unsigned long maxMessageSize;
};</pre>
          <section>
            <h2>Dictionary <a class="idlType">RTCSctpCapabilities</a> Members</h2>
            <dl data-link-for="RTCSctpCapabilities" data-dfn-for="RTCSctpCapabilities"
            class="dictionary-members">
              <dt><dfn data-idl><code>maxMessageSize</code></dfn> of type <span class=
              "idlMemberType"><a>unsigned long</a></span>, required</dt>
              <dd>
                <p>The maximum size of data that the implementation can send
                or 0 if the implementation can handle messages of any size.</p>
              </dd>
            </dl>
          </section>
        </div>
      </section>
    </section>
    <section>
      <h3><dfn>RTCDataChannelEvent</dfn></h3>
      <p>The <code><a href="#event-datachannel">datachannel</a></code> event uses the
      <code><a>RTCDataChannelEvent</a></code> interface.</p>
      <p>Firing a datachannel event named <var>e</var> with a
      <code><a>RTCDataChannel</a></code> <var>channel</var> means that an event with the
      name <var>e</var>, which does not bubble (except where otherwise stated) and is not
      cancelable (except where otherwise stated), and which uses the
      <code><a>RTCDataChannelEvent</a></code> interface with the <code><a href=
      "#dom-datachannelevent-channel">channel</a></code> attribute set to
      <var>channel</var>, MUST be created and dispatched at the given target.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, RTCDataChannelEventInit eventInitDict), Exposed=Window]
interface RTCDataChannelEvent : Event {
    readonly        attribute RTCDataChannel channel;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCDataChannelEvent" data-dfn-for="RTCDataChannelEvent"
          class="constructors">
            <dt><code>RTCDataChannelEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>RTCDataChannelEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCDataChannelEvent" data-dfn-for="RTCDataChannelEvent"
          class="attributes">
            <dt><code>channel</code> of type <span class=
            "idlAttrType"><a>RTCDataChannel</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-datachannelevent-channel"><code>channel</code></dfn>
              attribute represents the <code><a>RTCDataChannel</a></code> object
              associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
          <p>The <dfn><code>RTCDataChannelEventInit</code></dfn> dictionary includes
          information on the configuration of the data channel.</p>
        <pre class="idl">dictionary RTCDataChannelEventInit : EventInit {
             required RTCDataChannel channel;
};</pre>
        <section>
          <h2>Dictionary RTCDataChannelEventInit Members</h2>
          <dl data-link-for="RTCDataChannelEventInit" data-dfn-for=
          "RTCDataChannelEventInit" class="dictionary-members">
            <dt><dfn data-idl><code>channel</code></dfn> of type <span class=
            "idlMemberType"><a>RTCDataChannel</a></span>, required</dt>
            <dd>
              <p>The <code><a>RTCDataChannel</a></code> object associated with the
              event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section class="informative" id="rtcsctpexample*">
      <h2>Examples</h2>
      <pre class="example highlight">
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

function initiate(mySignaller) {
  // Prepare the ICE gatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  // Handle state changes
  iceGatherer.onstatechange = function(event) {
    myIceGathererStateChange("iceGatherer", event.state);
  };
  // Handle errors
  iceGatherer.onerror = errorHandler;
  // Prepare to signal local candidates
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

  // Start gathering
  iceGatherer.gather();
  // Create ICE transport
  var ice = new RTCIceTransport(iceGatherer);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };

  // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create DTLS and SCTP transport
  var dtls = new RTCDtlsTransport(ice, certs);
  var sctp = new RTCSctpTransport(dtls);

  // Construct RTCDataChannelParameters dictionary
  var parameters = {
    label: "channel1",
    ordered: true,
    protocol: "ship",
    negotiated: false
  };

  mySignaller.sendInitiate({
    ice: iceGatherer.getLocalParameters(),
    dtls: dtls.getLocalParameters(),
    sctpCapabilities: RTCSctpTransport.getCapabilities(),
    port: sctp.port,
    // ... marshall RtpSender/RtpReceiver capabilities as in Section 6.6 Examples 8 and 9.
  }, function(remote) {
    // Start the ICE, DTLS and SCTP transports
    ice.start(iceGatherer, remote.ice, RTCIceRole.controlling);
    dtls.start(remote.dtls);
    sctp.start(remote.sctpCapabilities, remote.port);
    // Create the data channel object
    var channel = new RTCDataChannel(sctp, parameters);
    channel.send("foo");
    // ... configure RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.
  });
}
</pre>
<pre class="example highlight">
// This is an example of how to answer
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

function accept(mySignaller, remote) {
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  // Handle state changes
  iceGatherer.onstatechange = function(event) {
    myIceGathererStateChange("iceGatherer", event.state);
  };
  // Handle errors
  iceGatherer.onerror = errorHandler;
  // Prepare to signal local candidates
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

   // Start gathering
  iceGatherer.gather();
  // Create ICE transport
  var ice = new RTCIceTransport(iceGatherer);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };

   // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create DTLS and SCTP transport
  var dtls = new RTCDtlsTransport(ice, certs);
  var sctp = new RTCSctpTransport(dtls);

  mySignaller.sendAccept({
    ice: iceGatherer.getLocalParameters(),
    dtls: dtls.getLocalParameters(),
    sctpCapabilities: RTCSctpTransport.getCapabilities(),
    port: sctp.port,
    // ... marshall RtpSender/RtpReceiver capabilities as in Section 6.6 Examples 8 and 9.
  });

   // Start the ICE, DTLS and SCTP transports
  ice.start(iceGatherer, remote.ice, RTCIceRole.controlled);
  dtls.start(remote.dtls);
  // Start the SctpTransport
  sctp.start(remote.sctpCapabilities, remote.port);

  // ... configure RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.

  // Assume in-band signalling. We could also have sent
  // RTCDataChannelParameters in signalling and constructed
  // the data channel with negotiated: true.

  sctp.ondatachannel = function(channel) {
    channel.onmessage = function(message) {
      if (message === "foo") {
        channel.send("bar");
      }
    };
  };
}
                </pre>
    </section>
  </section>
  <section>
    <h3>Statistics API</h3>
    <p>The Statistics API enables retrieval of statistics relating to
    <code><a>RTCRtpSender</a></code>, <code><a>RTCRtpReceiver</a></code>,
    <code><a>RTCDtlsTransport</a></code>, <code><a>RTCIceGatherer</a></code>,
    <code><a>RTCIceTransport</a></code> and <code><a>RTCSctpTransport</a></code> objects.
    For detailed information on the Statistics API, consult [[!WEBRTC-STATS]].</p>
    <div>
      <p>The <dfn><code>RTCStatsProvider</code></dfn> interface enables the retrieval of statistics.</p>
      <pre class="idl">interface RTCStatsProvider {
    Promise&lt;RTCStatsReport&gt; getStats ();
};</pre>
      <section>
        <h2>Methods</h2>
        <dl data-link-for="RTCStatsProvider" data-dfn-for="RTCStatsProvider" class=
        "methods">
          <dt><code>getStats</code></dt>
          <dd>
            <p>Gathers stats for the given object and reports the result asynchronously.
            If the object has not yet begun to send or receive data, the returned stats
            will reflect this. If the object is in the closed state, the returned stats
            will reflect the stats at the time the object transitioned to the closed
            state.</p>
            <p>When the <dfn><code>getStats</code></dfn> method is invoked, the <a>user agent</a> MUST
            queue a task to run the following steps:</p>
            <ol>
              <li>
                <p>Let <var>p</var> be a new promise.</p>
              </li>
              <li>
                <p>Return, but continue the following steps in the background.</p>
              </li>
              <li>
                <p>Start gathering the stats.</p>
              </li>
              <li>
                <p>When the relevant stats have been gathered, return a new
                <code><a>RTCStatsReport</a></code> object, representing the gathered
                stats.</p>
              </li>
            </ol>
            <div>
              <em>No parameters.</em>
            </div>
            <div>
              <em>Return type:</em>
              <code>Promise</code>&lt;<code><a>RTCStatsReport</a></code>&gt;
            </div>
          </dd>
        </dl>
      </section>
    </div>
    <section>
      <h4><dfn>RTCStatsReport</dfn> Interface</h4>
      <p>The <code>getStats()</code> method delivers a successful result in the
      form of a <code>RTCStatsReport</code> object. An
      <code>RTCStatsReport</code> represents a map between strings,
      identifying the inspected objects (<a href="#dom-rtcstats-id">RTCStats.id</a>), and
      their corresponding <code><a>RTCStats</a></code> objects.</p>
      <p>An <code>RTCStatsReport</code> may be composed of several
      <code><a>RTCStats</a></code> objects, each reporting stats for one underlying
      object. One achieves the total for the object by summing over all stats of a
      certain type; for instance, if an <code><a>RTCRtpSender</a></code> object is
      sending RTP streams involving multiple SSRCs over the network, the
      <code><a>RTCStatsReport</a></code> may contain one <code>RTCStats</code> object per
      SSRC (which can be distinguished by the value of the <var>ssrc</var> stats
      attribute).</p>
      <div>
        <pre class="idl">[Exposed=Window]
interface RTCStatsReport {
    readonly maplike&lt;DOMString, object&gt;;
};</pre>
        <p>This interface has "entries", "forEach", "get", "has", "keys",
        "values", @@iterator methods and a "size" getter brought by
        <code>readonly maplike</code>.</p>
        <p>Use these to retrieve the various dictionaries descended from
        <code><a>RTCStats</a></code> that this stats report is composed of. The
        set of supported property names [[!WEBIDL]] is defined as the ids of
        all the <code><a>RTCStats</a></code>-derived dictionaries that have
        been generated for this stats report.</p>
      </div>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCStatsReport" data-dfn-for="RTCStatsReport" class=
          "methods">
            <dt><code>RTCStats</code></dt>
            <dd>
              <p>Getter to retrieve the <code><a>RTCStats</a></code> objects that this
              stats report is composed of.</p>
              <p>The set of supported property names [[!WEBIDL]] is defined as the ids of
              all the <code><a>RTCStats</a></code> objects that has been generated for
              this stats report. The order of the property names is left to the user
              agent.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">id</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>getter</code>
              </div>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h4><dfn>RTCStats</dfn> Dictionary</h4>
      <p>An <code>RTCStats</code> dictionary represents the stats gathered by
      inspecting a specific object. The <code>RTCStats</code> dictionary is a base
      type that specifies as set of default attributes, such as <code>timestamp</code>
      and <code>type</code>. Specific stats are added by extending the
      <code>RTCStats</code> dictionary.</p>
      <p>Note that while stats names are standardized, any given implementation may be
      using experimental values or values not yet known to the Web application. Thus,
      applications MUST be prepared to deal with unknown stats.</p>
      <p>Statistics need to be synchronized with each other in order to yield reasonable
      values in computation; for instance, if "bytesSent" and "packetsSent" are both
      reported, they both need to be reported over the same interval, so that "average
      packet size" can be computed as "bytes / packets" - if the intervals are different,
      this will yield errors. Thus implementations MUST return synchronized values for
      all stats in an <code>RTCStats</code> dictionary.</p>
      <div>
        <pre class="idl">dictionary RTCStats {
             DOMHighResTimeStamp timestamp;
             RTCStatsType        type;
             DOMString           id;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCStats</a> Members</h2>
          <dl data-link-for="RTCStats" data-dfn-for="RTCStats" class=
          "dictionary-members">
            <dt><code>timestamp</code> of type <span class=
            "idlMemberType"><a>DOMHighResTimeStamp</a></span></dt>
            <dd>
              <p>The <dfn><code>timestamp</code></dfn>, of type
              <code>DOMHighResTimeStamp</code> [[!HIGHRES-TIME]], associated with this
              object. The time is relative to the UNIX epoch (Jan 1, 1970, UTC). The
              timestamp for local measurements corresponds to the local clock and for
              remote measurements corresponds to the timestamp indicated in the incoming
              RTCP Sender Report (SR), Receiver Report (RR) or Extended Report (XR).</p>
            </dd>
            <dt><code>type</code> of type <span class=
            "idlMemberType"><a>RTCStatsType</a></span></dt>
            <dd>
              <p>The type of this object.</p>
              <p>The <dfn id="dom-rtcstats-type"><code>type</code></dfn> attribute
              <em class="rfc2119" title="MUST">MUST</em> be initialized to the name of
              the most specific type this <code><a>RTCStats</a></code> dictionary
              represents.</p>
            </dd>
            <dt><dfn><code>id</code></dfn> of type <span class=
            "idlMemberType"><a>DOMString</a></span></dt>
            <dd>
              <p>A unique <code>id</code> that is associated with the object that was
              inspected to produce this <code><a>RTCStats</a></code> object. Two
              <code><a>RTCStats</a></code> objects, extracted from two different
              <code><a>RTCStatsReport</a></code> objects, <em class="rfc2119" title=
              "MUST">MUST</em> have the same <code>id</code> if they were produced by
              inspecting the same underlying object. User agents are free to pick any
              format for the <code>id</code> as long as it meets the requirements
              above.</p>
            </dd>
          </dl>
        </section>
      </div>
      <section id="rtcstatstype*">
        <h3><dfn>RTCStatsType</dfn> Enum</h3>
        <p>For ORTC, <code><a>RTCStatsType</a></code> is equal to one of the
        values defined in [[!WEBRTC-STATS]] Section 6.1:</p>
        <dl>
          <dt><code>"inbound-rtp"</code></dt>
          <dd>
            <p>Statistics for the inbound RTP stream. It is accessed via the
            <code>RTCInboundRTPStreamStats</code> defined in [[!WEBRTC-STATS]] Section
            7.3. Local inbound RTP statistics can be obtained from the
            <code><a>RTCRtpReceiver</a></code> object; remote inbound RTP statistics can
            be obtained from the <code><a>RTCRtpSender</a></code> object.</p>
          </dd>
          <dt><code>"outbound-rtp"</code></dt>
          <dd>
            <p>Statistics for the outbound RTP stream. It is accessed via the
            <code>RTCOutboundRTPStreamStats</code> defined in [[!WEBRTC-STATS]] Section
            7.4. Local outbound RTP statistics can be obtained from the
            <code><a>RTCRtpSender</a></code> object; remote outbound RTP statistics can
            be obtained from the <code><a>RTCRtpReceiver</a></code> object.</p>
          </dd>
          <dt><code>"data-channel"</code></dt>
          <dd>
            <p>Statistics relating to each <code><a>RTCDataChannel</a></code> id. It is
            accessed via the <code>RTCDataChannelStats</code> defined in
            [[!WEBRTC-STATS]] Section 7.8.</p>
          </dd>
          <dt><code>"track"</code></dt>
          <dd>
            <p>Statistics relating to the <code>MediaStreamTrack</code> object. It is
            accessed via the <code>RTCMediaStreamTrackStats</code> defined in
            [[!WEBRTC-STATS]] Section 7.7.</p>
          </dd>
          <dt><code>"transport"</code></dt>
          <dd>
            <p>Transport statistics related to the <code><a>RTCDtlsTransport</a></code>
            object. It is accessed via the <code>RTCTransportStats</code>
            defined in [[!WEBRTC-STATS]] Sections 7.9.</p>
          </dd>
          <dt><code>"candidate-pair"</code></dt>
          <dd>
            <p>ICE candidate pair statistics related to
            <code><a>RTCIceTransport</a></code> objects. It is accessed via the
            <code>RTCIceCandidatePairStats</code> defined in [[!WEBRTC-STATS]]
            Section 7.11.</p>
          </dd>
          <dt><code>"local-candidate"</code></dt>
          <dd>
            <p>ICE local candidate statistics, related to <code><a>RTCIceGatherer</a></code>
            objects. It is accessed via the <code>RTCIceCandidateStats</code> for the
            local candidate, defined in [[!WEBRTC-STATS]] Section 7.10.</p>
          </dd>
          <dt><code>"remote-candidate"</code></dt>
          <dd>
            <p>ICE remote candidate statistics, related to <code><a>RTCIceTransport</a></code>
            objects. It is accessed via the <code>RTCIceCandidateStats</code>
            for the remote candidate, defined in [[!WEBRTC-STATS]] Section 7.10.</p>
          </dd>
          <dt><code>"certificate"</code></dt>
          <dd>
            <p>Information about a certificate used by an <code><a>RTCDtlsTransport</a></code>
            object. It is accessed via the <code>RTCCertificateStats</code>
            defined in [[!WEBRTC-STATS]] Sections 7.12.</p>
          </dd>
        </dl>
      </section>
    </section>
    <section>
      <h3>Mandatory To Implement Stats</h3>
      <p>The stats listed in [[!WEBRTC-STATS]] are intended to cover a wide
      range of use cases. Not all of them have to be implemented by every
      ORTC implementation.</p>
      <p>An ORTC implementation MUST support generating statistics of the types
      described in [[!WEBRTC10]] Section 8.6, with the exception of
      <code>RTCPeerConnectionStats</code>, when the corresponding
      objects exist, with the attributes that are listed when they are
      valid for that object. An implementation MAY support generating any
      other statistic defined in [[!WEBRTC-STATS]], and MAY generate
      statistics that are not documented.</p>
    </section>      
    <section class="informative">
      <h4>Example</h4>
      <p>Consider the case where the user is experiencing bad sound and the application
      wants to determine if the cause of it is packet loss. The following example code
      might be used:</p>
      <pre class="example highlight">var mySender = new RTCRtpSender(myTrack);
var myPreviousReport = null;

// ... wait a bit
setTimeout(function() {
  mySender.getStats().then(function(report) {
    processStats(report);
    myPreviousReport = report;
  });
}, aBit);

function processStats(currentReport) {
  if (myPreviousReport === null) return;

  // currentReport + myPreviousReport are an RTCStatsReport interface
  // compare the elements from the current report with the baseline
  for (var i in currentReport) {
    var now = currentReport[i];
    if (now.type !== "outboundrtp") continue;

    // get the corresponding stats from the previous report
    base = myPreviousReport[now.id];

    // base + now will be of RTCRtpStreamStats dictionary type
    if (base) {
      remoteNow = currentReport[now.associateStatsId];
      remoteBase = myPreviousReport[base.associateStatsId];
      var packetsSent = now.packetsSent - base.packetsSent;
      var packetsReceived = remoteNow.packetsReceived - remoteBase.packetsReceived;
      // if fractionLost is &gt; 0.3, we have probably found the culprit
      var fractionLost = (packetsSent - packetsReceived) / packetsSent;
    }
  }
}
                </pre>
    </section>
  </section>
  <section id="identity-api">
    <h2>Identity</h2>
    <div class="issue atrisk">
       <p>The Identity API is marked as a feature at risk, since there is no
         clear commitment from implementers.</p>
    </div>
    <section id="rtcidentity-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCIdentity</a></code> instance enables authentication of an
      <code><a>RTCDtlsTransport</a></code> using a web-based Identity Provider (IdP).
      The initiator acts as the Authenticating Party (AP) and obtains an
      identity assertion from the IdP which is then conveyed in signaling.
      The responder acts as the Relying Party (RP) and verifies the assertion.</p>
      <p>The interaction with the IdP is designed to decouple the browser from
      any particular identity provider; the browser need only know how to load
      the IdP's JavaScript, the location of which is determined by the IdP's
      identity, and the generic interface to generating and validating
      assertions. The IdP provides whatever logic is necessary to bridge the
      generic protocol to the IdP's specific requirements. Thus, a single
      browser can support any number of identity protocols, including being
      forward compatible with IdPs which did not exist at the time the browser
      was written.</p>
    </section>
    <section id="rtcidentity-operation*">
      <h3>Operation</h3>
      <p>An <code><a>RTCIdentity</a></code> instance is constructed from an
      <code><a>RTCDtlsTransport</a></code> object.</p>
    </section>
        <section>
      <h3><dfn>RTCIdentity</dfn> Interface</h3>
      <p>The Identity API is described below.</p>
      <div>
        <pre class="idl">
[ Constructor (RTCDtlsTransport transport)]
interface RTCIdentity {
    undefined       setIdentityProvider (DOMString provider, optional RTCIdentityProviderOptions options);
    Promise&lt;DOMString&gt; getIdentityAssertion ();
    readonly        attribute Promise&lt;RTCIdentityAssertion&gt; peerIdentity;
    readonly        attribute RTCDtlsTransport              transport;
    readonly        attribute DOMString?                    idpLoginUrl;
    readonly        attribute DOMString?                    idpErrorInfo;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="RTCIdentity" data-dfn-for="RTCIdentity" class=
          "constructors">
            <dt><code><a>RTCIdentity</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCDtlsTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCIdentity" data-dfn-for="RTCIdentity" class="attributes">
            <dt><dfn data-idl><code>peerIdentity</code></dfn> of type <span class=
            "idlAttrType">Promise&lt;<a>RTCIdentityAssertion</a>&gt;</span>,
            readonly</dt>
            <dd>
              <p>A promise that <a>resolves</a> with the identity of the peer if the
              identity is successfully validated.</p>
              <p>This promise is <a>rejected</a> if an identity assertion is present
              in a remote session description and validation of that assertion
              fails for any reason. If the promise is <a>rejected</a>, a new
              unresolved value is created, unless a <a>target peer identity</a>
              has been established. If this promise successfully <a>resolves</a>, the
              value will not change.</p>
            </dd>
            <dt><dfn data-idl><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCDtlsTransport</a></span>, readonly</dt>
            <dd>
              <p>The <code><a>RTCDtlsTransport</a></code> to be authenticated.</p>
            </dd>
            <dt><dfn data-idl><code>idpLoginUrl</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly, nullable</dt>
            <dd>
              <p>The URL that an application can navigate to so that the user
              can login to the IdP, as described in <a href=
              "#sec.idp-loginneeded"></a>.</p>
            </dd>
            <dt><dfn data-idl><code>idpErrorInfo</code></dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly, nullable</dt>
            <dd>
              <p>An attribute that the IdP can use to pass additional
              information back to the applications about the
              error. The format of this string is defined by the IdP
              and may be JSON.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCIdentity" data-dfn-for="RTCIdentity" class="methods">
            <dt><code>setIdentityProvider</code></dt>
            <dd>
              <p>Sets the identity provider to be used for a given
              <code>RTCIdentity</code> object. Applications need not make
              this call; if the browser is already configured for an IdP, then
              that configured IdP might be used to get an assertion.</p>
              <p>When the <dfn data-idl><code>setIdentityProvider</code></dfn> method is
              invoked, the user agent MUST run the following steps:</p>
              <ol>
                <li>
                  <p>If the <code><a>RTCIdentity</a></code> object's
                  <code><var>transport</var>.state</code> attribute
                  is <code>closed</code>, <a>throw</a> an
                  <code>InvalidStateError</code>.</p>
                </li>
                <li>
                  <p>If <var>options.protocol</var> includes the the character
                  <code>'/'</code> or <code>'\'</code>, throw a
                  <code>SyntaxError</code>.</p>
                </li>
                <li>
                  <p>Set the current identity provider values to the tuple
                  (<code>provider</code>, <code>options</code>).</p>
                </li>
                <li>
                  <p>If any identity provider value has changed, discard any
                  stored identity assertion.</p>
                </li>
              </ol>
              <p>Identity provider information is not used until an identity
              assertion is required in response to a call to
              <code>getIdentityAssertion</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">provider</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">options</td>
                    <td class="prmType"><code>RTCIdentityProviderOptions</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>undefined</code>
              </div>
            </dd>
            <dt><dfn data-idl><code>getIdentityAssertion</code></dfn></dt>
            <dd>
              <p>Initiates the process of obtaining an identity assertion.
              Applications need not make this call. It is merely intended to
              allow them to start the process of obtaining identity assertions
              before a call is initiated. If an identity is needed, either
              because the browser has been configured with a default identity
              provider or because the <code><a>setIdentityProvider</a></code> method
              was called, then an identity will be automatically requested when
              an offer or answer is created.</p>
              <p>When <code>getIdentityAssertion</code> is invoked, queue a
              task to run the following steps:</p>
              <ol>
                <li>
                  <p>If the <code>RTCIdentity</code> object's
                  <code><var>transport</var>.state</code> attribute
                  is <code>closed</code>, <a>throw</a> an
                  <code>InvalidStateError</code>.</p>
                </li>
                <li>
                  <p><a href="#sec.identity-proxy-assertion-request">Request an
                  identity assertion</a> from the IdP.</p>
                </li>
                <li>
                  <p><a>Resolve</a> the promise with the base64 and JSON encoded
                  assertion.</p>
                </li>
              </ol>             
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>Promise&lt;DOMString&gt;</code>
             </div>          
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
        <h4 id="sec.identity-proxy-communications">Identity Provider
        Selection</h4>
        <p>An IdP is used to generate an identity assertion as follows:</p>
        <ol>
          <li>If the <code>setIdentityProvider()</code> method has been called,
          the IdP provided shall be used.</li>
          <li>If the <code>setIdentityProvider()</code> method has not been
          called, then the user agent MAY use an IdP configured into the
          browser.</li>
        </ol>
        <p>In order to verify assertions, the IdP domain name and protocol are
        taken from the <code>domain</code> and <code>protocol</code> fields of
        the identity assertion.</p>
     </section>
     <section>
        <h4 id="sec.create-identity-proxy">Instantiating an IdP Proxy</h4>
        <p>Instantiating an IdP proxy is described in [[WEBRTC-IDENTITY]] Section 4.2.</p>  
        <section>
          <h2 id="sec.implement-idp">Implementing an IdP Securely</h2>
          <p>Aspects of IdP security are described in [[WEBRTC-IDENTITY]] Section 4.2.1.</p>
        </section>
      </section>
    <section>
      <h2 id="sec.register-idp">Registering an IdP Proxy</h2>
      <p>Registration of an IdP proxy is described in [[WEBRTC-IDENTITY]] Section 5.</p>
      <section>
        <h2>Interface Exposed by Identity Providers</h2>
        <p>The <code><a>RTCIdentityProvider</a></code> callback functions
        are called by <code><a>RTCDtlsTransport</a></code>
        to acquire or validate identity assertions.</p>
      </section>
     </section>
    <section>
      <h3 id="sec.identity-proxy-assertion-request">Requesting Identity
      Assertions</h3>
      <p>The identity assertion request process is triggered by a call to
      <code>getIdentityAssertion</code>. When this call is invoked and an
      identity provider has been set, the following steps are executed:</p>
      <ol>
        <li>
          <p>The <code>RTCIdentity</code> instantiates an IdP as
          described in <a href="#sec.identity-proxy-communications">Identity
          Provider Selection</a> and <a href="#sec.register-idp">Registering an
          IdP Proxy</a>. If the IdP cannot be loaded, instantiated, or the IdP
          proxy is not registered, this process fails.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> invokes the <code><a data-link-for=
          "RTCIdentityProvider">generateAssertion</a></code> method on the
          <code><a>RTCIdentityProvider</a></code> methods registered by the
          IdP.</p>
          <p>The <code>RTCIdentity</code> generates the
          <var>contents</var> parameter to this method as described in
          [[!RTCWEB-SECURITY-ARCH]]. The value of <var>contents</var> includes
          the fingerprint of the certificate that was selected or generated
          during the construction of the <code>RTCDtlsTransport</code>
          <code>RTCIdentity.transport</code>. The
          <var>origin</var> parameter contains the origin of the script that
          triggers this behavior. The <var>usernameHint</var> value is the same value that is
          provided to <code>setIdentityProvider</code>, if any such value
          was provided.</p>
        </li>
        <li>
          <p>The IdP proxy returns a Promise to the
          <code>RTCIdentity</code>. The IdP proxy is expected to generate
          the identity assertion asynchronously.</p>
          <p>If the user has been authenticated by the IdP, and the IdP is able
          to generate an identity assertion, the IdP <a>resolves</a> the promise with
          an identity assertion in the form of an
          <code><a>RTCIdentityAssertionResult</a></code>.</p>
          <p>This step depends entirely on the IdP. The methods by which an IdP
          authenticates users or generates assertions is not specified, though
          they could involve interacting with the IdP server or other
          servers.</p>
        </li>
        <li>
          <p>If the IdP proxy produces an error or returns a promise that does
          not <a>resolve</a> to a valid
          <code><a>RTCIdentityAssertionResult</a></code> (see <a href=
          "#sec.idp-error-handling"></a>), then assertion generation fails.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> MAY store the identity
          assertion for future use. If a fresh identity
          assertion is needed for any reason, applications can create a new
          <code>RTCIdentity</code>.</p>
        </li>
      </ol>
      <p>If assertion generation fails, then the promise for the corresponding
      function call is <a>rejected</a> with a newly <a data-link-for="exception"
      data-lt="create">created</a> <code>OperationError</code>.</p>
      <section>
        <h4 id="sec.idp-loginneeded">User Login Procedure</h4>
        <p>User login proceeds as described in [[WEBRTC-IDENTITY]] Section 6.1.
        IdP errors are handled as described in [[WEBRTC-IDENTITY]] Section 8.</p>
      </section>
    </section>
    <section>
      <h3 id="sec.identity-verify-assertion">Verifying Identity Assertions</h3>
      <p>Identity assertion validation happens when
      <code>RTCIdentity.<var>transport</var>.start()</code>
      is called. The process runs asynchronously,
      meaning that validation of an identity assertion might not block the
      transition of <code>RTCIdentity.<var>transport</var>.state</code> to
      <code>connected</code>.</p>
      <p>The identity assertion request process involves the following
      asynchronous steps:</p>
      <ol>
        <li>
          <p>The <code>RTCIdentity</code> awaits any prior identity
          validation. Only one identity validation can run at a time for an
          <code>RTCIdentity</code> instance.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> loads the identity assertion
          from the session description and decodes the base64 value, then
          parses the resulting JSON. The <var>idp</var> parameter of the
          resulting dictionary contains a <var>domain</var> and an optional
          <var>protocol</var> value that identifies the IdP, as described in
          [[!RTCWEB-SECURITY-ARCH]].</p>
        </li>
        <li>
          <p>If the identity assertion is malformed, or if <var>protocol</var>
          includes the character <code>'/'</code> or <code>'\'</code>,
          this process fails.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> instantiates the identified IdP
          as described in <a href="#sec.identity-proxy-communications"></a> and
          <a href="#sec.register-idp"></a>. If the IdP cannot be loaded,
          instantiated or the IdP proxy is not registered, this process
          fails.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> invokes the <code><a data-link-for=
          "RTCIdentityProvider">validateAssertion</a></code> method registered
          by the IdP.</p>
          <p>The <var>assertion</var> parameter is taken from the decoded
          identity assertion. The <var>origin</var> parameter contains the
          origin of the script that calls the <code>RTCIdentity</code>
          method that triggers this behavior.</p>
        </li>
        <li>
          <p>The IdP proxy returns a promise and performs the validation
          process asynchronously.</p>
          <p>The IdP proxy verifies the identity assertion using whatever means
          necessary. Depending on the authentication protocol this could
          involve interacting with the IdP server.</p>
        </li>
        <li>
          <p>If the IdP proxy produces an error or returns a promise that does
          not <a>resolve</a> to a valid
          <code><a>RTCIdentityValidationResult</a></code> (see <a href=
          "#sec.idp-error-handling"></a>), then identity validation fails.</p>
        </li>
        <li>
          <p>Once the assertion is successfully verified, the IdP proxy
          <a>resolves</a> the promise with an
          <code><a>RTCIdentityValidationResult</a></code> containing the
          validated identity and the original contents that are the payload of
          the assertion.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> decodes the <code>contents</code>
          attribute of <code><a>RTCIdentityValidationResult</a></code>
          and validates that it contains a fingerprint value for the remote certificate.
          This ensures that the certificate used by the remote peer for
          communications is covered by the identity assertion.</p>
          <p class="note">A <a>user agent</a> is required to fail to
          communicate with peers that offer a certificate that doesn't match.</p>
          <p class="note">The user agent decodes <code>contents</code> using
          the format described in [[!RTCWEB-SECURITY-ARCH]]. However the IdP
          MUST treat <code>contents</code> as opaque and return the same string
          to allow for future extensions.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> validates that the domain
          portion of the identity matches the domain of the IdP as described in
          [[!RTCWEB-SECURITY-ARCH]]. If this check fails then the identity
         validation fails.</p>
        </li>
        <li>
          <p>The <code>RTCIdentity</code> resolves the
          <code>peerIdentity</code> attribute with a new
          instance of <code>RTCIdentityAssertion</code> that includes the IdP
          domain and peer identity.</p>
        </li>
        <li>
          <p>The <a>user agent</a> MAY display identity information to a user
          in its UI. Any user identity information that is displayed in this
          fashion MUST use a mechanism that cannot be spoofed by content.</p>
        </li>
      </ol>
      <p>If identity validation fails, the
      <code>peerIdentity</code> promise is <a>rejected</a> with a
      newly <a data-link-for="exception" data-lt="create">created</a>
      <code>OperationError</code>.</p>
      <p>If identity validation fails and there is a target peer
      identity for the <code><a>RTCDtlsTransport</a></code>, the promise returned
      MUST be <a>rejected</a> with the same
      <code>DOMException</code>.</p>
      <p>If identity validation fails and there is no a target peer
      identity, the value of the
      <code>peerIdentity</code> MUST be set to a new,
      unresolved promise instance. This permits the use of renegotiation (or a
      subsequent answer, if the session description was a provisional answer)
      to resolve or reject the identity.</p>
    </section>
    <section class="informative">
      <h3>Example</h3>
      <p>The identity system is designed so that applications need not take any special
      action in order for users to generate and verify identity assertions; if a user has
      configured an IdP into their browser, then the browser will automatically
      request/generate assertions and the other side will automatically verify them and
      display the results. However, applications may wish to exercise tighter control
      over the identity system as shown by the following examples.</p>
      <div>
        <p>This example shows how to configure the identity provider and protocol, and
        consume identity assertions.</p>
        <pre class="example highlight">
        // Set ICE gather options and construct the RTCIceGatherer object, assuming that
// we are using RTP/RTCP mux and A/V mux so that only one RTCIceTransport is needed.
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';
var gatherOptions = {
  gatherPolicy: "all",
  iceServers: [
    { urls: "stun:stun1.example.net" },
    { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
      credentialType: "password" }
   ]
};
var iceGatherer = new RTCIceGatherer(gatherOptions);
iceGatherer.onlocalcandidate = function(event) {
  mySendLocalCandidate(event.candidate);
};
// Start gathering
iceGatherer.gather();
// Construct the ICE transport
var ice = new RTCIceTransport(iceGatherer);
// Create the DTLS certificate
var certs;
var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
  certs[0] = certificate;
}, function(){
  trace('Certificate could not be created');
});

// Create the RTCDtlsTransport object.
var dtls = new RTCDtlsTransport(ice, certs);
var identity = new RTCIdentity(dtls);
identity
  .getIdentityAssertion("example.com", "default", "alice@example.com")
  .then(signalAssertion(assertion), function(e) {
    trace("Could not obtain an Identity Assertion. idp: " + e.idp + " Protocol: "
      + e.protocol + " loginUrl: " + e.loginUrl);
  });

function signalAssertion(assertion) {
  mySignalInitiate({
    myAssertion: assertion,
    ice: iceGatherer.getLocalParameters(),
    dtls: dtls.getLocalParameters()
  }, function(response) {
    ice.start(iceGatherer, response.ice, RTCIceRole.controlling);
    // Call dtls.start() before setIdentityAssertion so the peer assertion can be validated.
    dtls.start(response.dtls);
    identity.setIdentityAssertion(response.myAssertion).then(function(peerAssertion) {
      trace("Peer identity assertion validated. idp: " + peerAssertion.idp + " name: "
        + peerAssertion.name);
    }, function(e) {
      trace("Could not validate peer assertion. idp: " + e.idp + " Protocol: " + e.protocol);
    });
  });
}
                    </pre>
      </div>
    </section>
  </section>
  <section id="certificate-api">
    <h2>Certificate Management</h2>
    <section id="rtccertificate-overview*">
      <h3>Overview</h3>
      <p>The <code>RTCCertificate</code> interface represents a
      certificate used to authenticate communications. In addition to
      the visible properties, internal slots contain a handle to the
      generated private keying materal (<dfn>[[\KeyingMaterial]]</dfn>) and a certificate
      (<dfn>[[\Certificate]]</dfn>]]).</p>
      <p>Certificates are provided in the constructors of
      <code><a>RTCDtlsTransport</a></code> and <code><a>RTCQuicTransport</a></code>
      objects, and are used to authenticate to a peer. This makes it possible
      to support forking, where the offerer creates multiple <code><a>RTCDtlsTransport</a></code>
      or <code><a>RTCQuicTransport</a></code> objects using the same local certificate and
      fingerprint. Also, an <code>RTCCertificate</code> can be persisted in
      [[INDEXEDDB]] and reused, so as to avoid the cost of key generation.</p>
    </section>
    <section>
        <h2><dfn>RTCCertificateExpiration</dfn> Dictionary</h2>
        <p><code><a>RTCCertificateExpiration</a></code> is used to set an
        expiration date on certificates generated by
        <code>generateCertificate</code>.</p>
        <pre class="idl">dictionary RTCCertificateExpiration {
    [EnforceRange]
    DOMTimeStamp expires;
};</pre>
        <dl data-link-for="RTCCertificateExpiration" data-dfn-for=
        "RTCCertificateExpiration" class="methods">
          <dt><dfn data-idl>expires</dfn></dt>
          <dd>
            <p>An optional <code>expires</code> attribute MAY be added to the
            definition of the algorithm that is passed to
            <code>generateCertificate</code>. If this
            parameter is present it indicates the maximum time that the
            <code><a>RTCCertificate</a></code> is valid for relative to the
            current time.</p>
            <p>When <code>generateCertificate</code> is called
            with an <code><a>object</a></code> argument, the <a>user agent</a>
            attempts to convert the object into an
            <code><a>RTCCertificateExpiration</a></code>. If this is
            unsuccessful, immediately return a promise that is <a>rejected</a> with a
            newly <a data-link-for="exception" data-lt="create">created</a>
            <code>TypeError</code> and abort processing.</p>
            <p>A <a>user agent</a> generates a certificate that has an
            expiration date set to the current time plus the value of the
            <code>expires</code> attribute. The <a data-link-for=
            "RTCCertificate"><code>expires</code></a> attribute of the returned
            <a><code>RTCCertificate</code></a> is set to the expiration time of
            the certificate. A <a>user agent</a> MAY choose to limit the value
            of the <a data-link-for="RTCCertificate"><code>expires</code></a>
            attribute.</p>
          </dd>
        </dl>
      </section>
    <section>
      <h3><dfn>RTCCertificate</dfn> Interface</h3>
      <p>The <code>RTCCertificate</code> interface is described below.</p>
      <div>
        <pre class="idl">[Exposed=Window]
        interface RTCCertificate {
    readonly        attribute DOMTimeStamp       expires;
    static sequence&lt;AlgorithmIdentifier&gt; getSupportedAlgorithms();
    sequence&lt;RTCDtlsFingerprint&gt; getFingerprints ();
    static Promise&lt;RTCCertificate&gt; generateCertificate (AlgorithmIdentifier keygenAlgorithm);
};</pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCCertificate" data-dfn-for="RTCCertificate" class=
          "attributes">
            <dt><dfn><code>expires</code></dfn> of type <span class=
            "idlAttrType"><a>DOMTimeStamp</a></span>, readonly</dt>
            <dd>
              <p>The <code>expires</code> attribute indicates the date and time in
              milliseconds relative to 1970-01-01T00:00:00Z after which the certificate
              will be considered invalid by the browser. After this time, attempts to
              construct an object using this certificate will fail.</p>
              <p>Note that this value might not be reflected in a <code>notAfter</code>
              parameter in the certificate itself.</p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCCertificate" data-dfn-for="RTCCertificate" class=
          "methods">
            <dt><dfn><code>getSupportedAlgorithms</code></dfn></dt>
            <dd>
                <p>Returns a sequence providing a representative set of supported
                certificate algorithms. At least one algorithm MUST be returned.</p>
                <div class="note">
                  <p>For example, the "RSASSA-PKCS1-v1_5" algorithm dictionary,
                  <code>RsaHashedKeyGenParams</code>, contains fields for the modulus
                  length, public exponent, and hash algorithm. Implementations
                  are likely to support a wide range of modulus lengths and exponents,
                  but a finite number of hash algorithms. So in this case, it would be
                  reasonable for the implementation to return one
                  <code>AlgorithmIdentifier</code> for each supported hash algorithm
                  that can be used with RSA, using default/recommended values for
                  <code>modulusLength</code> and <code>publicExponent</code>
                  (such as 1024 and 65537, respectively).</p>
                </div>
                <div>
                  <em>No parameters.</em>
                </div>
                <div>
                  <em>Return type:</em>
                  sequence&lt;<code>AlgorithmIdentifier</code>&gt
                </div>
            </dd>
            <dt><dfn><code>getFingerprints</code></dfn></dt>
            <dd>
                <p>Returns the list of certificate fingerprints, one of which is
                computed with the digest algorithm used in the certificate
                signature.</p>
                <div>
                  <em>No parameters.</em>
                </div>
                <div>
                  <em>Return type:</em>
                  sequence&lt;<code><a>RTCDtlsFingerprint</a></code>&gt
              </div>
            </dd>
            <dt><dfn><code>generateCertificate</code></dfn>, static</dt>
            <dd>
              <p>The <code>generateCertificate</code> method causes the <a class=
              "internalDFN" href="#dfn-user-agent">user agent</a> to create and store an
              X.509 certificate [[!X509V3]] and corresponding private key. A handle to
              information is provided in the form of the
              <code><a>RTCCertificate</a></code> interface. The returned
              <code><a>RTCCertificate</a></code> can be used to control the certificates
              that are offered in DTLS or QUIC.</p>
              <p>The <code>keygenAlgorithm</code> argument is used to control how the
              private key associated with the certificate is generated. The
              <code>keygenAlgorithm</code> argument uses the WebCrypto [[!WebCryptoAPI]]
              <a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-AlgorithmIdentifier">
              AlgorithmIdentifier</a> type. The <code>keygenAlgorithm</code> value
              <em title="MUST" class="rfc2119">MUST</em> be a valid argument to <a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#SubtleCrypto-method-generateKey">
              <code>window.crypto.subtle.generateKey</code></a>; that is, the value
              <em title="MUST" class="rfc2119">MUST</em> produce a non-error result when
              normalized according to the WebCrypto <a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#algorithm-normalization">
              algorithm normalization process</a> [[!WebCryptoAPI]] with an operation
              name of <code>generateKey</code> and a [[<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-supportedAlgorithms">supportedAlgorithms</a>]]
              value specific to production of certificates for
              <code><a>RTCDtlsTransport</a></code>. If the algorithm normalization
              process produces an error, the call to <code>generateCertificate()</code>
              <em title="MUST" class="rfc2119">MUST</em> be <a>rejected</a> with that error.</p>
              <p>Signatures produced by the generated key are used to authenticate the
              DTLS or QUIC connection. The identified algorithm (as identified by the
              <code>name</code> of the normalized <code>AlgorithmIdentifier</code>)
              <em title="MUST" class="rfc2119">MUST</em> be an asymmetric algorithm that
              can be used to produce a signature.</p>
              <p>The certificate produced by this process also contains a signature. The
              validity of this signature is only relevant for compatibility reasons. Only
              the public key and the resulting certificate fingerprint are used by
              <code><a>RTCDtlsTransport</a></code> or <code><a>RTCQuicTransport</a></code>,
              but it is more likely that a certificate will be accepted if the certificate
              is well formed. The browser selects the algorithm used to sign the certificate;
              a browser <em title="SHOULD" class="rfc2119">SHOULD</em> select
              SHA-256 [[!FIPS-180-4]] if a hash algorithm is needed.</p>
              <p>The resulting certificate <em title="MUST NOT" class="rfc2119">MUST
              NOT</em> include information that can be linked to a user or <a class=
              "internalDFN" href="#dfn-user-agent">user agent</a>. Randomized values for
              distinguished name and serial number <em title="SHOULD" class=
              "rfc2119">SHOULD</em> be used.</p>
              <p>An optional <code>expires</code> attribute <em title="MAY" class=
              "rfc2119">MAY</em> be added to the <var>keygenAlgorithm</var> parameter. If
              this contains a <code><a>DOMTimeStamp</a></code> value, it indicates the
              maximum time that the <code><a>RTCCertificate</a></code> is valid for
              relative to the current time. A <a>user agent</a> sets the <code><a href=
              "#widl-RTCCertificate-expires">expires</a></code> attribute of the returned
              <code><a>RTCCertificate</a></code> to the current time plus the value of
              the <code>expires</code> attribute. However, a <a>user agent</a> MAY choose
              to limit the period over which an <code><a>RTCCertificate</a></code> is
              valid.</p>
              <p>A <a class="internalDFN" href="#dfn-user-agent">user agent</a>
              <em title="MUST" class="rfc2119">MUST</em> <a>reject</a> a call to
              <code>generateCertificate()</code> with a <code>DOMError</code> of type
              "NotSupportedError" if the <var>keygenAlgorithm</var> parameter identifies
              an algorithm that the <a class="internalDFN" href="#dfn-user-agent">user
              agent</a> cannot or will not use to generate a certificate for
              <code><a>RTCDtlsTransport</a></code>.</p>
              <p>The following values <em title="MUST" class="rfc2119">MUST</em> be
              supported by a <a class="internalDFN" href="#dfn-user-agent">user
              agent</a>: <code>{ name: "<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#rsassa-pkcs1">RSASSA-PKCS1-v1_5</a>",
              modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash:
              "SHA-256" }</code>, and <code>{ name: "<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#ecdsa">ECDSA</a>",
              namedCurve: "<a href=
              "https://dvcs.w3.org/hg/webcrypto-api/raw-file/tip/spec/Overview.html#dfn-NamedCurve">P-256</a>"
              }</code>.</p>
              <p>It is expected that a <a class="internalDFN" href="#dfn-user-agent">user
              agent</a> will have a small or even fixed set of values that it will
              accept.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">keygenAlgorithm</td>
                    <td class="prmType"><code><a>AlgorithmIdentifier</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em>
                <code>Promise</code>&lt;<code><a>RTCCertificate</a></code>&gt;
              </div>
            </dd>
          </dl>
        </section>
      </div>
        <p>For the purposes of this API, the <a>[[\Certificate]]</a> slot
        contains unstructured binary data. No mechanism is provided for
        applications to access the <a>[[\KeyingMaterial]]</a> internal slot.
        Implementations MUST support applications storing and retrieving
        <code>RTCCertificate</code> objects from persistent storage.
        In implementations where an <code>RTCCertificate</code> might not
        directly hold private keying material (it might be stored in a
        secure module), a reference to the private key can be held in
        the <a>[[\KeyingMaterial]]</a> internal slot, allowing the
        private key to be stored and used.</p>
        <p>When a <a>user agent</a> is required to obtain a structured
        clone [[!HTML51]] of an <code>RTCCertificate</code> object,
        it performs the following steps:</p>
        <ol>
          <li>Let <var>input</var> and <var>memory</var> be the corresponding
          inputs defined by the internal structured cloning algorithm, where
          <var>input</var> represents an <code>RTCCertificate</code> object to
          be cloned.</li>
          <li>Let <var>output</var> be a newly constructed
          <code>RTCCertificate</code> object.</li>
          <li>Copy the value of the <code>expires</code> attribute from
          <var>input</var> to <var>output</var>.</li>
          <li>Let the <a>[[\Certificate]]</a> internal slot of <var>output</var>
          be set to the result of invoking the internal structured clone
          algorithm recursively on the corresponding internal slots of
          <var>input</var>, with the slot contents as the new
          "<var>input</var>" argument and <var>memory</var> as the new
          "<var>memory</var>" argument.
          </li>
          <li>Let the <a>[[\KeyingMaterial]]</a> internal slot of <var>output</var>
          refer to the same private keying material represented by the
          <a>[[\KeyingMaterial]]</a> internal slot of <var>input</var>.
          </li>
        </ol>
    </section>
  </section>
    <section id="privacy-security">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification. The overall security considerations of the
    APIs and protocols used in ORTC are described in
    [[RTCWEB-SECURITY-ARCH]].</p>
    <section>
      <h2>Impact on same origin policy</h2>
      <p>The ORTC API enables real-time communication between
      browsers and other devices, including other browsers.</p>
      <p>This means that data and media can be shared between applications
      running in different browsers, or between an application running in the
      same browser and something that is not a browser.  This is an extension
      to the Web model which has had barriers against sending data
      between entities with different origins.</p>
      <p>The ORTC specification provides no user prompts or chrome indicators
      for communication; it assumes that once the Web page has been allowed to
      access media, it is free to share that media with other entities as it
      chooses. Peer-to-peer exchanges of data via datachannels can therefore
      occur without any user explicit consent or involvement. Similarly, a
      server-mediated exchange (e.g. via Web Sockets) could occur without user
      involvement.</p>
      <p>The <code>peerIdentity</code> mechanism loads and executes
      JavaScript code from a third-party server acting as an identity provider.
      That code is executed in a separate JavaScript realm and does not affect
      the protections afforded by the same origin policy.</p>
    </section>
    <section>
      <h2>Revealing IP addresses</h2>
      <p>Even without ORTC, the Web server providing a Web application will
      know the public IP address to which the application is delivered. Setting
      up communications exposes additional information about the
      browser&#8217;s network context to the web application, and may include
      the set of (possibly private) IP addresses available to the browser for
      WebRTC use. Some of this information has to be passed to the
      corresponding party to enable the establishment of a communication
      session.</p>
      <p>Revealing IP addresses can leak location and means of connection; this
      can be sensitive. Depending on the network environment, it can also
      increase the fingerprinting surface and create persistent cross-origin
      state that cannot easily be cleared by the user.</p>
      <p>A connection will always reveal the IP addresses proposed for
      communication to the corresponding party. The application can limit this
      exposure by choosing not to use certain addresses using the settings
      exposed by the <code><a>RTCIceGatherPolicy</a></code> dictionary, and by using
      relays (for instance TURN servers) rather than direct connections between
      participants. One will normally assume that the IP address of TURN
      servers is not sensitive information. These choices can for instance be
      made by the application based on whether the user has indicated consent
      to start a media connection with the other party.</p>
      <p>Mitigating the exposure of IP addresses to the application itself
      requires limiting the IP addresses that can be used, which will impact
      the ability to communicate on the most direct path between endpoints.
      Browsers are encouraged to provide appropriate controls for deciding
      which IP addresses are made available to applications, based on the
      security posture desired by the user. The choice of which addresses to
      expose is controlled by local policy (see [[RTCWEB-IP-HANDLING]] for
      details).</p>
    </section>
    <section>
      <h2>Impact on local network</h2>
      <p>Since the browser is an active platform executing in a trusted network
      environment (inside the firewall), it is important to limit the damage
      that the browser can do to other elements on the local network, and it is
      important to protect data from interception, manipulation and
      modification by untrusted participants.</p>
      <p>Mitigations include:</p>
      <ul>
        <li>An UA will always request permission from the correspondent UA to
        communicate using ICE. This ensures that the UA can only send to
        partners who you have shared credentials with.</li>
        <li>An UA will always request ongoing permission to continue sending
        using ICE consent [[!RFC7675]]. This enables a receiver to withdraw
        consent to receive.</li>
        <li>An UA will always encrypt data, with strong per-session keying
        (DTLS-SRTP).</li>
        <li>An UA will always use congestion control. This ensures that ORTC
        cannot be used to flood the network.</li>
      </ul>
      <p>These measures are specified in the relevant IETF documents.</p>
    </section>
    <section>
      <h2>Confidentiality of Communications</h2>
      <p>The fact that communication is taking place cannot be hidden from
      adversaries that can observe the network, so this has to be regarded as
      public information.</p>
      <p>A mechanism, <code>peerIdentity</code>, is provided that gives
      Javascript the option of requesting media that the same javascript cannot
      access, but can only be sent to certain other entities.</p>
    </section>
    <section>
      <h2>Persistent information</h2>
      <p>As described above, the list of IP addresses exposed by the ORTC API
      can be used as a persistent cross-origin state.</p>
      <p>Beyond IP addresses, the ORTC API exposes information about the
      underlying media system via the <code>RTCRtpSender.getCapabilities</code>
      and <code>RTCRtpReceiver.getCapabilities</code> methods, including
      detailed and ordered information about the codecs that the system is able
      to produce and consume.
      That information is in most cases persistent across time
      and origins, and increases the fingerprint surface of a given device.</p>
      <p>When establishing DTLS connections, the ORTC API can generate
      certificates that can be persisted by the application (e.g. in
      IndexedDB). These certificates are not shared across origins, and get
      cleared when persistent storage is cleared for the origin.</p>
    </section>
  </section>
  <section class="informative">
    <h2>Event summary</h2>
    <p>The following events fire on <code><a>RTCIceGatherer</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn><code>icecandidateerror</code></dfn></td>
          <td><code><a>RTCIceGathererIceErrorEvent</a></code></td>
          <td>The <code><a>RTCIceGatherer</a></code> object has experienced an ICE
          gathering failure (such as an authentication failure with TURN
          credentials).</td>
        </tr>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceGathererState</a></code> changed.</td>
        </tr>
        <tr>
          <td><code>icecandidate</code></td>
          <td><code><a>RTCIceGatherer</a></code></td>
          <td>A new <code><a>RTCIceGatherCandidate</a></code> is made available to the
          script.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCIceTransport</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCIceTransportState</a></code> changed.</td>
        </tr>
        <tr>
          <td><code>icecandidatepairchange</code></td>
          <td><code><a>RTCIceCandidatePairChangedEvent</a></code></td>
          <td>The selected <code><a>RTCIceCandidatePair</a></code> changed.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCDtlsTransport</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>The <code><a>RTCDtlsTransport</a></code> object has received a DTLS
          Alert.</td>
        </tr>
        <tr>
          <td><dfn><code>statechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCDtlsTransportState</a></code> changed.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCRtpSender</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-ssrcconflict"><code>ssrcconflict</code></dfn></td>
          <td><code><a>RTCSsrcConflictEvent</a></code></td>
          <td>An SSRC conflict has been detected within the RTP session.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCRtpListener</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id=
          "event-RTCRtpListener-unhandledrtp"><code>unhandledrtp</code></dfn></td>
          <td><code><a>RTCRtpUnhandledEvent</a></code></td>
          <td>The <code><a>RTCRtpListener</a></code> object has received an RTP packet
          that it cannot deliver to an <code><a>RTCRtpReceiver</a></code> object.</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCDTMFSender</a></code>
    and <code><a>RTCDtmfSender</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-RTCDTMFSender-tonechange"><code>tonechange</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCDtmfSender</a></code> object has either just begun playout
          of a tone (returned as the <code>tone</code> attribute) or just ended playout
          of a tone (returned as an empty value in the <code>tone</code> attribute).</td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCDataChannel</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-datachannel-open"><code>open</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data
            transport</a> has been established (or re-established).
          </td>
        </tr>
        <tr>
          <td><dfn id="event-datachannel-message"><code>message</code></dfn></td>
          <td><code><a href=
          "http://www.w3.org/TR/webmessaging/#the-messageevent-interfaces">MessageEvent</a></code>
          [[!webmessaging]]</td>
          <td>A message was successfully received.</td>
        </tr>
        <tr>
          <td><dfn id=
          "event-datachannel-bufferedamountlow"><code>bufferedamountlow</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCDataChannel</a></code> object's <code><a href=
          "#dom-datachannel-bufferedamount">bufferedAmount</a></code> decreases from
          above its <code><a href=
          "#dom-datachannel-bufferedamountlowthreshold">bufferedAmountLowThreshold</a></code>
          to less than or equal to its <code><a href=
          "#dom-datachannel-bufferedamountlowthreshold">bufferedAmountLowThreshold</a></code>.</td>
        </tr>
        <tr>
          <td><dfn id="event-datachannel-error"><code>error</code></dfn></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>An error has been detected within the <code><a>RTCDataChannel</a></code>
          object. This is not used for programmatic exceptions.</td>
        </tr>
        <tr>
          <td><dfn id="event-datachannel-close"><code>close</code></dfn></td>
          <td><code><a>Event</a></code></td>
          <td>
            The <code><a>RTCDataChannel</a></code> object's <a>underlying data
            transport</a> has been closed.
          </td>
        </tr>
      </tbody>
    </table>
    <p>The following events fire on <code><a>RTCSctpTransport</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><dfn id="event-datachannel"><code>datachannel</code></dfn></td>
          <td><code><a>RTCDataChannelEvent</a></code></td>
          <td>A new <code><a>RTCDataChannel</a></code> is dispatched to the script in
          response to the other peer creating a channel.</td>
        </tr>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCSctpTransportState</a></code> changed.</td>
        </tr>
      </tbody>
    </table>
  </section>
  <section class="informative" id="webrtc-compat*">
    <h2>WebRTC 1.0 Compatibility</h2>
    <p>It is a goal of the ORTC API to provide the functionality of the WebRTC 1.0 API
    [[!WEBRTC10]], as well as to enable the WebRTC 1.0 API to be implemented on top of
    the ORTC API, utilizing a Javascript "shim" library. This section discusses WebRTC
    1.0 compatibility issues that have been encountered by ORTC API implementers.</p>
    <section id="spelling*">
      <h3>replaceTrack/setTrack</h3>
      <p>WebRTC 1.0 supports the <code>replaceTrack</code> method,
      whereas ORTC originally supported the <code>setTrack</code> method.
      In order to provide backward compatibility, this specification has
      added <code>replaceTrack</code> as an alias for <code>setTrack</code>.</p>
    </section>
    <section id="dtmfcompat">
      <h3>RTCDTMFSender/RTCDtmfSender</h3>
      <p>WebRTC 1.0 supports the <code>RTCDTMFSender</code> interface,
      whereas ORTC originally supported the <code>RTCDtmfSender</code>
      interface. In order to provide backward compatibility, this specification
      has added support for the <code>RTCDTMFSender</code> interface.</p>
      <p>In WebRTC 1.0 the <code>RTCDTMFSender</code> is an extension of
      <code>RTCRtpSender</code> whereas in ORTC it is created with an
      <code>RTCRtpSender</code>. The WebRTC 1.0 behaviour can be emulated by
      providing a getter for <code>RTCRtpSender</code>.<var>dtmf</var> attribute.
    </section>
    <section id="bundle*">
      <h3>BUNDLE</h3>
      <p>Via the use of [[!BUNDLE]] it is possible for WebRTC 1.0 implementations to
      multiplex audio and video on the same RTP session. Within ORTC API, equivalent
      behavior can be obtained by constructing multiple
      <code><a>RTCRtpReceiver</a></code> and <code><a>RTCRtpSender</a></code> objects
      from the same <code><a>RTCDtlsTransport</a></code> object. As noted in
      [[!RTP-USAGE]] Section 4.4, support for audio/video multiplexing is required, as
      described in [[!RTP-MULTI-STREAM]].</p>
    </section>
    <section id="voice-activity*">
      <h3>Voice Activity Detection</h3>
      <p>[[!WEBRTC10]] Section 4.2.4 defines the <code>RTCOfferOptions</code> dictionary,
      which includes the <code>voiceActivityDetection</code> attribute, which determines
      whether Voice Activity Detection (VAD) is enabled within the Offer produced by
      <code>createOffer()</code>. The effect of setting
      <code>voiceActivityDetection</code> to <code>true</code> is to include the Comfort
      Noice (CN) codec defined in [[!RFC3389]] within the Offer.</p>
      <p>Within ORTC API, equivalent behavior can be obtained by configuring the Comfort
      Noise (CN) codec for use within <code>RTCRtpParameters</code>, and/or configuring a
      codec with built-in support for Discontinuous Operation (DTX), such as Opus. As
      noted in [[!RFC7874]] Section 3, support for CN is required.</p>
    </section>
    <section id="h264*">
      <h3>H.264/AVC</h3>
      <p>[[RFC6184]] Section 8.1 defines the <code>level-asymmetry-allowed</code> SDP
      parameter supported by some WebRTC 1.0 API implementations. Within ORTC API, the
      <code>profile-level-id</code> capability is supported for both the
      <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code>, and the
      <code>profile-level-id</code> setting is provided for the
      <code><a>RTCRtpSender</a></code>. Since in ORTC API sender and receiver
      <code>profile-level-id</code> capabilities are independent and there is no
      <code>profile-level-id</code> setting for an <code><a>RTCRtpReceiver</a></code>, ORTC
      API assumes that implementations support level asymmetry. Therefore a WebRTC 1.0
      API shim library for ORTC API should provide a <code>level-asymmetry-allowed</code>
      value of <code>1</code>.</p>
    </section>
    <section id="nonmux-identity*">
      <h3>Identity and non-multiplexed RTP/RTCP</h3>
      <p>Where RTP and RTCP are not multiplexed, distinct
      <code><a>RTCIceTransport</a></code>, <code><a>RTCDtlsTransport</a></code> and
      <code><a>RTCIdentity</a></code> objects can be constructed for RTP and RTCP. While
      it is possible for <code>getIdentityAssertion</code>() to be called with different
      values of <code>provider</code>, <code>protocol</code> and <code>username</code>
      for the RTP and RTCP <code><a>RTCIdentity</a></code> objects, application
      developers desiring backward compatibility with WebRTC 1.0 are strongly discouraged
      from doing so, since this is likely to result in an error.</p>
      <p>Also, where RTP and RTCP are not multiplexed, it is possible that the assertions
      for both the RTP and RTCP will be validated, but that the identities will not be
      equivalent. Applications requiring backward compatibility with WebRTC 1.0 are
      advised to consider this an error. However, if backward compatibility with WebRTC
      1.0 is not required the application can consider an alternative, such as ignoring
      the RTCP identity assertion.</p>
    </section>
  </section>
  <section id="examples*">
    <h2>Examples</h2>
    <section class="informative" id="simple-peer-to-peer-example*">
      <h3>Simple Peer-to-peer Example</h3>
      <p>This example code provides a basic audio and video session between two
      browsers.</p>
      <pre class="example"></pre>
    </section>
    <section class="informative" id="rtcquicexample*">
      <h2>QUIC Examples</h2>
      <p>This example shows how an <code><a>RTCQuicTransport</a></code> can be established
      between browsers.</p>
      <pre class="example highlight">
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

function initiate(mySignaller) {
  // Prepare the IceGatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  // Handle state changes
  iceGatherer.onstatechange = function(event) {
    myIceGathererStateChange("iceGatherer", event.state);
  };
  // Handle errors
  iceGatherer.onerror = errorHandler;
  // Prepare to signal local candidates
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

  // Start gathering
  iceGatherer.gather();
  // Create the IceTransport
  var ice = new RTCIceTransport(iceGatherer);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };

  // Create the certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create the DtlsTransport and QuicTransport
  var dlts = new RTCDtlsTransport(ice, certs);
  var quic = new RTCQuicTransport(ice, certs);

  mySignaller.sendInitiate({
    ice: iceGatherer.getLocalParameters(),
    dlts: dtls.getLocalParameters(),
    quic: quic.getLocalParameters(),
    // ... marshall RtpSender/RtpReceiver capabilities as in Section 6.6 Examples 8 and 9.
  }, function(remote) {
    // Start the IceTransport, DtlsTransport and QuicTransport
    ice.start(iceGatherer, remote.ice, RTCIceRole.controlling);
    dtls.start(remote.dtls);
    quic.start(remote.quic);
    // ... configure RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.
  });
}
</pre>
<pre class="example highlight">
// This is an example of how to answer
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

function accept(mySignaller, remote) {
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  // Handle state changes
  iceGatherer.onstatechange = function(event) {
    myIceGathererStateChange("iceGatherer", event.state);
  };
  // Handle errors
  iceGatherer.onerror = errorHandler;
  // Prepare to signal local candidates
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

   // Start gathering
  iceGatherer.gather();
  // Create the IceTransport
  var ice = new RTCIceTransport(iceGatherer);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };

   // Create the certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create the DtlsTransport and QuicTransport
  var dtls = new RTCDtlsTransport(ice, certs);
  var quic = new RTCQuicTransport(ice, certs);

  mySignaller.sendAccept({
    ice: iceGatherer.getLocalParameters(),
    dtls: dtls.getLocalParameters(),
    quic: quic.getLocalParameters(),
    // ... marshall RtpSender/RtpReceiver capabilities as in Section 6.6 Examples 8 and 9.
  });

   // Start the IceTransport and DtlsTransport
  ice.start(iceGatherer, remote.ice, RTCIceRole.controlled);
  dtls.start(remote.dtls);
  // Start the QuicTransport
  quic.start(remote.quic);

  // ... configure RtpSender/RtpReceiver objects as in Section 6.6 Examples 8 and 9.

}
                </pre>
    </section>
    <section class="informative" id="js-library-example*">
      <h3>Determining common capabilities</h3>
      <p>Several of the examples reference <dfn>myCapsToSendParams</dfn>, which 
      returns sender parameters based on the intersection of the capabilities of
      the <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code>.
      This section provides an example of what such a library
      function might do.</p>
      <pre class="example highlight">
RTCRtpCapabilities function getCommonCapabilities(RTCRtpCapabilities 
   localCapabilities, RTCRtpCapabilities remoteCapabilities) {
// Function returning the common capabilities, based on the local sender and
// remote receiver capabilities. An implementation is available here:
// https://webrtc.github.io/adapter/adapter-latest.js
//
// Steps to determine the common capabilities of the local sender and
// remote receiver:
// 1. Determine the common codecs.
// 2. For each common codec, determine the common headerExtensions and
//    rtcpFeedback mechanisms.
// 3. For each common audio codec, determine:
//    a. For channels, the minimum of the local and remote values.
//    b. For maxptime, the minimum of the local and remote maxptime.
//    c. For ptime, the remote ptime if it is less than the computed maxptime
//       in step b); otherwise choose the local ptime.
// 4. For each common codec, determine the common parameters, such as:
//    a. For H.264/AVC, the minimum of the local and remote
//       profile-level-id (the packetization-mode must match for it
//       to be considered a common codec).
//    b. For Opus, usedtx and useinbandfec set to one if both sides
//       support that, otherwise zero.
// 5. Determine the common robustness (forward error correction and 
//    retransmission) mechanisms.
// 6. Determine the payloadType to be used, based on the remote
//    preferredPayloadType.
}

RTCRtpSendParameters function myCapsToSendParams(RTCRtpCapabilities sendCaps,
   RTCRtpCapabilities remoteRecvCaps) {
// Find the common capabilities
   var commonCaps = getCommonCapabilities(sendCaps, remoteRecvCaps); 
// Use the common capabilities to build the RTCRtpSendParameters
// 1. Populate the codecs list
// 2. Populate the headerExtensions
// 3. Set RTCRtcpParameters to their default values.
// 4. Return RTCRtpSendParameters enabling the jointly supported features
//    and codecs.
   var sendParams = {};
// Populate the codecs list and header extensions
   sendParams.codecs = commonCaps.codecs;
   sendParams.headerExtensions = commonCaps.headerExtensions;
   sendParams.rtcp = {reducedSize: false, mux: true};
// Do not set any encodings
   sendParams.encodings = {};
// Set degradationPreference to its default value
   sendParams.degradationPreference = "balanced";
   return sendParams;
}

RTCRtpReceiveParameters function myCapsToRecvParams(RTCRtpCapabilities recvCaps,
   RTCRtpCapabilities remoteSendCaps) {
// Find the common capabilities
   var commonCaps = getCommonCapabilities(remoteSendCaps, recvCaps);
// Use the common capabilities to build the RTCRtpReceiveParameters
// 1. Populate the codecs list
// 2. Populate the headerExtensions
// 3 Set RTCRtcpParameters to their default values.
// 4. Return RTCRtpReceiveParameters enabling the jointly supported features
//    and codecs.
   var receiveParams = {};
// Populate the codecs list and headerExtensions
   receiveParams.codecs = commonCaps.codecs;
   receiveParams.headerExtensions = commonCaps.headerExtensions;
   receiveParams.rtcp = {reducedSize: false, mux: true};
// Do not set any encodings
   receiveParams.encodings = {};
   return receiveParams;
}
            </pre>
    </section>
  </section>
  <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>The editor wishes to thank Erik Lagerway (former Chair of the ORTC CG and Co-chair
    of the WEBRTC WG) for his support. Substantial text in this specification was provided by
    many people including Peter Thatcher, Martin Thomson, Iñaki Baz Castillo,
    Jose Luis Millan, Christoph Dorn, Roman Shpount, Emil Ivov, Shijun Sun and Jason
    Ausborn. Special thanks to Peter Thatcher for his design contributions relating to
    many of the objects in the current specification, and to Philipp Hancke, Lennart Grahl,
    Jxck and Iñaki Baz Castillo for their detailed review.</p>
  </section>
  <section id="change-log*">
    <h2>Change Log</h2>
    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->
    <section id="since-01-February-2018*">
      <h3>Changes since 01 February 2018</h3>
      <ol>
        <li>Update finding common capabilities example, as noted in:
        <a href="https://github.com/w3c/ortc/issues/569">Issue 569</a>
        </li>
        <li>Add checks for header extension conflicts, as noted in:
        <a href="https://github.com/w3c/ortc/issues/803">Issue 803</a>
        </li>
        <li>Update <code>RTCIdentity</code> (now in Section 14) to reference [[WEBRTC-IDENTITY]], as noted in:
        <a href="https://github.com/w3c/ortc/issues/813">Issue 813</a>
        </li>
        <li>Update the <code><a>RTCDataChannel</a></code> interface to match WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/817">Issue 817</a>
        </li>
        <li>Update the <code><a>RTCSctpTransport</a></code> interface to match WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/820">Issue 820</a>
        </li>
        <li>Clarify the operation of the <code>RTCCertificate</code> keying material internal slot, as noted in:
        <a href="https://github.com/w3c/ortc/issues/832">Issue 832</a>
        </li>
        <li>Update mandatory-to-implement statistics, as noted in:
        <a href="https://github.com/w3c/ortc/issues/833">Issue 833</a>
        </li>
        <li>Separate <code><a>RTCRtpSendParameters</a></code> and <code><a>RTCRtpReceiveParameters</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/835">Issue 835</a>
        </li>
        <li>Remove Section 13 (<code><a>RTCQuicTransport</a></code>) and Section 14 (<code><a>RTCQuicStream</a></code>),
        and reference [[WEBRTC-QUIC]], as noted in:
        <a href="https://github.com/w3c/ortc/issues/853">Issue 853</a>
        </li>
        <li>Update RID usage in examples, as noted in:
        <a href="https://github.com/w3c/ortc/issues/865">Issue 865</a>
        </li>
      </ol>
    </section>
    <section id="since-22-September-2017*">
      <h3>Changes since 22 September 2017</h3>
      <ol>
        <li>Add error checks in <code>send</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/473">Issue 473</a>
        </li>
        <li>Support <code>priority</code> in <code><a>RTCDataChannel</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/623">Issue 623</a>
        </li>
        <li>Fix issues with <code>maxMessageSize</code> in <code><a>RTCSctpCapabilities</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/626">Issue 626</a>
        </li>
        <li>Clarify handling of unsupported fingerprint algorithms, as noted in:
        <a href="https://github.com/w3c/ortc/issues/752">Issue 752</a>
        </li>
        <li>Add [Exposed] to interfaces, as noted in:
        <a href="https://github.com/w3c/ortc/issues/766">Issue 766</a>
        </li>
        <li>Clarify operation of the <code><a>RTCRtpSender</a></code> and <code><a>RTCRtpReceiver</a></code> constructor, as noted in:
        <a href="https://github.com/w3c/ortc/issues/778">Issue 778</a>
        </li>
        <li>Clarify definition of <code>RTCQuicStreamState</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/788">Issue 788</a>
        </li>
        <li>Reference WebRTC 1.0 for definitions of <code><a>RTCIceCredentialType</a></code>
        and <code><a>RTCOauthCredential</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/792">Issue 792</a>
        </li>
        <li>Allow construction of an <code><a>RTCRtpReceiver</a></code> object without a transport, as noted in:
        <a href="https://github.com/w3c/ortc/issues/801">Issue 801</a>
        </li>
        <li>Clarify <code>track.muted</code> default in <code><a>RTCRtpReceiver</a></code> constructor, as noted in:
        <a href="https://github.com/w3c/ortc/issues/807">Issue 807</a>
        </li>
        <li>Allow null transport argument to <code>setTransport</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/808">Issue 808</a>
        </li>                
        <li>Update the <code><a>RTCRtpContributingSource</a></code> and <code><a>RTCRtpSynchronizationSource</a></code>
        dictionaries to match WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/809">Issue 809</a></li>
        </li>
        <li>Update the <code>RTCCertificate</code> interface to match WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/812">Issue 812</a>
        </li>
      </ol>
      </section>
      <section id="since-01-May-2017*">
      <h3>Changes since 01 May 2017</h3>
      <ol>
        <li>Add checks in the <code>send</code> method, as noted in:
        <a href="https://github.com/w3c/ortc/issues/564">Issue 564</a>
        </li>
        <li>Add support for reliable QUIC data exchange, as noted in:
        <a href="https://github.com/w3c/ortc/issues/584">Issue 584</a>
        </li>
        <li>Add a compliance section, as noted in:
        <a href="https://github.com/w3c/ortc/issues/586">Issue 586</a>
        </li>
        <li>Change type of <code>maxFramerate</code> to double, as noted in:
        <a href="https://github.com/w3c/ortc/issues/687">Issue 687</a>
        </li>
         <li>Change codec parameter names from camelCase to SDP-style names, as noted in:
        <a href="https://github.com/w3c/ortc/issues/689">Issue 689</a>
        </li>
        <li>Clarify operation of <code><a>RTCDtlsTransport</a>.getLocalParameters</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/690">Issue 690</a>
        </li>
        <li>Reference WebIDL definition of ArrayBuffer, as noted in:
        <a href="https://github.com/w3c/ortc/issues/692">Issue 692</a>
        </li>
        <li>Define <code>getCertificates()</code> method and remove <code>certificates</code> attribute, as noted in:
        <a href="https://github.com/w3c/ortc/issues/696">Issue 696</a>
        </li>
        <li>Clarify sender settings for "flexfec", as noted in:
        <a href="https://github.com/w3c/ortc/issues/698">Issue 698</a>
        </li>
        <li>Add a Privacy and Security section, as noted in:
        <a href="https://github.com/w3c/ortc/issues/705">Issue 705</a>
        </li>
        <li>Mark <code>getAlgorithm</code> as a "feature at risk", as noted in:
        <a href="https://github.com/w3c/ortc/issues/707">Issue 707</a>
        </li>
        <li>Mark the QoS/Priority API as a "feature at risk", as noted in:
        <a href="https://github.com/w3c/ortc/issues/708">Issue 708</a>
        </li>
        <li>Add validation steps in the <code>RTCDataChannel</code> constructor, as noted in:
        <a href="https://github.com/w3c/ortc/issues/717">Issue 717</a>
        </li>
        <li>Update contributing and synchronization sources for compatibility with WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/718">Issue 718</a>
        </li>
        <li>Update DTMF support for compatibility with WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/719">Issue 719</a>
        </li>
        <li>Synchronize with WebRTC 1.0 changes to ICE, as noted in:
        <a href="https://github.com/w3c/ortc/issues/720">Issue 720</a>
        </li>
        <li>Clarify key shortening behavior with use of OAuth credentials, as noted in:
        <a href="https://github.com/w3c/ortc/issues/721">Issue 721</a>
        </li>
        <li>Enable <code>setTrack</code>/<code>replaceTrack</code> argument to be <code>null</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/722">Issue 722</a>
        </li>
        <li>Update with WebRTC 1.0 changes to <code>RTCRtpParameters</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/723">Issue 723</a>
        </li>
        <li>Add support for DTLS error reporting, as noted in:
        <a href="https://github.com/w3c/ortc/issues/724">Issue 724</a>
        </li>
        <li>Fix race conditions in the DTMF examples, as noted in:
        <a href="https://github.com/w3c/ortc/issues/732">Issue 732</a>
        </li>
        <li>Change <code>numChannels</code> to <code>channels</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/738">Issue 738</a>
        </li>
        <li>Clarify behavior of <code>getCapabilities</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/740">Issue 740</a>
        </li>
        <li>Remove the <code>nohost</code> gathering policy, as noted in:
        <a href="https://github.com/w3c/ortc/issues/742">Issue 742</a>
        </li>
        <li>Add support for the <code>getDefaultIceServers</code> method, as noted in:
        <a href="https://github.com/w3c/ortc/issues/743">Issue 743</a>
        </li>
        <li>Update <code>RTCStatsType</code> values based on WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/745">Issue 745</a>
        </li>
        <li>Add validation steps in the <code><a>RTCIceGatherer</a></code> constructor, as noted in:
        <a href="https://github.com/w3c/ortc/issues/748">Issue 748</a>
        </li>
      </ol>
    </section>
    <section id="since-02-December-2016*">
      <h3>Changes since 02 December 2016</h3>
      <ol>
        <li>Updated the RTP matching rules (Section 6.5) to address issues
        <a href="https://github.com/w3c/ortc/issues/368">Issue 368</a> and
        <a href="https://github.com/w3c/ortc/issues/547">Issue 547</a>.
        </li>
        <li>Clarified handling of H.264 packetizationMode in <code>RTCRtpCodecCapability</code>, as noted in:
          <a href="https://github.com/w3c/ortc/issues/567">Issue 567</a>
        </li>
        <li>Provided updated guidance on use of multiple encodings as noted in:
        <a href="https://github.com/w3c/ortc/issues/568">Issue 568</a>
        </li>
        <li>Added support for <code>replaceTrack</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/614">Issue 614</a>
        </li>
        <li>Updated Oauth token auth support, as noted in:
        <a href="https://github.com/w3c/ortc/issues/618">Issue 618</a>
        </li>
        <li>Enabled setting of the <code><a>RTCSctpTransport</a></code> remote port,  as noted in:
        <a href="https://github.com/w3c/ortc/issues/625">Issue 625</a>
        </li>
        <li>Changed the <code>maxMessageSize</code> attribute type to unsigned long, as noted in:
        <a href="https://github.com/w3c/ortc/issues/626">Issue 626</a>
        </li>
        <li>Clarified handling of RTX in <code><a>RTCRtpCapabilities</a>.codecs</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/627">Issue 627</a>
        </li>
        <li>Clarified <code><a>RTCSctpTransportState</a></code> definitions, as noted in:
        <a href="https://github.com/w3c/ortc/issues/635">Issue 635</a>
        </li>
        <li>Changed <code><a>RTCIceComponent</a></code> values to lower case, as noted in:
        <a href="https://github.com/w3c/ortc/issues/636">Issue 636</a>
        </li>
        <li>Described the firing of the <code>mute</code> and <code>unmute</code> events, as noted in:
        <a href="https://github.com/w3c/ortc/issues/639">Issue 639</a>
        </li>
        <li>Added optional H.264 codec settings, as noted in:
        <a href="https://github.com/w3c/ortc/issues/641">Issue 641</a>
        </li>
        <li>Updated Section 6.5.3 to refer to RTCP packet routing specification, as noted in:
        <a href="https://github.com/w3c/ortc/issues/643">Issue 643</a>
        </li>
        <li>Updated Examples 21 and 22 to reflect updated <code><a>RTCSctpTransport</a></code> API, as noted in:
        <a href="https://github.com/w3c/ortc/issues/648">Issue 648</a>
        </li>
        <li>Provided details on the operation of <code><a>RTCIceTransport</a>.stop</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/651">Issue 651</a>
        </li>
        <li>Clarified the purpose of <code>RTCRtpCodecCapabilities.fecMechanisms</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/655">Issue 655</a>
        </li>
        <li>Allowed an <code><a>RTCRtpSender</a></code> to be constructed with a <code><a>MediaStreamTrack</a></code> or <code>kind</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/656">Issue 656</a>
        </li>
        <li>Clarified when multiple <code>RTCRtpCodecCapability</code> entries are provided for the same codec, as noted in:
          <a href="https://github.com/w3c/ortc/issues/662">Issue 662</a>
        </li>
        <li>Marked Identity as a "feature at risk", as noted in:
        <a href="https://github.com/w3c/ortc/issues/668">Issue 668</a>
        </li>
        <li>Updated Statistics API to track changes to WebRTC Statistics specification, as noted in:
        <a href="https://github.com/w3c/ortc/issues/672">Issue 672</a>
        </li>
        <li>Allow construction of an <code><a>RTCRtpSender</a></code> without an RTP DtlsTransport, as noted in:
        <a href="https://github.com/w3c/ortc/issues/679">Issue 679</a>
        </li>
        <li>Clarify syntax of <code>fingerprint</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/683">Issue 683</a>
        </li>
      </ol>
    </section>
    <section id="since-20-August-2016*">
      <h3>Changes since 20 August 2016</h3>
      <ol>
        <li>Clarified operation of <code>resolutionScale</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/362">Issue 362</a>
        </li>
        <li>Clarified meaning of the <code>disconnected</code> state, as noted in:
        <a href="https://github.com/w3c/ortc/issues/565">Issue 565</a>
        </li>
        <li>Changed <code>profileLevelId</code> to a DOMString, as noted in:
        <a href="https://github.com/w3c/ortc/issues/587">Issue 587</a>
        </li>
        <li>Enabled <code>setTrack()</code> to replace a track that is "ended", as noted in:
        <a href="https://github.com/w3c/ortc/issues/589">Issue 589</a>
        </li>
        <li>Clarified operation of <code>setTransport()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/591">Issue 591</a>
        </li>
        <li>Clarified behavior of <code><a>RTCRtpReceiver</a>.stop()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/596">Issue 596</a>
        </li>
        <li>Clarified behavior of <code><a>RTCRtpSender</a>.track.stop()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/597">Issue 597</a>
        </li>
        <li>Aligned ORTC with WebRTC 1.0 DTMF API, as noted in:
        <a href="https://github.com/w3c/ortc/issues/604">Issue 604</a>
        </li>
        <li>Clarified state transitions of the <code><a>RTCIceGatherer</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/606">Issue 606</a>
        </li>
        <li>Clarified behavior of <code><a>RTCIceTransport</a>.start()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/607">Issue 607</a>
        </li>
        <li>Clarified required attributes of an <code><a>RTCIceCandidate</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/608">Issue 608</a>
        </li>
        <li>Enable <code>setTrack(null)</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/615">Issue 615</a>
        </li>
        <li>Clarified meaning of <code><var>sender</var>.track</code> set to null, as noted in:
        <a href="https://github.com/w3c/ortc/issues/616">Issue 616</a>
        </li>
      </ol>
    </section>
    <section id="since-04-May-2016*">
      <h3>Changes since 04 May 2016</h3>
      <ol>
        <li>Clarified support for simulcast reception and <code><a>MRST</a></code> SVC
        codecs, as noted in: <a href="https://github.com/w3c/ortc/issues/175">Issue
        175</a>
        </li>
        <li>Clarified handling of media prior to remote fingerprint verification, as
        noted in: <a href="https://github.com/w3c/ortc/issues/200">Issue 200</a>
        </li>
        <li>Simplified text relating to event handlers, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/309">Issue 309</a>
        </li>
        <li>Clarified meaning of
        <code><a>RTCRtpCodecCapability</a></code>.<var>options</var>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/412">Issue 412</a>
        </li>
        <li>Clarified exceptions and error conditions in the
        <code><a>RTCDtmfSender</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/446">Issue 446</a>
        </li>
        <li>Provided <code>rtcp.ssrc</code> advice for implementations, as noted in:
        <a href="https://github.com/w3c/ortc/issues/462">Issue 462</a>
        </li>
        <li>Clarified effect of <code>RTCRtpReceiver.track.stop()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/498">Issue 498</a>
        </li>
        <li>Summarized header extension parameters implementation experience, as noted in:
        <a href="https://github.com/w3c/ortc/issues/502">Issue 502</a>
        </li>
        <li>Updated text relating to consent failures, as noted in: <a href=
        "https://github.com/w3c/webrtc-pc/issues/517">Issue 517</a>
        </li>
        <li>Clarified <code>muxId</code> usage, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/528">Issue 528</a>
        </li>
        <li>Clarified meaning of <code>name</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/529">Issue 529</a>
        </li>
        <li>Updated ICE transition diagram, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/535">Issue 535</a>
        </li>
        <li>Clarified "rtx" entries in <code><a>RTCRtpCodecCapability</a></code> and
        <code><a>RTCRtpCodecParameters</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/539">Issue 539</a>
        </li>
        <li>Updated text relating to "server could not be reached", as noted in:
          <a href="https://github.com/w3c/webrtc-pc/issues/542">Issue 542</a>
        </li>
        <li>Corrected codec name usage, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/544">Issue 544</a> and <a href=
        "https://github.com/w3c/ortc/issues/548">Issue 548</a>
        </li>
        <li>Clarified that <code>codecPayloadType</code> can be unset, as noted in:
        <a href="https://github.com/w3c/ortc/issues/545">Issue 545</a>
        </li>
        <li>Converted figures to SVG format with figure/caption markup, as noted in:
        <a href="https://github.com/w3c/ortc/issues/572">Issue 572</a>
        </li>
      </ol>
    </section>
    <section id="since-01-March-2016*">
      <h3>Changes since 01 March 2016</h3>
      <ol>
        <li>Added the <code>gather()</code> method, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/165">Issue 165</a>
        </li>
        <li>Removed "public" from <code><a>RTCIceGatherPolicy</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/224">Issue 224</a>
        </li>
        <li>Removed the <code>minQuality</code> attribute, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/351">Issue 351</a>
        </li>
        <li>Made <code>send()</code> and <code>receive()</code> asynchronous, as noted
        in: <a href="https://github.com/w3c/ortc/issues/399">Issue 399</a>,
          <a href="https://github.com/w3c/ortc/issues/463">Issue 463</a>, <a href=
          "https://github.com/w3c/ortc/issues/468">Issue 468</a> and <a href=
          "https://github.com/w3c/ortc/issues/469">Issue 469</a>
        </li>
        <li>Provided additional information on ICE candidate errors, as noted in:
          <a href="https://github.com/w3c/ortc/issues/402">Issue 402</a>
        </li>
        <li>Added <code>state</code> attribute to <code><a>RTCSctpTransport</a></code>,
        as noted in: <a href="https://github.com/w3c/ortc/issues/403">Issue 403</a>
        </li>
        <li>Provided an example of RTX/RED/FEC configuration, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/404">Issue 404</a>
        </li>
        <li>Clarified <code>payloadType</code> uniqueness, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/405">Issue 405</a>
        </li>
        <li>Updated the list of header extensions, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/409">Issue 409</a>
        </li>
        <li>Added "goog-remb" to the list of feedback mechanisms, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/410">Issue 410</a>
        </li>
        <li>Added <var>kind</var> argument to the <code><a>RTCRtpReceiver</a></code>
        constructor, as noted in: <a href="https://github.com/w3c/ortc/issues/411">
          Issue 411</a>
        </li>
        <li>Clarified <code>send()</code> restrictions on <var>kind</var>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/414">Issue 414</a>
        </li>
        <li>Added <code>getAlgorithm()</code> method, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/427">Issue 427</a>
        </li>
        <li>Changed <code><a>RTCDataChannel</a></code> <var>protocol</var> and
        <var>label</var> to USVString, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/429">Issue 429</a>
        </li>
        <li>Clarified nullable attributes and methods returning empty lists, as noted in:
        <a href="https://github.com/w3c/ortc/issues/433">Issue 433</a>
        </li>
        <li>Clarified support for the "direction" parameter, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/442">Issue 442</a>
        </li>
        <li>Clarified the <var>apt</var> capability of the "red" codec, as noted in:
        <a href="https://github.com/w3c/ortc/issues/444">Issue 444</a>
        </li>
        <li>Clarified usage of <code><a>RTCRtpEncodingParameters</a></code> attributes,
        as noted in: <a href="https://github.com/w3c/ortc/issues/445">Issue 445</a>
        </li>
        <li>Clarified firing of <code>onssrcconflict</code> event, as noted in:
          <a href="https://github.com/w3c/ortc/issues/448">Issue 448</a>
        </li>
        <li>Clarified that CNAME is only set on an <code><a>RTCRtpSender</a></code>, as
        noted in: <a href="https://github.com/w3c/ortc/issues/450">Issue 450</a>
        </li>
        <li>Updated references, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/457">Issue 457</a>
        </li>
        <li>Described behavior of <code>send()</code> and <code>receive()</code> with
        unset <code><a>RTCRtpEncodingParameters</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/461">Issue 461</a>
        </li>
        <li>Corrected dictionary initialization in the examples, noted in: <a href=
        "https://github.com/w3c/ortc/issues/464">Issue 464</a> and <a href=
        "https://github.com/w3c/ortc/issues/465">Issue 465</a>
        </li>
        <li>Corrected use of enums in the examples, noted in: <a href=
        "https://github.com/w3c/ortc/issues/466">Issue 466</a>
        </li>
        <li>Clarified handling of identity constraints, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/467">Issue 467</a> and <a href=
        "https://github.com/w3c/ortc/issues/468">Issue 468</a>
        </li>
        <li>Clarified use of <code><a>RTCRtpEncodingParameters</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/470">Issue 470</a>
        </li>
        <li>Changed <var>hostCandidate</var> type, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/474">Issue 474</a>
        </li>
        <li>Renamed state change event handlers to onstatechange, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/475">Issue 475</a>
        </li>
        <li>Updated description of <code><a>RTCIceGatherer</a></code> <code>closed</code>
        state, as noted in: <a href="https://github.com/w3c/ortc/issues/476">Issue
        476</a>
        </li>
        <li>Updated description of <code><a>RTCIceTransport</a></code> object, as noted
        in: <a href="https://github.com/w3c/ortc/issues/477">Issue 477</a>
        </li>
        <li>Updated description of <code>relatedPort</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/484">Issue 484</a>
        </li>
        <li>Updated description of <code><a>RTCIceParameters</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/485">Issue 485</a>
        </li>
        <li>Clarified exceptions in <code><a>RTCDataChannel</a></code> construction, as
        noted in: <a href="https://github.com/w3c/ortc/issues/492">Issue 492</a>
        </li>
        <li>Provided a reference to <code>error.message</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/495">Issue 495</a>
        </li>
        <li>Clarified <code><a>RTCRtpReceiver</a></code> description, as noted in:
        <a href="https://github.com/w3c/ortc/issues/496">Issue 496</a>
        </li>
        <li>Clarified default for <code>clockRate</code> attribute, as noted in:
          <a href="https://github.com/w3c/ortc/issues/500">Issue 500</a>
        </li>
        <li>Removed use of "null if unset", as noted in: <a href=
        "https://github.com/w3c/ortc/issues/503">Issue 503</a>
        </li>
        <li>Updated <code><a>RTCSctpTransport</a></code> constructor, as noted in:
        <a href="https://github.com/w3c/ortc/issues/504">Issue 504</a>
        </li>
        <li>Clarified behavior of <code>getCapabilities()</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/509">Issue 509</a>
        </li>
        <li>Addressed issues with <code><a>RTCDataChannelParameters</a></code>, as noted
        in: <a href="https://github.com/w3c/ortc/issues/519">Issue 519</a>
        </li>
      </ol>
    </section>
    <section id="since-20-November-2015*">
      <h3>Changes since 20 November 2015</h3>
      <ol>
        <li>Clarified <code>unhandledrtp</code> event contents prior to calling
        <code>receive()</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/243">Issue 243</a>
        </li>
        <li>Added support for <code>ptime</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/160">Issue 160</a>
        </li>
        <li>Clarified behavior of <code>send()</code> when <var>encodings</var> is unset,
        as noted in: <a href="https://github.com/w3c/ortc/issues/187">Issue 187</a>
        </li>
        <li>Fixed invalid import in examples, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/250">Issue 250</a>
        </li>
        <li>Added support for Forward Error Correction (FEC), as noted in: <a href=
        "https://github.com/w3c/ortc/issues/253">Issue 253</a>
        </li>
        <li>Added support for "V" bit in <code><a>RTCRtpContributingSource</a></code>, as
        noted in: <a href="https://github.com/w3c/ortc/issues/263">Issue 263</a>
        </li>
        <li>Added definition of <code>maxBitrate</code>, as noted in: <a href=
        "https://github.com/w3c/webrtc-pc/issues/267">Issue 267</a>
        </li>
        <li>Clarified definition of <code>audioLevel</code>, as noted in: <a href=
        "https://github.com/w3c/webrtc-pc/issues/377">Issue 377</a>
        </li>
        <li>Use USVString for <code>datachannel.send()</code>, as noted in: <a href=
        "https://github.com/w3c/webrtc-pc/pull/387">PR 387</a>
        </li>
        <li>Clarified requirements for DTMF A-D tone support, as noted in: <a href=
        "https://github.com/w3c/webrtc-pc/issues/391">Issue 391</a>
        </li>
        <li>Changed <code><a>RTCRtpContributingSource</a></code> from an interface to a
        dictionary, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/289">Issue 289</a>
        </li>
        <li>Added support for <code>maxFramerate</code> encoding parameter, as noted in:
        <a href="https://github.com/w3c/webrtc-pc/issues/412">Issue 412</a>
        </li>
        <li>Clarified behavior of <code>getRemoteCertificates()</code>, as noted in:
        <a href="https://github.com/w3c/webrtc-pc/issues/378">Issue 378</a>
        </li>
        <li>Added support for remote peer ICE-lite implementation, as noted in:
          <a href="https://github.com/w3c/ortc/issues/293">Issue 293</a>
        </li>
        <li>Clarified <code><a>RTCDtlsTransportState</a></code> definition, as noted in:
        <a href="https://github.com/w3c/ortc/issues/294">Issue 294</a>
        </li>
        <li>Added explanation for unset <code>iceServers</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/302">Issue 302</a>
        </li>
        <li>Sync of certificate management API with WebRTC 1.0 changes, as noted in:
        <a href="https://github.com/w3c/ortc/issues/303">Issue 303</a>
        </li>
        <li>Added "public" to <code><a>RTCIceGatherPolicy</a></code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/305">Issue 305</a>
        </li>
        <li>Fixed problems in Examples 6, 7, 22 and 24, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/310">Issue 310</a>
        </li>
        <li>Clarified value of the <code>component</code> attribute, as noted in:
          <a href="https://github.com/w3c/ortc/issues/314">Issue 314</a>
        </li>
        <li>Clarified behavior with multiple local or remote certificates, as noted in:
        <a href="https://github.com/w3c/ortc/issues/317">Issue 317</a>
        </li>
        <li>Added <code>credentialType</code> attribute to Examples, as noted in:
          <a href="https://github.com/w3c/ortc/issues/323">Issue 323</a>
        </li>
        <li>Clarified alert handling in <code><a>RTCDtlsTransportState</a></code>, as
        noted in: <a href="https://github.com/w3c/ortc/issues/327">Issue 327</a>
        </li>
        <li>Added example <code><a>RTCIceTransportState</a></code> transitions, as noted
        in: <a href="https://github.com/w3c/ortc/issues/332">Issue 332</a>
        </li>
        <li>Clarified object garbage collection, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/338">Issue 338</a>
        </li>
        <li>Fixed certificate example errors, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/340">Issue 340</a>
        </li>
        <li>Clarified RTP matching rules, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/344">Issue 344</a>
        </li>
        <li>Clarified value of <code>rtcpTransport</code> for BUNDLE and RTP/RTCP mux
        use, as noted in: <a href="https://github.com/w3c/ortc/issues/349">Issue
        349</a>
        </li>
        <li>Fixed markup issues in respec, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/345">Issue 345</a>
        </li>
        <li>Addressed issues with document anchor links, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/353">Issue 353</a>
        </li>
        <li>Clarified meaning of <var>active</var> for an
        <code><a>RTCRtpReceiver</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/355">Issue 355</a>
        </li>
        <li>Updated <code><a>RTCDataChannel</a></code> event table, as noted in:
          <a href="https://github.com/w3c/ortc/issues/358">Issue 358</a>
        </li>
        <li>Clarified behavior of <var>resolutionScale</var>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/362">Issue 362</a>
        </li>
        <li>Updated RTP matching rules in Section 6.5 to support FEC/RTX/RED, as noted
        in: <a href="https://github.com/w3c/ortc/issues/368">Issue 368</a>
        </li>
        <li>Clarified certificate checking behavior, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/372">Issue 372</a>
        </li>
        <li>Clarified <code>encodingId</code> syntax, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/375">Issue 375</a>
        </li>
        <li>Added <code>url</code> to <code>RTCIceGathererEvent</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/376">Issue 376</a>
        </li>
        <li>Added <code>RangeError</code> for <var>resolutionScale</var> &lt;1.0, as
        noted in: <a href="https://github.com/w3c/ortc/issues/379">Issue 379</a>
        </li>
        <li>Added clarification on level asymmetry, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/382">Issue 382</a>
        </li>
        <li>Clarified DTMF tone requirements, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/384">Issue 384</a>
        </li>
        <li>Clarified Generic NACK settings, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/395">Issue 395</a>
        </li>
      </ol>
    </section>
    <section id="since-05-October-2015*">
      <h3>Changes since 05 October 2015</h3>
      <ol>
        <li>Added support for Opus capabilities and settings, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/252">Issue 252</a>
        </li>
        <li>Added <code>payloadType</code> attribute to
        <code><a>RTCRtpRtxParameters</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/254">Issue 254</a>
        </li>
        <li>Clarified meaning of unset <code>RTCRtpCodecCapability.clockRate</code>, as
        noted in: <a href="https://github.com/w3c/ortc/issues/255">Issue 255</a>
        </li>
        <li>Updated VP8 and H.264 capabilities and added VP8 and H.264 settings, as noted
        in: <a href="https://github.com/w3c/ortc/issues/258">Issue 258</a>
        </li>
        <li>Added RTX codec parameters, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/259">Issue 259</a>
        </li>
        <li>Added RED codec parameters, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/260">Issue 260</a>
        </li>
        <li>Substituted <code>degradationPreference</code> for <code>framerateBias</code>
        and moved it to <code><a>RTCRtpParameters</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/262">Issue 262</a>
        </li>
        <li>Added <a>RID</a> support to the <code><a>unhandledrtp</a></code> event, as
        noted in: <a href="https://github.com/w3c/ortc/issues/265">Issue 265</a>
        </li>
        <li>Updated references, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/268">Issue 268</a>
        </li>
        <li>Changed codec parameter and option names to camelCase, as noted in:
          <a href="https://github.com/w3c/ortc/issues/273">Issue 273</a>
        </li>
        <li>Added section of codec options, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/274">Issue 274</a>
        </li>
        <li>Clarified meaning of codec capabilities and options, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/275">Issue 275</a> and <a href=
        "https://github.com/w3c/ortc/issues/277">Issue 277</a>
        </li>
        <li>Clarified behavior in <code><a>RTCRtpSender</a></code> constructor and <code>
          setTrack()</code> when <code>track.readyState</code> is "ended", as noted in:
          <a href="https://github.com/w3c/ortc/issues/278">Issue 278</a>
        </li>
      </ol>
    </section>
    <section id="since-22-June-2015*">
      <h3>Changes since 22 June 2015</h3>
      <ol>
        <li>Added support for the WebRTC 1.0 certificate management API, as noted in:
        <a href="https://github.com/w3c/ortc/issues/195">Issue 195</a>
        </li>
        <li>Added certificate argument to the <code><a>RTCDtlsTransport</a></code>
        constructor, as noted in: <a href="https://github.com/w3c/ortc/issues/218">
          Issue 218</a>
        </li>
        <li>Added the <code>failed</code> state to
        <code><a>RTCDtlsTransportState</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/219">Issue 219</a>
        </li>
        <li>Changed <code>getNominatedCandidatePair</code> to
        <code>getSelectedCandidatePair</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/220">Issue 220</a>
        </li>
        <li>Added support for WebRTC 1.0 <code><a>RTCIceCredentialType</a></code>, as
        noted in: <a href="https://github.com/w3c/ortc/issues/222">Issue 222</a>
        </li>
        <li>Clarified behavior of <code>createAssociatedGatherer()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/223">Issue 223</a>
        </li>
        <li>Changed spelling from "iceservers" to "iceServers" for consistency with
        WebRTC 1.0, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/225">Issue 225</a>
        </li>
        <li>Added support for SCTP port numbers, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/227">Issue 227</a>
        </li>
        <li>Changed "outbound-rtp" to "outboundrtp" within the Statistics API, as noted
        in: <a href="https://github.com/w3c/ortc/issues/229">Issue 229</a>
        </li>
        <li>Changed <code>maxPacketLifetime</code> and <code>maxRetransmits</code> from
        unsigned short to unsigned long, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/231">Issue 231</a>
        </li>
        <li>Clarified DataChannel negotiation, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/233">Issue 233</a>
        </li>
        <li>Added <code>getContributingSources()</code> method, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/236">Issue 236</a>
        </li>
        <li>Fixes to Examples 5 and 6, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/237">Issue 237</a> and <a href=
        "https://github.com/w3c/ortc/issues/239">Issue 239</a>
        </li>
        <li>Clarified behavior of <code>RTCDataChannel.send()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/240">Issue 240</a>
        </li>
        <li>Fixed typos in Example 11, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/241">Issue 241</a> and <a href=
        "https://github.com/w3c/ortc/issues/248">Issue 248</a>
        </li>
        <li>Added text relating to <code><a>RTCDataChannel</a></code> exceptions and
        errors, as noted in: <a href="https://github.com/w3c/ortc/issues/242">Issue
        242</a>
        </li>
        <li>Reconciliation of <code><a>RTCRtpEncodingParameters</a></code> dictionary
        with WebRTC 1.0, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/249">Issue 249</a>
        </li>
      </ol>
    </section>
    <section id="since-07-May-2015*">
      <h3>Changes since 7 May 2015</h3>
      <ol>
        <li>Addressed Philipp Hancke's review comments, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/198">Issue 198</a>
        </li>
        <li>Added the <code>failed</code> state to
        <code><a>RTCIceTransportState</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/199">Issue 199</a>
        </li>
        <li>Added text relating to handling of incoming media packets prior to remote
        fingerprint verification, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/200">Issue 200</a>
        </li>
        <li>Added a <code>complete</code> attribute to the
        <code><a>RTCIceCandidateComplete</a></code> dictionary, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/207">Issue 207</a>
        </li>
        <li>Updated the description of <code>RTCIceGatherer.close()</code> and the <code>
          closed</code> state, as noted in: <a href=
          "https://github.com/w3c/ortc/issues/208">Issue 208</a>
        </li>
        <li>Updated Statistics API error handling to reflect proposed changes to the
        WebRTC 1.0 API, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/214">Issue 214</a>
        </li>
        <li>Updated Section 10 (RTCDtmfSender) to reflect changes in the WebRTC 1.0 API,
        as noted in: <a href="https://github.com/w3c/ortc/issues/215">Issue 215</a>
        </li>
        <li>Clarified state transitions due to consent failure, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/216">Issue 216</a>
        </li>
        <li>Added a reference to [[FEC]], as noted in: <a href=
        "https://github.com/w3c/ortc/issues/217">Issue 217</a>
        </li>
      </ol>
    </section>
    <section id="since-25-March-2015*">
      <h3>Changes since 25 March 2015</h3>
      <ol>
        <li>
          <code>sender.setTrack()</code> updated to return a Promise, as noted in:
          <a href="https://github.com/w3c/ortc/issues/148">Issue 148</a>
        </li>
        <li>Added <code>RTCIceGatherer</code> as an optional argument to the
        <code>RTCIceTransport</code> constructor, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/174">Issue 174</a>
        </li>
        <li>Clarified handling of contradictory RTP/RTCP multiplexing settings, as noted
        in: <a href="https://github.com/w3c/ortc/issues/185">Issue 185</a>
        </li>
        <li>Clarified error handling relating to <code><a>RTCIceTransport</a></code>,
        <code><a>RTCDtlsTransport</a></code> and <code><a>RTCIceGatherer</a></code>
        objects in the <code>closed</code> state, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/186">Issue 186</a>
        </li>
        <li>Added <code>component</code> attribute and
        <code>createAssociatedGatherer()</code> method to the
        <code><a>RTCIceGatherer</a></code> object, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/188">Issue 188</a>
        </li>
        <li>Added <code>close()</code> method to the <code><a>RTCIceGatherer</a></code>
        object as noted in: <a href="https://github.com/w3c/ortc/issues/189">Issue
        189</a>
        </li>
        <li>Clarified behavior of TCP candidate types, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/190">Issue 190</a>
        </li>
        <li>Clarified behavior of <code>iceGatherer.onlocalcandidate</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/191">Issue 191</a>
        </li>
        <li>Updated terminology in Section 1.1 as noted in: <a href=
        "https://github.com/w3c/ortc/issues/193">Issue 193</a>
        </li>
        <li>Updated <code><a>RTCDtlsTransportState</a></code> definitions, as noted in:
        <a href="https://github.com/w3c/ortc/issues/194">Issue 194</a>
        </li>
        <li>Updated <code><a>RTCIceTransportState</a></code> definitions, as noted in:
        <a href="https://github.com/w3c/ortc/issues/197">Issue 197</a>
        </li>
      </ol>
    </section>
    <section id="since-22-January-2015*">
      <h3>Changes since 22 January 2015</h3>
      <ol>
        <li>Updated Section 6.5 on RTP matching rules, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/48">Issue 48</a>
        </li>
        <li>Further updates to the Statistics API, reflecting: <a href=
        "https://github.com/w3c/ortc/issues/85">Issue 85</a>
        </li>
        <li>Added support for <code>maxptime</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/160">Issue 160</a>
        </li>
        <li>Revised the text relating to <code>RTCDtlsTransport.start()</code>, as noted
        in: <a href="https://github.com/w3c/ortc/issues/168">Issue 168</a>
        </li>
        <li>Clarified pre-requisites for <code>insertDTMF()</code>, based on: <a href=
        "https://github.com/w3c/ortc/issues/178">Issue 178</a>
        </li>
        <li>Added Section 6.5.3 and updated Section 9.5.1 to clarify aspects of RTCP
        sending and receiving, based on: <a href=
        "https://github.com/w3c/ortc/issues/180">Issue 180</a>
        </li>
        <li>Fixed miscellaneous typos, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/183">Issue 183</a>
        </li>
        <li>Added informative reference to [[RFC3264]] Section 5.1, as noted in:
          <a href="https://github.com/w3c/ortc/issues/184">Issue 184</a>
        </li>
      </ol>
    </section>
    <section id="since-14-October-2014*">
      <h3>Changes since 14 October 2014</h3>
      <ol>
        <li>Update to the Statistics API, reflecting: <a href=
        "https://github.com/w3c/ortc/issues/85">Issue 85</a>
        </li>
        <li>Update on 'automatic' use of scalable video coding, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/156">Issue 156</a>
        </li>
        <li>Update to the H.264 parameters, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/158">Issue 158</a>
        </li>
        <li>Update to the 'Big Picture', as noted in: <a href=
        "https://github.com/w3c/ortc/issues/159">Issue 159</a>
        </li>
        <li>Changed 'RTCIceTransportEvent' to 'RTCIceGathererEvent' as noted in:
          <a href="https://github.com/w3c/ortc/issues/161">Issue 161</a>
        </li>
        <li>Update to <code>RTCRtpUnhandledEvent</code> as noted in: <a href=
        "https://github.com/w3c/ortc/issues/163">Issue 163</a>
        </li>
        <li>Added support for <code>RTCIceGatherer.state</code> as noted in: <a href=
        "https://github.com/w3c/ortc/issues/164">Issue 164</a>
        </li>
        <li>Revised the text relating to <code>RTCIceTransport.start()</code> as noted
        in: <a href="https://github.com/w3c/ortc/issues/166">Issue 166</a>
        </li>
        <li>Added text relating to DTLS interoperability with WebRTC 1.0, as noted in:
        <a href="https://github.com/w3c/ortc/issues/167">Issue 167</a>
        </li>
        <li>Added a reference to the ICE consent specification, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/171">Issue 171</a>
        </li>
      </ol>
    </section>
    <section id="since-20-August-2014*">
      <h3>Changes since 20 August 2014</h3>
      <ol>
        <li>Address questions about <code>RTCDtlsTransport.start()</code>, as noted in:
        <a href="https://github.com/w3c/ortc/issues/146">Issue 146</a>
        </li>
        <li>Address questions about
        <code>RTCRtpCodecCapability.preferredPayloadType</code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/147">Issue 147</a>
        </li>
        <li>Address questions about <code>RTCRtpSender.setTrack()</code> error handling,
        as noted in: <a href="https://github.com/w3c/ortc/issues/148">Issue 148</a>
        </li>
        <li>Address 'automatic' use of scalable video coding (in
        <code>RTCRtpReceiver.receive()</code>) as noted in: <a href=
        "https://github.com/w3c/ortc/issues/149">Issue 149</a>
        </li>
        <li>Renamed RTCIceListener to <code><a>RTCIceGatherer</a></code> as noted in:
        <a href="https://github.com/w3c/ortc/issues/150">Issue 150</a>
        </li>
        <li>Added text on multiplexing of STUN, TURN, DTLS and RTP/RTCP, as noted in:
        <a href="https://github.com/w3c/ortc/issues/151">Issue 151</a>
        </li>
        <li>Address issue with queueing of candidate events within the
        <code><a>RTCIceGatherer</a></code>, as noted in: <a href=
        "https://github.com/w3c/ortc/issues/152">Issue 152</a>
        </li>
        <li>Clarify behavior of <code>RTCRtpReceiver.getCapabilities(kind)</code>, as
        noted in: <a href="https://github.com/w3c/ortc/issues/153">Issue 153</a>
        </li>
      </ol>
    </section>
    <section id="since-16-July-2014*">
      <h3>Changes since 16 July 2014</h3>
      <ol>
        <li>Clarification of the ICE restart issue, as noted in : <a href=
        "https://github.com/w3c/ortc/issues/93">Issue 93</a>
        </li>
        <li>Clarified onerror usage in sender and receiver objects, as noted in:
          <a href="https://github.com/w3c/ortc/issues/95">Issue 95</a>
        </li>
        <li>Clarified SST-MS capability issue noted in: <a href=
        "https://github.com/w3c/ortc/issues/108">Issue 108</a>
        </li>
        <li>Clarification of <code>send()</code> and <code>receive()</code> usage as
        noted in: <a href="https://github.com/w3c/ortc/issues/119">Issue 119</a>
        </li>
        <li>Changed ICE state diagram as noted in: <a href=
        "https://github.com/w3c/ortc/issues/122">Issue 122</a>
        </li>
        <li>Removed getParameters methods and changed send() method as noted in:
          <a href="https://github.com/w3c/ortc/issues/136">Issue 136</a>
        </li>
        <li>Changed definition of framerateScale and resolutionScale as noted in:
          <a href="https://github.com/w3c/ortc/issues/137">Issue 137</a>
        </li>
        <li>Substituted <code>muxId</code> for <code>receiverId</code> as noted in:
        <a href="https://github.com/w3c/ortc/issues/138">Issue 138</a> and
          <a href="https://github.com/w3c/ortc/issues/140">Issue 140</a>
        </li>
        <li>Clarified the setting of <code>track.kind</code> as described in: <a href=
        "https://github.com/w3c/ortc/issues/141">Issue 141</a>
        </li>
        <li>Added SSRC conflict event to the <code><a>RTCRtpSender</a></code>, as
        described in: <a href="https://github.com/w3c/ortc/issues/143">Issue 143</a>
        </li>
        <li>Addressed the "end of candidates" issues noted in: <a href=
        "https://github.com/w3c/ortc/issues/142">Issue 142</a> and <a href=
        "https://github.com/w3c/ortc/issues/144">Issue 144</a>
        </li>
      </ol>
    </section>
    <section id="since-16-June-2014*">
      <h3>Changes since 16 June 2014</h3>
      <ol>
        <li>Added section on WebRTC 1.0 compatibility issues, responding to <a href=
        "https://github.com/w3c/ortc/issues/66">Issue 66</a>
        </li>
        <li>Added Identity support, as described in <a href=
        "https://github.com/w3c/ortc/issues/78">Issue 78</a>
        </li>
        <li>Reworked <code>getStats()</code> method, as described in <a href=
        "https://github.com/w3c/ortc/issues/85">Issue 85</a>
        </li>
        <li>Removed ICE restart method described in <a href=
        "https://github.com/w3c/ortc/issues/93">Issue 93</a>
        </li>
        <li>Addressed CNAME and synchronization context issues described in <a href=
        "https://github.com/w3c/ortc/issues/94">Issue 94</a>
        </li>
        <li>Fixed WebIDL issues noted in <a href=
        "https://github.com/w3c/ortc/issues/97">Issue 97</a>
        </li>
        <li>Addressed NITs described in <a href=
        "https://github.com/w3c/ortc/issues/99">Issue 99</a>
        </li>
        <li>DTLS transport issues fixed as described in <a href=
        "https://github.com/w3c/ortc/issues/100">Issue 100</a>
        </li>
        <li>ICE transport issues fixed as described in <a href=
        "https://github.com/w3c/ortc/issues/101">Issue 101</a>
        </li>
        <li>ICE transport controller fixes made as described in <a href=
        "https://github.com/w3c/ortc/issues/102">Issue 102</a>
        </li>
        <li>Sender and Receiver object fixes made as described in <a href=
        "https://github.com/w3c/ortc/issues/103">Issue 103</a>
        </li>
        <li>Fixed <code><a>RTCRtpEncodingParameters</a></code> default issues described
        in <a href="https://github.com/w3c/ortc/issues/104">Issue 104</a>
        </li>
        <li>Fixed 'Big Picture' issues descibed in <a href=
        "https://github.com/w3c/ortc/issues/105">Issue 105</a>
        </li>
        <li>Fixed <code><a>RTCRtpParameters</a></code> default issues described in
        <a href="https://github.com/w3c/ortc/issues/106">Issue 106</a>
        </li>
        <li>Added a multi-stream capability, as noted in <a href=
        "https://github.com/w3c/ortc/issues/108">Issue 108</a>
        </li>
        <li>Removed quality scalability capabilities and parameters, as described in
        <a href="https://github.com/w3c/ortc/issues/109">Issue 109</a>
        </li>
        <li>Added scalability examples as requested in <a href=
        "https://github.com/w3c/ortc/issues/110">Issue 110</a>
        </li>
        <li>Addressed WebRTC 1.0 Data Channel compatibility issue described in <a href=
        "https://github.com/w3c/ortc/issues/111">Issue 111</a>
        </li>
        <li>Removed header extensions from <code><a>RTCRtpCodecParameters</a></code> as
        described in <a href="https://github.com/w3c/ortc/issues/113">Issue 113</a>
        </li>
        <li>Addressed RTP/RTCP non-mux issues with IdP as described in <a href=
        "https://github.com/w3c/ortc/issues/114">Issue 114</a>
        </li>
        <li>Added getParameter methods to <code><a>RTCRtpSender</a></code> and <code><a>
          RTCRtpReceiver</a></code> objects, as described in <a href=
          "https://github.com/w3c/ortc/issues/116">Issue 116</a>
        </li>
        <li>Added layering diagrams as requested in <a href=
        "https://github.com/w3c/ortc/issues/117">Issue 117</a>
        </li>
        <li>Added a typedef for <code>payloadtype</code>, as described in <a href=
        "https://github.com/w3c/ortc/issues/118">Issue 118</a>
        </li>
        <li>Moved <code>onerror</code> from the <code><a>RTCIceTransport</a></code>
        object to the <code>RTCIceListener</code> object as described in <a href=
        "https://github.com/w3c/ortc/issues/121">Issue 121</a>
        </li>
        <li>Added explanation of Voice Activity Detection (VAD), responding to <a href=
        "https://github.com/w3c/ortc/issues/129">Issue 129</a>
        </li>
        <li>Clarified the meaning of <code>maxTemporalLayers</code> and
        <code>maxSpatialLayers</code>, as noted in <a href=
        "https://github.com/w3c/ortc/issues/130">Issue 130</a>
        </li>
        <li>Added [[!RFC6051]] to the list of header extensions and removed RFC 5450, as
        noted in <a href="https://github.com/w3c/ortc/issues/131">Issue 131</a>
        </li>
        <li>Addressed ICE terminology issues, as described in <a href=
        "https://github.com/w3c/ortc/issues/132">Issue 132</a>
        </li>
        <li>Separated references into Normative and Informative, as noted in <a href=
        "https://github.com/w3c/ortc/issues/133">Issue 133</a>
        </li>
      </ol>
    </section>
    <section id="since-14-May-2014*">
      <h3>Changes since 14 May 2014</h3>
      <ol>
        <li>Added support for non-multiplexed RTP/RTCP and ICE freezing, as described in
        <a href="https://github.com/w3c/ortc/issues/57">Issue 57</a>
        </li>
        <li>Added support for <code>getRemoteCertificates()</code>, as described in
        <a href="https://github.com/w3c/ortc/issues/67">Issue 67</a>
        </li>
        <li>Removed <code>filterParameters()</code> and <code>createParameters()</code>
        methods, as described in <a href=
        "https://github.com/w3c/ortc/issues/80">Issue 80</a>
        </li>
        <li>Partially addressed capabilities issues, as described in <a href=
        "https://github.com/w3c/ortc/issues/84">Issue 84</a>
        </li>
        <li>Addressed WebIDL type issues described in <a href=
        "https://github.com/w3c/ortc/issues/88">Issue 88</a>
        </li>
        <li>Addressed Overview section issues described in <a href=
        "https://github.com/w3c/ortc/issues/91">Issue 91</a>
        </li>
        <li>Addressed readonly attribute issues described in <a href=
        "https://github.com/w3c/ortc/issues/92">Issue 92</a>
        </li>
        <li>Added ICE restart method to address the issue described in <a href=
        "https://github.com/w3c/ortc/issues/93">Issue 93</a>
        </li>
        <li>Added onerror eventhandler to sender and receiver objects as described in
        <a href="https://github.com/w3c/ortc/issues/95">Issue 95</a>
        </li>
      </ol>
    </section>
    <section id="since-29-April-2014*">
      <h3>Changes since 29 April 2014</h3>
      <ol>
        <li>ICE restart explanation added, as described in <a href=
        "https://github.com/w3c/ortc/issues/59">Issue 59</a>
        </li>
        <li>Fixes for error handling, as described in <a href=
        "https://github.com/w3c/ortc/issues/75">Issue 75</a>
        </li>
        <li>Fixes for miscellaneous NITs, as described in <a href=
        "https://github.com/w3c/ortc/issues/76">Issue 76</a>
        </li>
        <li>Enable retrieval of the SSRC to be used by RTCP, as described in <a href=
        "https://github.com/w3c/ortc/issues/77">Issue 77</a>
        </li>
        <li>Support for retrieval of audio and video capabilities, as described in
        <a href="https://github.com/w3c/ortc/issues/81">Issue 81</a>
        </li>
        <li>getStats interface updated, as described in <a href=
        "https://github.com/w3c/ortc/issues/82">Issue 82</a>
        </li>
        <li>Partially addressed SVC issues described in <a href=
        "https://github.com/w3c/ortc/issues/83">Issue 83</a>
        </li>
        <li>Partially addressed statistics update issues described in <a href=
        "https://github.com/w3c/ortc/issues/85">Issue 85</a>
        </li>
      </ol>
    </section>
    <section id="since-12-April-2014*">
      <h3>Changes since 12 April 2014</h3>
      <ol>
        <li>Fixes for error handling, as described in <a href=
        "https://github.com/w3c/ortc/issues/26">Issue 26</a>
        </li>
        <li>Support for contributing sources removed (re-classified as a 1.2 feature), as
        described in <a href="https://github.com/w3c/ortc/issues/27">Issue 27</a>
        </li>
        <li>Cleanup of DataChannel construction, as described in <a href=
        "https://github.com/w3c/ortc/issues/60">Issue 60</a>
        </li>
        <li>Separate proposal on simulcast/layering, as described in <a href=
        "https://github.com/w3c/ortc/issues/61">Issue 61</a>
        </li>
        <li>Separate proposal on quality, as described in <a href=
        "https://github.com/w3c/ortc/issues/62">Issue 62</a>
        </li>
        <li>Fix for TCP candidate type, as described in <a href=
        "https://github.com/w3c/ortc/issues/63">Issue 63</a>
        </li>
        <li>Fix to the fingerprint attribute, as described in <a href=
        "https://github.com/w3c/ortc/issues/64">Issue 64</a>
        </li>
        <li>Fix to RTCRtpFeatures, as described in <a href=
        "https://github.com/w3c/ortc/issues/65">Issue 65</a>
        </li>
        <li>Support for retrieval of remote certificates, as described in <a href=
        "https://github.com/w3c/ortc/issues/67">Issue 67</a>
        </li>
        <li>Support for ICE error handling, described in <a href=
        "https://github.com/w3c/ortc/issues/68">Issue 68</a>
        </li>
        <li>Support for Data Channel send rate control, as described in <a href=
        "https://github.com/w3c/ortc/issues/69">Issue 69</a>
        </li>
        <li>Support for capabilities and settings, as described in <a href=
        "https://github.com/w3c/ortc/issues/70">Issue 70</a>
        </li>
        <li>Removal of duplicate RTCIceListener functionality, as described in <a href=
        "https://github.com/w3c/ortc/issues/71">Issue 71</a>
        </li>
        <li>ICE gathering state added, as described in <a href=
        "https://github.com/w3c/ortc/issues/72">Issue 72</a>
        </li>
        <li>Removed ICE role from the ICE transport constructor, as described in
          <a href="https://github.com/w3c/ortc/issues/73">Issue 73</a>
        </li>
      </ol>
    </section>
    <section id="since-13-February-2014*">
      <h3>Changes since 13 February 2014</h3>
      <ol>
        <li>Support for contributing source information added, as described in <a href=
        "https://github.com/w3c/ortc/issues/27">Issue 27</a>
        </li>
        <li>Support for control of quality, resolution, framerate and layering added, as
        described in <a href="https://github.com/w3c/ortc/issues/31">Issue 31</a>
        </li>
        <li>
          <code><a>RTCRtpListener</a></code> object added and figure in Section 1
          updated, as described in <a href=
          "https://github.com/w3c/ortc/issues/32">Issue 32</a>
        </li>
        <li>More complete support for RTP and Codec Parameters added, as described in
        <a href="https://github.com/w3c/ortc/issues/33">Issue 33</a>
        </li>
        <li>Data Channel transport problem fixed, as described in <a href=
        "https://github.com/w3c/ortc/issues/34">Issue 34</a>
        </li>
        <li>Various NITs fixed, as described in <a href=
        "https://github.com/w3c/ortc/issues/37">Issue 37</a>
        </li>
        <li>
          <code><a>RTCDtlsTransport</a></code> operation and interface definition
          updates, as described in: <a href=
          "https://github.com/w3c/ortc/issues/38">Issue 38</a>
        </li>
        <li>Default values of some dictionary attributes added, to partially address the
        issue described in: <a href="https://github.com/w3c/ortc/issues/39">Issue
        39</a>
        </li>
        <li>Support for ICE TCP added, as described in <a href=
        "https://github.com/w3c/ortc/issues/41">Issue 41</a>
        </li>
        <li>Fixed issue with sequences as attributes, as described in <a href=
        "https://github.com/w3c/ortc/issues/43">Issue 43</a>
        </li>
        <li>Fix for issues with onlocalcandidate, as described in <a href=
        "https://github.com/w3c/ortc/issues/44">Issue 44</a>
        </li>
        <li>Initial stab at a Stats API, as requested in <a href=
        "https://github.com/w3c/ortc/issues/46">Issue 46</a>
        </li>
        <li>Added support for ICE gather policy, as described in <a href=
        "https://github.com/w3c/ortc/issues/47">Issue 47</a>
        </li>
      </ol>
    </section>
    <section id="since-07-November-2013*">
      <h3>Changes since 07 November 2013</h3>
      <ol>
        <li>RTCTrack split into <code><a>RTCRtpSender</a></code> and
        <code><a>RTCRtpReceiver</a></code> objects, as proposed on <a href=
        "http://lists.w3.org/Archives/Public/public-orca/2014Jan/0000.html">06 January
        2014.</a>
        </li>
        <li>RTCConnection split into <code><a>RTCIceTransport</a></code> and
        <code><a>RTCDtlsTransport</a></code> objects, as proposed on <a href=
        "http://lists.w3.org/Archives/Public/public-orca/2014Jan/0005.html">09 January
        2014.</a>
        </li>
        <li>
          <code><a>RTCSctpTransport</a></code> object added, as described in <a href=
          "https://github.com/w3c/ortc/issues/25">Issue 25</a>
        </li>
        <li>RTCRtpHeaderExtensionParameters added, as described in <a href=
        "https://github.com/w3c/ortc/issues/28">Issue 28</a>
        </li>
        <li>RTCIceListener added, in order to support parallel forking, as described in
        <a href="https://github.com/w3c/ortc/issues/29">Issue 29</a>
        </li>
        <li>DTMF support added, as described in <a href=
        "https://github.com/w3c/ortc/issues/30">Issue 30</a>
        </li>
      </ol>
    </section>
  </section>
</body>
</html>
